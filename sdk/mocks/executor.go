// Code generated by mockery v2.46.3. DO NOT EDIT.

package mocks

import (
	common "github.com/ethereum/go-ethereum/common"
	mock "github.com/stretchr/testify/mock"

	types "github.com/smartcontractkit/mcms/types"
)

// Executor is an autogenerated mock type for the Executor type
type Executor struct {
	mock.Mock
}

type Executor_Expecter struct {
	mock *mock.Mock
}

func (_m *Executor) EXPECT() *Executor_Expecter {
	return &Executor_Expecter{mock: &_m.Mock}
}

// ExecuteOperation provides a mock function with given fields: metadata, nonce, proof, op
func (_m *Executor) ExecuteOperation(metadata types.ChainMetadata, nonce uint32, proof []common.Hash, op types.ChainOperation) (string, error) {
	ret := _m.Called(metadata, nonce, proof, op)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteOperation")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(types.ChainMetadata, uint32, []common.Hash, types.ChainOperation) (string, error)); ok {
		return rf(metadata, nonce, proof, op)
	}
	if rf, ok := ret.Get(0).(func(types.ChainMetadata, uint32, []common.Hash, types.ChainOperation) string); ok {
		r0 = rf(metadata, nonce, proof, op)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(types.ChainMetadata, uint32, []common.Hash, types.ChainOperation) error); ok {
		r1 = rf(metadata, nonce, proof, op)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Executor_ExecuteOperation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteOperation'
type Executor_ExecuteOperation_Call struct {
	*mock.Call
}

// ExecuteOperation is a helper method to define mock.On call
//   - metadata types.ChainMetadata
//   - nonce uint32
//   - proof []common.Hash
//   - op types.ChainOperation
func (_e *Executor_Expecter) ExecuteOperation(metadata interface{}, nonce interface{}, proof interface{}, op interface{}) *Executor_ExecuteOperation_Call {
	return &Executor_ExecuteOperation_Call{Call: _e.mock.On("ExecuteOperation", metadata, nonce, proof, op)}
}

func (_c *Executor_ExecuteOperation_Call) Run(run func(metadata types.ChainMetadata, nonce uint32, proof []common.Hash, op types.ChainOperation)) *Executor_ExecuteOperation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.ChainMetadata), args[1].(uint32), args[2].([]common.Hash), args[3].(types.ChainOperation))
	})
	return _c
}

func (_c *Executor_ExecuteOperation_Call) Return(_a0 string, _a1 error) *Executor_ExecuteOperation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Executor_ExecuteOperation_Call) RunAndReturn(run func(types.ChainMetadata, uint32, []common.Hash, types.ChainOperation) (string, error)) *Executor_ExecuteOperation_Call {
	_c.Call.Return(run)
	return _c
}

// GetConfig provides a mock function with given fields: mcmAddress
func (_m *Executor) GetConfig(mcmAddress string) (*types.Config, error) {
	ret := _m.Called(mcmAddress)

	if len(ret) == 0 {
		panic("no return value specified for GetConfig")
	}

	var r0 *types.Config
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*types.Config, error)); ok {
		return rf(mcmAddress)
	}
	if rf, ok := ret.Get(0).(func(string) *types.Config); ok {
		r0 = rf(mcmAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Config)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(mcmAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Executor_GetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConfig'
type Executor_GetConfig_Call struct {
	*mock.Call
}

// GetConfig is a helper method to define mock.On call
//   - mcmAddress string
func (_e *Executor_Expecter) GetConfig(mcmAddress interface{}) *Executor_GetConfig_Call {
	return &Executor_GetConfig_Call{Call: _e.mock.On("GetConfig", mcmAddress)}
}

func (_c *Executor_GetConfig_Call) Run(run func(mcmAddress string)) *Executor_GetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Executor_GetConfig_Call) Return(_a0 *types.Config, _a1 error) *Executor_GetConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Executor_GetConfig_Call) RunAndReturn(run func(string) (*types.Config, error)) *Executor_GetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetOpCount provides a mock function with given fields: mcmAddress
func (_m *Executor) GetOpCount(mcmAddress string) (uint64, error) {
	ret := _m.Called(mcmAddress)

	if len(ret) == 0 {
		panic("no return value specified for GetOpCount")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (uint64, error)); ok {
		return rf(mcmAddress)
	}
	if rf, ok := ret.Get(0).(func(string) uint64); ok {
		r0 = rf(mcmAddress)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(mcmAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Executor_GetOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOpCount'
type Executor_GetOpCount_Call struct {
	*mock.Call
}

// GetOpCount is a helper method to define mock.On call
//   - mcmAddress string
func (_e *Executor_Expecter) GetOpCount(mcmAddress interface{}) *Executor_GetOpCount_Call {
	return &Executor_GetOpCount_Call{Call: _e.mock.On("GetOpCount", mcmAddress)}
}

func (_c *Executor_GetOpCount_Call) Run(run func(mcmAddress string)) *Executor_GetOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Executor_GetOpCount_Call) Return(_a0 uint64, _a1 error) *Executor_GetOpCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Executor_GetOpCount_Call) RunAndReturn(run func(string) (uint64, error)) *Executor_GetOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoot provides a mock function with given fields: mcmAddress
func (_m *Executor) GetRoot(mcmAddress string) (common.Hash, uint32, error) {
	ret := _m.Called(mcmAddress)

	if len(ret) == 0 {
		panic("no return value specified for GetRoot")
	}

	var r0 common.Hash
	var r1 uint32
	var r2 error
	if rf, ok := ret.Get(0).(func(string) (common.Hash, uint32, error)); ok {
		return rf(mcmAddress)
	}
	if rf, ok := ret.Get(0).(func(string) common.Hash); ok {
		r0 = rf(mcmAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(string) uint32); ok {
		r1 = rf(mcmAddress)
	} else {
		r1 = ret.Get(1).(uint32)
	}

	if rf, ok := ret.Get(2).(func(string) error); ok {
		r2 = rf(mcmAddress)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Executor_GetRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoot'
type Executor_GetRoot_Call struct {
	*mock.Call
}

// GetRoot is a helper method to define mock.On call
//   - mcmAddress string
func (_e *Executor_Expecter) GetRoot(mcmAddress interface{}) *Executor_GetRoot_Call {
	return &Executor_GetRoot_Call{Call: _e.mock.On("GetRoot", mcmAddress)}
}

func (_c *Executor_GetRoot_Call) Run(run func(mcmAddress string)) *Executor_GetRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Executor_GetRoot_Call) Return(_a0 common.Hash, _a1 uint32, _a2 error) *Executor_GetRoot_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Executor_GetRoot_Call) RunAndReturn(run func(string) (common.Hash, uint32, error)) *Executor_GetRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetRootMetadata provides a mock function with given fields: mcmAddress
func (_m *Executor) GetRootMetadata(mcmAddress string) (types.ChainMetadata, error) {
	ret := _m.Called(mcmAddress)

	if len(ret) == 0 {
		panic("no return value specified for GetRootMetadata")
	}

	var r0 types.ChainMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (types.ChainMetadata, error)); ok {
		return rf(mcmAddress)
	}
	if rf, ok := ret.Get(0).(func(string) types.ChainMetadata); ok {
		r0 = rf(mcmAddress)
	} else {
		r0 = ret.Get(0).(types.ChainMetadata)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(mcmAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Executor_GetRootMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRootMetadata'
type Executor_GetRootMetadata_Call struct {
	*mock.Call
}

// GetRootMetadata is a helper method to define mock.On call
//   - mcmAddress string
func (_e *Executor_Expecter) GetRootMetadata(mcmAddress interface{}) *Executor_GetRootMetadata_Call {
	return &Executor_GetRootMetadata_Call{Call: _e.mock.On("GetRootMetadata", mcmAddress)}
}

func (_c *Executor_GetRootMetadata_Call) Run(run func(mcmAddress string)) *Executor_GetRootMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Executor_GetRootMetadata_Call) Return(_a0 types.ChainMetadata, _a1 error) *Executor_GetRootMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Executor_GetRootMetadata_Call) RunAndReturn(run func(string) (types.ChainMetadata, error)) *Executor_GetRootMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// HashMetadata provides a mock function with given fields: metadata
func (_m *Executor) HashMetadata(metadata types.ChainMetadata) (common.Hash, error) {
	ret := _m.Called(metadata)

	if len(ret) == 0 {
		panic("no return value specified for HashMetadata")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(types.ChainMetadata) (common.Hash, error)); ok {
		return rf(metadata)
	}
	if rf, ok := ret.Get(0).(func(types.ChainMetadata) common.Hash); ok {
		r0 = rf(metadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(types.ChainMetadata) error); ok {
		r1 = rf(metadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Executor_HashMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashMetadata'
type Executor_HashMetadata_Call struct {
	*mock.Call
}

// HashMetadata is a helper method to define mock.On call
//   - metadata types.ChainMetadata
func (_e *Executor_Expecter) HashMetadata(metadata interface{}) *Executor_HashMetadata_Call {
	return &Executor_HashMetadata_Call{Call: _e.mock.On("HashMetadata", metadata)}
}

func (_c *Executor_HashMetadata_Call) Run(run func(metadata types.ChainMetadata)) *Executor_HashMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.ChainMetadata))
	})
	return _c
}

func (_c *Executor_HashMetadata_Call) Return(_a0 common.Hash, _a1 error) *Executor_HashMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Executor_HashMetadata_Call) RunAndReturn(run func(types.ChainMetadata) (common.Hash, error)) *Executor_HashMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// HashOperation provides a mock function with given fields: opCount, metadata, op
func (_m *Executor) HashOperation(opCount uint32, metadata types.ChainMetadata, op types.ChainOperation) (common.Hash, error) {
	ret := _m.Called(opCount, metadata, op)

	if len(ret) == 0 {
		panic("no return value specified for HashOperation")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(uint32, types.ChainMetadata, types.ChainOperation) (common.Hash, error)); ok {
		return rf(opCount, metadata, op)
	}
	if rf, ok := ret.Get(0).(func(uint32, types.ChainMetadata, types.ChainOperation) common.Hash); ok {
		r0 = rf(opCount, metadata, op)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(uint32, types.ChainMetadata, types.ChainOperation) error); ok {
		r1 = rf(opCount, metadata, op)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Executor_HashOperation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashOperation'
type Executor_HashOperation_Call struct {
	*mock.Call
}

// HashOperation is a helper method to define mock.On call
//   - opCount uint32
//   - metadata types.ChainMetadata
//   - op types.ChainOperation
func (_e *Executor_Expecter) HashOperation(opCount interface{}, metadata interface{}, op interface{}) *Executor_HashOperation_Call {
	return &Executor_HashOperation_Call{Call: _e.mock.On("HashOperation", opCount, metadata, op)}
}

func (_c *Executor_HashOperation_Call) Run(run func(opCount uint32, metadata types.ChainMetadata, op types.ChainOperation)) *Executor_HashOperation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint32), args[1].(types.ChainMetadata), args[2].(types.ChainOperation))
	})
	return _c
}

func (_c *Executor_HashOperation_Call) Return(_a0 common.Hash, _a1 error) *Executor_HashOperation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Executor_HashOperation_Call) RunAndReturn(run func(uint32, types.ChainMetadata, types.ChainOperation) (common.Hash, error)) *Executor_HashOperation_Call {
	_c.Call.Return(run)
	return _c
}

// SetRoot provides a mock function with given fields: metadata, proof, root, validUntil, sortedSignatures
func (_m *Executor) SetRoot(metadata types.ChainMetadata, proof []common.Hash, root [32]byte, validUntil uint32, sortedSignatures []types.Signature) (string, error) {
	ret := _m.Called(metadata, proof, root, validUntil, sortedSignatures)

	if len(ret) == 0 {
		panic("no return value specified for SetRoot")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(types.ChainMetadata, []common.Hash, [32]byte, uint32, []types.Signature) (string, error)); ok {
		return rf(metadata, proof, root, validUntil, sortedSignatures)
	}
	if rf, ok := ret.Get(0).(func(types.ChainMetadata, []common.Hash, [32]byte, uint32, []types.Signature) string); ok {
		r0 = rf(metadata, proof, root, validUntil, sortedSignatures)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(types.ChainMetadata, []common.Hash, [32]byte, uint32, []types.Signature) error); ok {
		r1 = rf(metadata, proof, root, validUntil, sortedSignatures)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Executor_SetRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRoot'
type Executor_SetRoot_Call struct {
	*mock.Call
}

// SetRoot is a helper method to define mock.On call
//   - metadata types.ChainMetadata
//   - proof []common.Hash
//   - root [32]byte
//   - validUntil uint32
//   - sortedSignatures []types.Signature
func (_e *Executor_Expecter) SetRoot(metadata interface{}, proof interface{}, root interface{}, validUntil interface{}, sortedSignatures interface{}) *Executor_SetRoot_Call {
	return &Executor_SetRoot_Call{Call: _e.mock.On("SetRoot", metadata, proof, root, validUntil, sortedSignatures)}
}

func (_c *Executor_SetRoot_Call) Run(run func(metadata types.ChainMetadata, proof []common.Hash, root [32]byte, validUntil uint32, sortedSignatures []types.Signature)) *Executor_SetRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.ChainMetadata), args[1].([]common.Hash), args[2].([32]byte), args[3].(uint32), args[4].([]types.Signature))
	})
	return _c
}

func (_c *Executor_SetRoot_Call) Return(_a0 string, _a1 error) *Executor_SetRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Executor_SetRoot_Call) RunAndReturn(run func(types.ChainMetadata, []common.Hash, [32]byte, uint32, []types.Signature) (string, error)) *Executor_SetRoot_Call {
	_c.Call.Return(run)
	return _c
}

// NewExecutor creates a new instance of Executor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewExecutor(t interface {
	mock.TestingT
	Cleanup(func())
}) *Executor {
	mock := &Executor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Code generated by mockery v2.53.4. DO NOT EDIT.

package mock_aptossdk

import (
	aptos "github.com/aptos-labs/aptos-go-sdk"
	api "github.com/aptos-labs/aptos-go-sdk/api"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// AptosRpcClient is an autogenerated mock type for the AptosRpcClient type
type AptosRpcClient struct {
	mock.Mock
}

type AptosRpcClient_Expecter struct {
	mock *mock.Mock
}

func (_m *AptosRpcClient) EXPECT() *AptosRpcClient_Expecter {
	return &AptosRpcClient_Expecter{mock: &_m.Mock}
}

// Account provides a mock function with given fields: address, ledgerVersion
func (_m *AptosRpcClient) Account(address aptos.AccountAddress, ledgerVersion ...uint64) (aptos.AccountInfo, error) {
	_va := make([]interface{}, len(ledgerVersion))
	for _i := range ledgerVersion {
		_va[_i] = ledgerVersion[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, address)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Account")
	}

	var r0 aptos.AccountInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, ...uint64) (aptos.AccountInfo, error)); ok {
		return rf(address, ledgerVersion...)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, ...uint64) aptos.AccountInfo); ok {
		r0 = rf(address, ledgerVersion...)
	} else {
		r0 = ret.Get(0).(aptos.AccountInfo)
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, ...uint64) error); ok {
		r1 = rf(address, ledgerVersion...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_Account_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Account'
type AptosRpcClient_Account_Call struct {
	*mock.Call
}

// Account is a helper method to define mock.On call
//   - address aptos.AccountAddress
//   - ledgerVersion ...uint64
func (_e *AptosRpcClient_Expecter) Account(address interface{}, ledgerVersion ...interface{}) *AptosRpcClient_Account_Call {
	return &AptosRpcClient_Account_Call{Call: _e.mock.On("Account",
		append([]interface{}{address}, ledgerVersion...)...)}
}

func (_c *AptosRpcClient_Account_Call) Run(run func(address aptos.AccountAddress, ledgerVersion ...uint64)) *AptosRpcClient_Account_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]uint64, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(uint64)
			}
		}
		run(args[0].(aptos.AccountAddress), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_Account_Call) Return(_a0 aptos.AccountInfo, _a1 error) *AptosRpcClient_Account_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_Account_Call) RunAndReturn(run func(aptos.AccountAddress, ...uint64) (aptos.AccountInfo, error)) *AptosRpcClient_Account_Call {
	_c.Call.Return(run)
	return _c
}

// AccountAPTBalance provides a mock function with given fields: address, ledgerVersion
func (_m *AptosRpcClient) AccountAPTBalance(address aptos.AccountAddress, ledgerVersion ...uint64) (uint64, error) {
	_va := make([]interface{}, len(ledgerVersion))
	for _i := range ledgerVersion {
		_va[_i] = ledgerVersion[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, address)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountAPTBalance")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, ...uint64) (uint64, error)); ok {
		return rf(address, ledgerVersion...)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, ...uint64) uint64); ok {
		r0 = rf(address, ledgerVersion...)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, ...uint64) error); ok {
		r1 = rf(address, ledgerVersion...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_AccountAPTBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountAPTBalance'
type AptosRpcClient_AccountAPTBalance_Call struct {
	*mock.Call
}

// AccountAPTBalance is a helper method to define mock.On call
//   - address aptos.AccountAddress
//   - ledgerVersion ...uint64
func (_e *AptosRpcClient_Expecter) AccountAPTBalance(address interface{}, ledgerVersion ...interface{}) *AptosRpcClient_AccountAPTBalance_Call {
	return &AptosRpcClient_AccountAPTBalance_Call{Call: _e.mock.On("AccountAPTBalance",
		append([]interface{}{address}, ledgerVersion...)...)}
}

func (_c *AptosRpcClient_AccountAPTBalance_Call) Run(run func(address aptos.AccountAddress, ledgerVersion ...uint64)) *AptosRpcClient_AccountAPTBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]uint64, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(uint64)
			}
		}
		run(args[0].(aptos.AccountAddress), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_AccountAPTBalance_Call) Return(_a0 uint64, _a1 error) *AptosRpcClient_AccountAPTBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_AccountAPTBalance_Call) RunAndReturn(run func(aptos.AccountAddress, ...uint64) (uint64, error)) *AptosRpcClient_AccountAPTBalance_Call {
	_c.Call.Return(run)
	return _c
}

// AccountModule provides a mock function with given fields: address, moduleName, ledgerVersion
func (_m *AptosRpcClient) AccountModule(address aptos.AccountAddress, moduleName string, ledgerVersion ...uint64) (*api.MoveBytecode, error) {
	_va := make([]interface{}, len(ledgerVersion))
	for _i := range ledgerVersion {
		_va[_i] = ledgerVersion[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, address, moduleName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountModule")
	}

	var r0 *api.MoveBytecode
	var r1 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, ...uint64) (*api.MoveBytecode, error)); ok {
		return rf(address, moduleName, ledgerVersion...)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, ...uint64) *api.MoveBytecode); ok {
		r0 = rf(address, moduleName, ledgerVersion...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MoveBytecode)
		}
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, string, ...uint64) error); ok {
		r1 = rf(address, moduleName, ledgerVersion...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_AccountModule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountModule'
type AptosRpcClient_AccountModule_Call struct {
	*mock.Call
}

// AccountModule is a helper method to define mock.On call
//   - address aptos.AccountAddress
//   - moduleName string
//   - ledgerVersion ...uint64
func (_e *AptosRpcClient_Expecter) AccountModule(address interface{}, moduleName interface{}, ledgerVersion ...interface{}) *AptosRpcClient_AccountModule_Call {
	return &AptosRpcClient_AccountModule_Call{Call: _e.mock.On("AccountModule",
		append([]interface{}{address, moduleName}, ledgerVersion...)...)}
}

func (_c *AptosRpcClient_AccountModule_Call) Run(run func(address aptos.AccountAddress, moduleName string, ledgerVersion ...uint64)) *AptosRpcClient_AccountModule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]uint64, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(uint64)
			}
		}
		run(args[0].(aptos.AccountAddress), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_AccountModule_Call) Return(_a0 *api.MoveBytecode, _a1 error) *AptosRpcClient_AccountModule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_AccountModule_Call) RunAndReturn(run func(aptos.AccountAddress, string, ...uint64) (*api.MoveBytecode, error)) *AptosRpcClient_AccountModule_Call {
	_c.Call.Return(run)
	return _c
}

// AccountResource provides a mock function with given fields: address, resourceType, ledgerVersion
func (_m *AptosRpcClient) AccountResource(address aptos.AccountAddress, resourceType string, ledgerVersion ...uint64) (map[string]interface{}, error) {
	_va := make([]interface{}, len(ledgerVersion))
	for _i := range ledgerVersion {
		_va[_i] = ledgerVersion[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, address, resourceType)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountResource")
	}

	var r0 map[string]interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, ...uint64) (map[string]interface{}, error)); ok {
		return rf(address, resourceType, ledgerVersion...)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, ...uint64) map[string]interface{}); ok {
		r0 = rf(address, resourceType, ledgerVersion...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, string, ...uint64) error); ok {
		r1 = rf(address, resourceType, ledgerVersion...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_AccountResource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountResource'
type AptosRpcClient_AccountResource_Call struct {
	*mock.Call
}

// AccountResource is a helper method to define mock.On call
//   - address aptos.AccountAddress
//   - resourceType string
//   - ledgerVersion ...uint64
func (_e *AptosRpcClient_Expecter) AccountResource(address interface{}, resourceType interface{}, ledgerVersion ...interface{}) *AptosRpcClient_AccountResource_Call {
	return &AptosRpcClient_AccountResource_Call{Call: _e.mock.On("AccountResource",
		append([]interface{}{address, resourceType}, ledgerVersion...)...)}
}

func (_c *AptosRpcClient_AccountResource_Call) Run(run func(address aptos.AccountAddress, resourceType string, ledgerVersion ...uint64)) *AptosRpcClient_AccountResource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]uint64, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(uint64)
			}
		}
		run(args[0].(aptos.AccountAddress), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_AccountResource_Call) Return(_a0 map[string]interface{}, _a1 error) *AptosRpcClient_AccountResource_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_AccountResource_Call) RunAndReturn(run func(aptos.AccountAddress, string, ...uint64) (map[string]interface{}, error)) *AptosRpcClient_AccountResource_Call {
	_c.Call.Return(run)
	return _c
}

// AccountResources provides a mock function with given fields: address, ledgerVersion
func (_m *AptosRpcClient) AccountResources(address aptos.AccountAddress, ledgerVersion ...uint64) ([]aptos.AccountResourceInfo, error) {
	_va := make([]interface{}, len(ledgerVersion))
	for _i := range ledgerVersion {
		_va[_i] = ledgerVersion[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, address)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountResources")
	}

	var r0 []aptos.AccountResourceInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, ...uint64) ([]aptos.AccountResourceInfo, error)); ok {
		return rf(address, ledgerVersion...)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, ...uint64) []aptos.AccountResourceInfo); ok {
		r0 = rf(address, ledgerVersion...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]aptos.AccountResourceInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, ...uint64) error); ok {
		r1 = rf(address, ledgerVersion...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_AccountResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountResources'
type AptosRpcClient_AccountResources_Call struct {
	*mock.Call
}

// AccountResources is a helper method to define mock.On call
//   - address aptos.AccountAddress
//   - ledgerVersion ...uint64
func (_e *AptosRpcClient_Expecter) AccountResources(address interface{}, ledgerVersion ...interface{}) *AptosRpcClient_AccountResources_Call {
	return &AptosRpcClient_AccountResources_Call{Call: _e.mock.On("AccountResources",
		append([]interface{}{address}, ledgerVersion...)...)}
}

func (_c *AptosRpcClient_AccountResources_Call) Run(run func(address aptos.AccountAddress, ledgerVersion ...uint64)) *AptosRpcClient_AccountResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]uint64, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(uint64)
			}
		}
		run(args[0].(aptos.AccountAddress), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_AccountResources_Call) Return(_a0 []aptos.AccountResourceInfo, _a1 error) *AptosRpcClient_AccountResources_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_AccountResources_Call) RunAndReturn(run func(aptos.AccountAddress, ...uint64) ([]aptos.AccountResourceInfo, error)) *AptosRpcClient_AccountResources_Call {
	_c.Call.Return(run)
	return _c
}

// AccountResourcesBCS provides a mock function with given fields: address, ledgerVersion
func (_m *AptosRpcClient) AccountResourcesBCS(address aptos.AccountAddress, ledgerVersion ...uint64) ([]aptos.AccountResourceRecord, error) {
	_va := make([]interface{}, len(ledgerVersion))
	for _i := range ledgerVersion {
		_va[_i] = ledgerVersion[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, address)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AccountResourcesBCS")
	}

	var r0 []aptos.AccountResourceRecord
	var r1 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, ...uint64) ([]aptos.AccountResourceRecord, error)); ok {
		return rf(address, ledgerVersion...)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, ...uint64) []aptos.AccountResourceRecord); ok {
		r0 = rf(address, ledgerVersion...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]aptos.AccountResourceRecord)
		}
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, ...uint64) error); ok {
		r1 = rf(address, ledgerVersion...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_AccountResourcesBCS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountResourcesBCS'
type AptosRpcClient_AccountResourcesBCS_Call struct {
	*mock.Call
}

// AccountResourcesBCS is a helper method to define mock.On call
//   - address aptos.AccountAddress
//   - ledgerVersion ...uint64
func (_e *AptosRpcClient_Expecter) AccountResourcesBCS(address interface{}, ledgerVersion ...interface{}) *AptosRpcClient_AccountResourcesBCS_Call {
	return &AptosRpcClient_AccountResourcesBCS_Call{Call: _e.mock.On("AccountResourcesBCS",
		append([]interface{}{address}, ledgerVersion...)...)}
}

func (_c *AptosRpcClient_AccountResourcesBCS_Call) Run(run func(address aptos.AccountAddress, ledgerVersion ...uint64)) *AptosRpcClient_AccountResourcesBCS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]uint64, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(uint64)
			}
		}
		run(args[0].(aptos.AccountAddress), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_AccountResourcesBCS_Call) Return(_a0 []aptos.AccountResourceRecord, _a1 error) *AptosRpcClient_AccountResourcesBCS_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_AccountResourcesBCS_Call) RunAndReturn(run func(aptos.AccountAddress, ...uint64) ([]aptos.AccountResourceRecord, error)) *AptosRpcClient_AccountResourcesBCS_Call {
	_c.Call.Return(run)
	return _c
}

// AccountTransactions provides a mock function with given fields: address, start, limit
func (_m *AptosRpcClient) AccountTransactions(address aptos.AccountAddress, start *uint64, limit *uint64) ([]*api.CommittedTransaction, error) {
	ret := _m.Called(address, start, limit)

	if len(ret) == 0 {
		panic("no return value specified for AccountTransactions")
	}

	var r0 []*api.CommittedTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, *uint64, *uint64) ([]*api.CommittedTransaction, error)); ok {
		return rf(address, start, limit)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, *uint64, *uint64) []*api.CommittedTransaction); ok {
		r0 = rf(address, start, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.CommittedTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, *uint64, *uint64) error); ok {
		r1 = rf(address, start, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_AccountTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountTransactions'
type AptosRpcClient_AccountTransactions_Call struct {
	*mock.Call
}

// AccountTransactions is a helper method to define mock.On call
//   - address aptos.AccountAddress
//   - start *uint64
//   - limit *uint64
func (_e *AptosRpcClient_Expecter) AccountTransactions(address interface{}, start interface{}, limit interface{}) *AptosRpcClient_AccountTransactions_Call {
	return &AptosRpcClient_AccountTransactions_Call{Call: _e.mock.On("AccountTransactions", address, start, limit)}
}

func (_c *AptosRpcClient_AccountTransactions_Call) Run(run func(address aptos.AccountAddress, start *uint64, limit *uint64)) *AptosRpcClient_AccountTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(aptos.AccountAddress), args[1].(*uint64), args[2].(*uint64))
	})
	return _c
}

func (_c *AptosRpcClient_AccountTransactions_Call) Return(_a0 []*api.CommittedTransaction, _a1 error) *AptosRpcClient_AccountTransactions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_AccountTransactions_Call) RunAndReturn(run func(aptos.AccountAddress, *uint64, *uint64) ([]*api.CommittedTransaction, error)) *AptosRpcClient_AccountTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// BatchSubmitTransaction provides a mock function with given fields: signedTxns
func (_m *AptosRpcClient) BatchSubmitTransaction(signedTxns []*aptos.SignedTransaction) (*api.BatchSubmitTransactionResponse, error) {
	ret := _m.Called(signedTxns)

	if len(ret) == 0 {
		panic("no return value specified for BatchSubmitTransaction")
	}

	var r0 *api.BatchSubmitTransactionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func([]*aptos.SignedTransaction) (*api.BatchSubmitTransactionResponse, error)); ok {
		return rf(signedTxns)
	}
	if rf, ok := ret.Get(0).(func([]*aptos.SignedTransaction) *api.BatchSubmitTransactionResponse); ok {
		r0 = rf(signedTxns)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.BatchSubmitTransactionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func([]*aptos.SignedTransaction) error); ok {
		r1 = rf(signedTxns)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_BatchSubmitTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchSubmitTransaction'
type AptosRpcClient_BatchSubmitTransaction_Call struct {
	*mock.Call
}

// BatchSubmitTransaction is a helper method to define mock.On call
//   - signedTxns []*aptos.SignedTransaction
func (_e *AptosRpcClient_Expecter) BatchSubmitTransaction(signedTxns interface{}) *AptosRpcClient_BatchSubmitTransaction_Call {
	return &AptosRpcClient_BatchSubmitTransaction_Call{Call: _e.mock.On("BatchSubmitTransaction", signedTxns)}
}

func (_c *AptosRpcClient_BatchSubmitTransaction_Call) Run(run func(signedTxns []*aptos.SignedTransaction)) *AptosRpcClient_BatchSubmitTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]*aptos.SignedTransaction))
	})
	return _c
}

func (_c *AptosRpcClient_BatchSubmitTransaction_Call) Return(_a0 *api.BatchSubmitTransactionResponse, _a1 error) *AptosRpcClient_BatchSubmitTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_BatchSubmitTransaction_Call) RunAndReturn(run func([]*aptos.SignedTransaction) (*api.BatchSubmitTransactionResponse, error)) *AptosRpcClient_BatchSubmitTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// BlockByHeight provides a mock function with given fields: blockHeight, withTransactions
func (_m *AptosRpcClient) BlockByHeight(blockHeight uint64, withTransactions bool) (*api.Block, error) {
	ret := _m.Called(blockHeight, withTransactions)

	if len(ret) == 0 {
		panic("no return value specified for BlockByHeight")
	}

	var r0 *api.Block
	var r1 error
	if rf, ok := ret.Get(0).(func(uint64, bool) (*api.Block, error)); ok {
		return rf(blockHeight, withTransactions)
	}
	if rf, ok := ret.Get(0).(func(uint64, bool) *api.Block); ok {
		r0 = rf(blockHeight, withTransactions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Block)
		}
	}

	if rf, ok := ret.Get(1).(func(uint64, bool) error); ok {
		r1 = rf(blockHeight, withTransactions)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_BlockByHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockByHeight'
type AptosRpcClient_BlockByHeight_Call struct {
	*mock.Call
}

// BlockByHeight is a helper method to define mock.On call
//   - blockHeight uint64
//   - withTransactions bool
func (_e *AptosRpcClient_Expecter) BlockByHeight(blockHeight interface{}, withTransactions interface{}) *AptosRpcClient_BlockByHeight_Call {
	return &AptosRpcClient_BlockByHeight_Call{Call: _e.mock.On("BlockByHeight", blockHeight, withTransactions)}
}

func (_c *AptosRpcClient_BlockByHeight_Call) Run(run func(blockHeight uint64, withTransactions bool)) *AptosRpcClient_BlockByHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(bool))
	})
	return _c
}

func (_c *AptosRpcClient_BlockByHeight_Call) Return(_a0 *api.Block, _a1 error) *AptosRpcClient_BlockByHeight_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_BlockByHeight_Call) RunAndReturn(run func(uint64, bool) (*api.Block, error)) *AptosRpcClient_BlockByHeight_Call {
	_c.Call.Return(run)
	return _c
}

// BlockByVersion provides a mock function with given fields: ledgerVersion, withTransactions
func (_m *AptosRpcClient) BlockByVersion(ledgerVersion uint64, withTransactions bool) (*api.Block, error) {
	ret := _m.Called(ledgerVersion, withTransactions)

	if len(ret) == 0 {
		panic("no return value specified for BlockByVersion")
	}

	var r0 *api.Block
	var r1 error
	if rf, ok := ret.Get(0).(func(uint64, bool) (*api.Block, error)); ok {
		return rf(ledgerVersion, withTransactions)
	}
	if rf, ok := ret.Get(0).(func(uint64, bool) *api.Block); ok {
		r0 = rf(ledgerVersion, withTransactions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Block)
		}
	}

	if rf, ok := ret.Get(1).(func(uint64, bool) error); ok {
		r1 = rf(ledgerVersion, withTransactions)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_BlockByVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockByVersion'
type AptosRpcClient_BlockByVersion_Call struct {
	*mock.Call
}

// BlockByVersion is a helper method to define mock.On call
//   - ledgerVersion uint64
//   - withTransactions bool
func (_e *AptosRpcClient_Expecter) BlockByVersion(ledgerVersion interface{}, withTransactions interface{}) *AptosRpcClient_BlockByVersion_Call {
	return &AptosRpcClient_BlockByVersion_Call{Call: _e.mock.On("BlockByVersion", ledgerVersion, withTransactions)}
}

func (_c *AptosRpcClient_BlockByVersion_Call) Run(run func(ledgerVersion uint64, withTransactions bool)) *AptosRpcClient_BlockByVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(bool))
	})
	return _c
}

func (_c *AptosRpcClient_BlockByVersion_Call) Return(_a0 *api.Block, _a1 error) *AptosRpcClient_BlockByVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_BlockByVersion_Call) RunAndReturn(run func(uint64, bool) (*api.Block, error)) *AptosRpcClient_BlockByVersion_Call {
	_c.Call.Return(run)
	return _c
}

// BuildSignAndSubmitTransaction provides a mock function with given fields: sender, payload, options
func (_m *AptosRpcClient) BuildSignAndSubmitTransaction(sender aptos.TransactionSigner, payload aptos.TransactionPayload, options ...interface{}) (*api.PendingTransaction, error) {
	var _ca []interface{}
	_ca = append(_ca, sender, payload)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BuildSignAndSubmitTransaction")
	}

	var r0 *api.PendingTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(aptos.TransactionSigner, aptos.TransactionPayload, ...interface{}) (*api.PendingTransaction, error)); ok {
		return rf(sender, payload, options...)
	}
	if rf, ok := ret.Get(0).(func(aptos.TransactionSigner, aptos.TransactionPayload, ...interface{}) *api.PendingTransaction); ok {
		r0 = rf(sender, payload, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.PendingTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(aptos.TransactionSigner, aptos.TransactionPayload, ...interface{}) error); ok {
		r1 = rf(sender, payload, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_BuildSignAndSubmitTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BuildSignAndSubmitTransaction'
type AptosRpcClient_BuildSignAndSubmitTransaction_Call struct {
	*mock.Call
}

// BuildSignAndSubmitTransaction is a helper method to define mock.On call
//   - sender aptos.TransactionSigner
//   - payload aptos.TransactionPayload
//   - options ...interface{}
func (_e *AptosRpcClient_Expecter) BuildSignAndSubmitTransaction(sender interface{}, payload interface{}, options ...interface{}) *AptosRpcClient_BuildSignAndSubmitTransaction_Call {
	return &AptosRpcClient_BuildSignAndSubmitTransaction_Call{Call: _e.mock.On("BuildSignAndSubmitTransaction",
		append([]interface{}{sender, payload}, options...)...)}
}

func (_c *AptosRpcClient_BuildSignAndSubmitTransaction_Call) Run(run func(sender aptos.TransactionSigner, payload aptos.TransactionPayload, options ...interface{})) *AptosRpcClient_BuildSignAndSubmitTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(aptos.TransactionSigner), args[1].(aptos.TransactionPayload), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_BuildSignAndSubmitTransaction_Call) Return(_a0 *api.PendingTransaction, _a1 error) *AptosRpcClient_BuildSignAndSubmitTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_BuildSignAndSubmitTransaction_Call) RunAndReturn(run func(aptos.TransactionSigner, aptos.TransactionPayload, ...interface{}) (*api.PendingTransaction, error)) *AptosRpcClient_BuildSignAndSubmitTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// BuildTransaction provides a mock function with given fields: sender, payload, options
func (_m *AptosRpcClient) BuildTransaction(sender aptos.AccountAddress, payload aptos.TransactionPayload, options ...interface{}) (*aptos.RawTransaction, error) {
	var _ca []interface{}
	_ca = append(_ca, sender, payload)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BuildTransaction")
	}

	var r0 *aptos.RawTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, aptos.TransactionPayload, ...interface{}) (*aptos.RawTransaction, error)); ok {
		return rf(sender, payload, options...)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, aptos.TransactionPayload, ...interface{}) *aptos.RawTransaction); ok {
		r0 = rf(sender, payload, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*aptos.RawTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, aptos.TransactionPayload, ...interface{}) error); ok {
		r1 = rf(sender, payload, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_BuildTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BuildTransaction'
type AptosRpcClient_BuildTransaction_Call struct {
	*mock.Call
}

// BuildTransaction is a helper method to define mock.On call
//   - sender aptos.AccountAddress
//   - payload aptos.TransactionPayload
//   - options ...interface{}
func (_e *AptosRpcClient_Expecter) BuildTransaction(sender interface{}, payload interface{}, options ...interface{}) *AptosRpcClient_BuildTransaction_Call {
	return &AptosRpcClient_BuildTransaction_Call{Call: _e.mock.On("BuildTransaction",
		append([]interface{}{sender, payload}, options...)...)}
}

func (_c *AptosRpcClient_BuildTransaction_Call) Run(run func(sender aptos.AccountAddress, payload aptos.TransactionPayload, options ...interface{})) *AptosRpcClient_BuildTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(aptos.AccountAddress), args[1].(aptos.TransactionPayload), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_BuildTransaction_Call) Return(_a0 *aptos.RawTransaction, _a1 error) *AptosRpcClient_BuildTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_BuildTransaction_Call) RunAndReturn(run func(aptos.AccountAddress, aptos.TransactionPayload, ...interface{}) (*aptos.RawTransaction, error)) *AptosRpcClient_BuildTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// BuildTransactionMultiAgent provides a mock function with given fields: sender, payload, options
func (_m *AptosRpcClient) BuildTransactionMultiAgent(sender aptos.AccountAddress, payload aptos.TransactionPayload, options ...interface{}) (*aptos.RawTransactionWithData, error) {
	var _ca []interface{}
	_ca = append(_ca, sender, payload)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BuildTransactionMultiAgent")
	}

	var r0 *aptos.RawTransactionWithData
	var r1 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, aptos.TransactionPayload, ...interface{}) (*aptos.RawTransactionWithData, error)); ok {
		return rf(sender, payload, options...)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, aptos.TransactionPayload, ...interface{}) *aptos.RawTransactionWithData); ok {
		r0 = rf(sender, payload, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*aptos.RawTransactionWithData)
		}
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, aptos.TransactionPayload, ...interface{}) error); ok {
		r1 = rf(sender, payload, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_BuildTransactionMultiAgent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BuildTransactionMultiAgent'
type AptosRpcClient_BuildTransactionMultiAgent_Call struct {
	*mock.Call
}

// BuildTransactionMultiAgent is a helper method to define mock.On call
//   - sender aptos.AccountAddress
//   - payload aptos.TransactionPayload
//   - options ...interface{}
func (_e *AptosRpcClient_Expecter) BuildTransactionMultiAgent(sender interface{}, payload interface{}, options ...interface{}) *AptosRpcClient_BuildTransactionMultiAgent_Call {
	return &AptosRpcClient_BuildTransactionMultiAgent_Call{Call: _e.mock.On("BuildTransactionMultiAgent",
		append([]interface{}{sender, payload}, options...)...)}
}

func (_c *AptosRpcClient_BuildTransactionMultiAgent_Call) Run(run func(sender aptos.AccountAddress, payload aptos.TransactionPayload, options ...interface{})) *AptosRpcClient_BuildTransactionMultiAgent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(aptos.AccountAddress), args[1].(aptos.TransactionPayload), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_BuildTransactionMultiAgent_Call) Return(_a0 *aptos.RawTransactionWithData, _a1 error) *AptosRpcClient_BuildTransactionMultiAgent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_BuildTransactionMultiAgent_Call) RunAndReturn(run func(aptos.AccountAddress, aptos.TransactionPayload, ...interface{}) (*aptos.RawTransactionWithData, error)) *AptosRpcClient_BuildTransactionMultiAgent_Call {
	_c.Call.Return(run)
	return _c
}

// EntryFunctionWithArgs provides a mock function with given fields: moduleAddress, moduleName, functionName, typeArgs, args
func (_m *AptosRpcClient) EntryFunctionWithArgs(moduleAddress aptos.AccountAddress, moduleName string, functionName string, typeArgs []interface{}, args []interface{}) (*aptos.EntryFunction, error) {
	ret := _m.Called(moduleAddress, moduleName, functionName, typeArgs, args)

	if len(ret) == 0 {
		panic("no return value specified for EntryFunctionWithArgs")
	}

	var r0 *aptos.EntryFunction
	var r1 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, string, []interface{}, []interface{}) (*aptos.EntryFunction, error)); ok {
		return rf(moduleAddress, moduleName, functionName, typeArgs, args)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, string, []interface{}, []interface{}) *aptos.EntryFunction); ok {
		r0 = rf(moduleAddress, moduleName, functionName, typeArgs, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*aptos.EntryFunction)
		}
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, string, string, []interface{}, []interface{}) error); ok {
		r1 = rf(moduleAddress, moduleName, functionName, typeArgs, args)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_EntryFunctionWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EntryFunctionWithArgs'
type AptosRpcClient_EntryFunctionWithArgs_Call struct {
	*mock.Call
}

// EntryFunctionWithArgs is a helper method to define mock.On call
//   - moduleAddress aptos.AccountAddress
//   - moduleName string
//   - functionName string
//   - typeArgs []interface{}
//   - args []interface{}
func (_e *AptosRpcClient_Expecter) EntryFunctionWithArgs(moduleAddress interface{}, moduleName interface{}, functionName interface{}, typeArgs interface{}, args interface{}) *AptosRpcClient_EntryFunctionWithArgs_Call {
	return &AptosRpcClient_EntryFunctionWithArgs_Call{Call: _e.mock.On("EntryFunctionWithArgs", moduleAddress, moduleName, functionName, typeArgs, args)}
}

func (_c *AptosRpcClient_EntryFunctionWithArgs_Call) Run(run func(moduleAddress aptos.AccountAddress, moduleName string, functionName string, typeArgs []interface{}, args []interface{})) *AptosRpcClient_EntryFunctionWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(aptos.AccountAddress), args[1].(string), args[2].(string), args[3].([]interface{}), args[4].([]interface{}))
	})
	return _c
}

func (_c *AptosRpcClient_EntryFunctionWithArgs_Call) Return(_a0 *aptos.EntryFunction, _a1 error) *AptosRpcClient_EntryFunctionWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_EntryFunctionWithArgs_Call) RunAndReturn(run func(aptos.AccountAddress, string, string, []interface{}, []interface{}) (*aptos.EntryFunction, error)) *AptosRpcClient_EntryFunctionWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// EstimateGasPrice provides a mock function with no fields
func (_m *AptosRpcClient) EstimateGasPrice() (aptos.EstimateGasInfo, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for EstimateGasPrice")
	}

	var r0 aptos.EstimateGasInfo
	var r1 error
	if rf, ok := ret.Get(0).(func() (aptos.EstimateGasInfo, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() aptos.EstimateGasInfo); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(aptos.EstimateGasInfo)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_EstimateGasPrice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EstimateGasPrice'
type AptosRpcClient_EstimateGasPrice_Call struct {
	*mock.Call
}

// EstimateGasPrice is a helper method to define mock.On call
func (_e *AptosRpcClient_Expecter) EstimateGasPrice() *AptosRpcClient_EstimateGasPrice_Call {
	return &AptosRpcClient_EstimateGasPrice_Call{Call: _e.mock.On("EstimateGasPrice")}
}

func (_c *AptosRpcClient_EstimateGasPrice_Call) Run(run func()) *AptosRpcClient_EstimateGasPrice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *AptosRpcClient_EstimateGasPrice_Call) Return(_a0 aptos.EstimateGasInfo, _a1 error) *AptosRpcClient_EstimateGasPrice_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_EstimateGasPrice_Call) RunAndReturn(run func() (aptos.EstimateGasInfo, error)) *AptosRpcClient_EstimateGasPrice_Call {
	_c.Call.Return(run)
	return _c
}

// EventsByCreationNumber provides a mock function with given fields: account, creationNumber, start, limit
func (_m *AptosRpcClient) EventsByCreationNumber(account aptos.AccountAddress, creationNumber string, start *uint64, limit *uint64) ([]*api.Event, error) {
	ret := _m.Called(account, creationNumber, start, limit)

	if len(ret) == 0 {
		panic("no return value specified for EventsByCreationNumber")
	}

	var r0 []*api.Event
	var r1 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, *uint64, *uint64) ([]*api.Event, error)); ok {
		return rf(account, creationNumber, start, limit)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, *uint64, *uint64) []*api.Event); ok {
		r0 = rf(account, creationNumber, start, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, string, *uint64, *uint64) error); ok {
		r1 = rf(account, creationNumber, start, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_EventsByCreationNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EventsByCreationNumber'
type AptosRpcClient_EventsByCreationNumber_Call struct {
	*mock.Call
}

// EventsByCreationNumber is a helper method to define mock.On call
//   - account aptos.AccountAddress
//   - creationNumber string
//   - start *uint64
//   - limit *uint64
func (_e *AptosRpcClient_Expecter) EventsByCreationNumber(account interface{}, creationNumber interface{}, start interface{}, limit interface{}) *AptosRpcClient_EventsByCreationNumber_Call {
	return &AptosRpcClient_EventsByCreationNumber_Call{Call: _e.mock.On("EventsByCreationNumber", account, creationNumber, start, limit)}
}

func (_c *AptosRpcClient_EventsByCreationNumber_Call) Run(run func(account aptos.AccountAddress, creationNumber string, start *uint64, limit *uint64)) *AptosRpcClient_EventsByCreationNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(aptos.AccountAddress), args[1].(string), args[2].(*uint64), args[3].(*uint64))
	})
	return _c
}

func (_c *AptosRpcClient_EventsByCreationNumber_Call) Return(_a0 []*api.Event, _a1 error) *AptosRpcClient_EventsByCreationNumber_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_EventsByCreationNumber_Call) RunAndReturn(run func(aptos.AccountAddress, string, *uint64, *uint64) ([]*api.Event, error)) *AptosRpcClient_EventsByCreationNumber_Call {
	_c.Call.Return(run)
	return _c
}

// EventsByHandle provides a mock function with given fields: account, eventHandle, fieldName, start, limit
func (_m *AptosRpcClient) EventsByHandle(account aptos.AccountAddress, eventHandle string, fieldName string, start *uint64, limit *uint64) ([]*api.Event, error) {
	ret := _m.Called(account, eventHandle, fieldName, start, limit)

	if len(ret) == 0 {
		panic("no return value specified for EventsByHandle")
	}

	var r0 []*api.Event
	var r1 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, string, *uint64, *uint64) ([]*api.Event, error)); ok {
		return rf(account, eventHandle, fieldName, start, limit)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, string, *uint64, *uint64) []*api.Event); ok {
		r0 = rf(account, eventHandle, fieldName, start, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, string, string, *uint64, *uint64) error); ok {
		r1 = rf(account, eventHandle, fieldName, start, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_EventsByHandle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EventsByHandle'
type AptosRpcClient_EventsByHandle_Call struct {
	*mock.Call
}

// EventsByHandle is a helper method to define mock.On call
//   - account aptos.AccountAddress
//   - eventHandle string
//   - fieldName string
//   - start *uint64
//   - limit *uint64
func (_e *AptosRpcClient_Expecter) EventsByHandle(account interface{}, eventHandle interface{}, fieldName interface{}, start interface{}, limit interface{}) *AptosRpcClient_EventsByHandle_Call {
	return &AptosRpcClient_EventsByHandle_Call{Call: _e.mock.On("EventsByHandle", account, eventHandle, fieldName, start, limit)}
}

func (_c *AptosRpcClient_EventsByHandle_Call) Run(run func(account aptos.AccountAddress, eventHandle string, fieldName string, start *uint64, limit *uint64)) *AptosRpcClient_EventsByHandle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(aptos.AccountAddress), args[1].(string), args[2].(string), args[3].(*uint64), args[4].(*uint64))
	})
	return _c
}

func (_c *AptosRpcClient_EventsByHandle_Call) Return(_a0 []*api.Event, _a1 error) *AptosRpcClient_EventsByHandle_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_EventsByHandle_Call) RunAndReturn(run func(aptos.AccountAddress, string, string, *uint64, *uint64) ([]*api.Event, error)) *AptosRpcClient_EventsByHandle_Call {
	_c.Call.Return(run)
	return _c
}

// GetChainId provides a mock function with no fields
func (_m *AptosRpcClient) GetChainId() (uint8, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetChainId")
	}

	var r0 uint8
	var r1 error
	if rf, ok := ret.Get(0).(func() (uint8, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() uint8); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint8)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_GetChainId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetChainId'
type AptosRpcClient_GetChainId_Call struct {
	*mock.Call
}

// GetChainId is a helper method to define mock.On call
func (_e *AptosRpcClient_Expecter) GetChainId() *AptosRpcClient_GetChainId_Call {
	return &AptosRpcClient_GetChainId_Call{Call: _e.mock.On("GetChainId")}
}

func (_c *AptosRpcClient_GetChainId_Call) Run(run func()) *AptosRpcClient_GetChainId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *AptosRpcClient_GetChainId_Call) Return(_a0 uint8, _a1 error) *AptosRpcClient_GetChainId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_GetChainId_Call) RunAndReturn(run func() (uint8, error)) *AptosRpcClient_GetChainId_Call {
	_c.Call.Return(run)
	return _c
}

// Info provides a mock function with no fields
func (_m *AptosRpcClient) Info() (aptos.NodeInfo, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 aptos.NodeInfo
	var r1 error
	if rf, ok := ret.Get(0).(func() (aptos.NodeInfo, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() aptos.NodeInfo); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(aptos.NodeInfo)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_Info_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Info'
type AptosRpcClient_Info_Call struct {
	*mock.Call
}

// Info is a helper method to define mock.On call
func (_e *AptosRpcClient_Expecter) Info() *AptosRpcClient_Info_Call {
	return &AptosRpcClient_Info_Call{Call: _e.mock.On("Info")}
}

func (_c *AptosRpcClient_Info_Call) Run(run func()) *AptosRpcClient_Info_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *AptosRpcClient_Info_Call) Return(_a0 aptos.NodeInfo, _a1 error) *AptosRpcClient_Info_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_Info_Call) RunAndReturn(run func() (aptos.NodeInfo, error)) *AptosRpcClient_Info_Call {
	_c.Call.Return(run)
	return _c
}

// NodeAPIHealthCheck provides a mock function with given fields: durationSecs
func (_m *AptosRpcClient) NodeAPIHealthCheck(durationSecs ...uint64) (api.HealthCheckResponse, error) {
	_va := make([]interface{}, len(durationSecs))
	for _i := range durationSecs {
		_va[_i] = durationSecs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NodeAPIHealthCheck")
	}

	var r0 api.HealthCheckResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(...uint64) (api.HealthCheckResponse, error)); ok {
		return rf(durationSecs...)
	}
	if rf, ok := ret.Get(0).(func(...uint64) api.HealthCheckResponse); ok {
		r0 = rf(durationSecs...)
	} else {
		r0 = ret.Get(0).(api.HealthCheckResponse)
	}

	if rf, ok := ret.Get(1).(func(...uint64) error); ok {
		r1 = rf(durationSecs...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_NodeAPIHealthCheck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NodeAPIHealthCheck'
type AptosRpcClient_NodeAPIHealthCheck_Call struct {
	*mock.Call
}

// NodeAPIHealthCheck is a helper method to define mock.On call
//   - durationSecs ...uint64
func (_e *AptosRpcClient_Expecter) NodeAPIHealthCheck(durationSecs ...interface{}) *AptosRpcClient_NodeAPIHealthCheck_Call {
	return &AptosRpcClient_NodeAPIHealthCheck_Call{Call: _e.mock.On("NodeAPIHealthCheck",
		append([]interface{}{}, durationSecs...)...)}
}

func (_c *AptosRpcClient_NodeAPIHealthCheck_Call) Run(run func(durationSecs ...uint64)) *AptosRpcClient_NodeAPIHealthCheck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]uint64, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(uint64)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_NodeAPIHealthCheck_Call) Return(_a0 api.HealthCheckResponse, _a1 error) *AptosRpcClient_NodeAPIHealthCheck_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_NodeAPIHealthCheck_Call) RunAndReturn(run func(...uint64) (api.HealthCheckResponse, error)) *AptosRpcClient_NodeAPIHealthCheck_Call {
	_c.Call.Return(run)
	return _c
}

// PollForTransaction provides a mock function with given fields: hash, options
func (_m *AptosRpcClient) PollForTransaction(hash string, options ...interface{}) (*api.UserTransaction, error) {
	var _ca []interface{}
	_ca = append(_ca, hash)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PollForTransaction")
	}

	var r0 *api.UserTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (*api.UserTransaction, error)); ok {
		return rf(hash, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *api.UserTransaction); ok {
		r0 = rf(hash, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UserTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(hash, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_PollForTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PollForTransaction'
type AptosRpcClient_PollForTransaction_Call struct {
	*mock.Call
}

// PollForTransaction is a helper method to define mock.On call
//   - hash string
//   - options ...interface{}
func (_e *AptosRpcClient_Expecter) PollForTransaction(hash interface{}, options ...interface{}) *AptosRpcClient_PollForTransaction_Call {
	return &AptosRpcClient_PollForTransaction_Call{Call: _e.mock.On("PollForTransaction",
		append([]interface{}{hash}, options...)...)}
}

func (_c *AptosRpcClient_PollForTransaction_Call) Run(run func(hash string, options ...interface{})) *AptosRpcClient_PollForTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_PollForTransaction_Call) Return(_a0 *api.UserTransaction, _a1 error) *AptosRpcClient_PollForTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_PollForTransaction_Call) RunAndReturn(run func(string, ...interface{}) (*api.UserTransaction, error)) *AptosRpcClient_PollForTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// PollForTransactions provides a mock function with given fields: txnHashes, options
func (_m *AptosRpcClient) PollForTransactions(txnHashes []string, options ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, txnHashes)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PollForTransactions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]string, ...interface{}) error); ok {
		r0 = rf(txnHashes, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AptosRpcClient_PollForTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PollForTransactions'
type AptosRpcClient_PollForTransactions_Call struct {
	*mock.Call
}

// PollForTransactions is a helper method to define mock.On call
//   - txnHashes []string
//   - options ...interface{}
func (_e *AptosRpcClient_Expecter) PollForTransactions(txnHashes interface{}, options ...interface{}) *AptosRpcClient_PollForTransactions_Call {
	return &AptosRpcClient_PollForTransactions_Call{Call: _e.mock.On("PollForTransactions",
		append([]interface{}{txnHashes}, options...)...)}
}

func (_c *AptosRpcClient_PollForTransactions_Call) Run(run func(txnHashes []string, options ...interface{})) *AptosRpcClient_PollForTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].([]string), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_PollForTransactions_Call) Return(_a0 error) *AptosRpcClient_PollForTransactions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AptosRpcClient_PollForTransactions_Call) RunAndReturn(run func([]string, ...interface{}) error) *AptosRpcClient_PollForTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveHeader provides a mock function with given fields: key
func (_m *AptosRpcClient) RemoveHeader(key string) {
	_m.Called(key)
}

// AptosRpcClient_RemoveHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveHeader'
type AptosRpcClient_RemoveHeader_Call struct {
	*mock.Call
}

// RemoveHeader is a helper method to define mock.On call
//   - key string
func (_e *AptosRpcClient_Expecter) RemoveHeader(key interface{}) *AptosRpcClient_RemoveHeader_Call {
	return &AptosRpcClient_RemoveHeader_Call{Call: _e.mock.On("RemoveHeader", key)}
}

func (_c *AptosRpcClient_RemoveHeader_Call) Run(run func(key string)) *AptosRpcClient_RemoveHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *AptosRpcClient_RemoveHeader_Call) Return() *AptosRpcClient_RemoveHeader_Call {
	_c.Call.Return()
	return _c
}

func (_c *AptosRpcClient_RemoveHeader_Call) RunAndReturn(run func(string)) *AptosRpcClient_RemoveHeader_Call {
	_c.Run(run)
	return _c
}

// SetHeader provides a mock function with given fields: key, value
func (_m *AptosRpcClient) SetHeader(key string, value string) {
	_m.Called(key, value)
}

// AptosRpcClient_SetHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetHeader'
type AptosRpcClient_SetHeader_Call struct {
	*mock.Call
}

// SetHeader is a helper method to define mock.On call
//   - key string
//   - value string
func (_e *AptosRpcClient_Expecter) SetHeader(key interface{}, value interface{}) *AptosRpcClient_SetHeader_Call {
	return &AptosRpcClient_SetHeader_Call{Call: _e.mock.On("SetHeader", key, value)}
}

func (_c *AptosRpcClient_SetHeader_Call) Run(run func(key string, value string)) *AptosRpcClient_SetHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *AptosRpcClient_SetHeader_Call) Return() *AptosRpcClient_SetHeader_Call {
	_c.Call.Return()
	return _c
}

func (_c *AptosRpcClient_SetHeader_Call) RunAndReturn(run func(string, string)) *AptosRpcClient_SetHeader_Call {
	_c.Run(run)
	return _c
}

// SetTimeout provides a mock function with given fields: timeout
func (_m *AptosRpcClient) SetTimeout(timeout time.Duration) {
	_m.Called(timeout)
}

// AptosRpcClient_SetTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTimeout'
type AptosRpcClient_SetTimeout_Call struct {
	*mock.Call
}

// SetTimeout is a helper method to define mock.On call
//   - timeout time.Duration
func (_e *AptosRpcClient_Expecter) SetTimeout(timeout interface{}) *AptosRpcClient_SetTimeout_Call {
	return &AptosRpcClient_SetTimeout_Call{Call: _e.mock.On("SetTimeout", timeout)}
}

func (_c *AptosRpcClient_SetTimeout_Call) Run(run func(timeout time.Duration)) *AptosRpcClient_SetTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Duration))
	})
	return _c
}

func (_c *AptosRpcClient_SetTimeout_Call) Return() *AptosRpcClient_SetTimeout_Call {
	_c.Call.Return()
	return _c
}

func (_c *AptosRpcClient_SetTimeout_Call) RunAndReturn(run func(time.Duration)) *AptosRpcClient_SetTimeout_Call {
	_c.Run(run)
	return _c
}

// SimulateTransaction provides a mock function with given fields: rawTxn, sender, options
func (_m *AptosRpcClient) SimulateTransaction(rawTxn *aptos.RawTransaction, sender aptos.TransactionSigner, options ...interface{}) ([]*api.UserTransaction, error) {
	var _ca []interface{}
	_ca = append(_ca, rawTxn, sender)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SimulateTransaction")
	}

	var r0 []*api.UserTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*aptos.RawTransaction, aptos.TransactionSigner, ...interface{}) ([]*api.UserTransaction, error)); ok {
		return rf(rawTxn, sender, options...)
	}
	if rf, ok := ret.Get(0).(func(*aptos.RawTransaction, aptos.TransactionSigner, ...interface{}) []*api.UserTransaction); ok {
		r0 = rf(rawTxn, sender, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.UserTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*aptos.RawTransaction, aptos.TransactionSigner, ...interface{}) error); ok {
		r1 = rf(rawTxn, sender, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_SimulateTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SimulateTransaction'
type AptosRpcClient_SimulateTransaction_Call struct {
	*mock.Call
}

// SimulateTransaction is a helper method to define mock.On call
//   - rawTxn *aptos.RawTransaction
//   - sender aptos.TransactionSigner
//   - options ...interface{}
func (_e *AptosRpcClient_Expecter) SimulateTransaction(rawTxn interface{}, sender interface{}, options ...interface{}) *AptosRpcClient_SimulateTransaction_Call {
	return &AptosRpcClient_SimulateTransaction_Call{Call: _e.mock.On("SimulateTransaction",
		append([]interface{}{rawTxn, sender}, options...)...)}
}

func (_c *AptosRpcClient_SimulateTransaction_Call) Run(run func(rawTxn *aptos.RawTransaction, sender aptos.TransactionSigner, options ...interface{})) *AptosRpcClient_SimulateTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(*aptos.RawTransaction), args[1].(aptos.TransactionSigner), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_SimulateTransaction_Call) Return(_a0 []*api.UserTransaction, _a1 error) *AptosRpcClient_SimulateTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_SimulateTransaction_Call) RunAndReturn(run func(*aptos.RawTransaction, aptos.TransactionSigner, ...interface{}) ([]*api.UserTransaction, error)) *AptosRpcClient_SimulateTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// SimulateTransactionMultiAgent provides a mock function with given fields: rawTxn, sender, options
func (_m *AptosRpcClient) SimulateTransactionMultiAgent(rawTxn *aptos.RawTransactionWithData, sender aptos.TransactionSigner, options ...interface{}) ([]*api.UserTransaction, error) {
	var _ca []interface{}
	_ca = append(_ca, rawTxn, sender)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SimulateTransactionMultiAgent")
	}

	var r0 []*api.UserTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*aptos.RawTransactionWithData, aptos.TransactionSigner, ...interface{}) ([]*api.UserTransaction, error)); ok {
		return rf(rawTxn, sender, options...)
	}
	if rf, ok := ret.Get(0).(func(*aptos.RawTransactionWithData, aptos.TransactionSigner, ...interface{}) []*api.UserTransaction); ok {
		r0 = rf(rawTxn, sender, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.UserTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*aptos.RawTransactionWithData, aptos.TransactionSigner, ...interface{}) error); ok {
		r1 = rf(rawTxn, sender, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_SimulateTransactionMultiAgent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SimulateTransactionMultiAgent'
type AptosRpcClient_SimulateTransactionMultiAgent_Call struct {
	*mock.Call
}

// SimulateTransactionMultiAgent is a helper method to define mock.On call
//   - rawTxn *aptos.RawTransactionWithData
//   - sender aptos.TransactionSigner
//   - options ...interface{}
func (_e *AptosRpcClient_Expecter) SimulateTransactionMultiAgent(rawTxn interface{}, sender interface{}, options ...interface{}) *AptosRpcClient_SimulateTransactionMultiAgent_Call {
	return &AptosRpcClient_SimulateTransactionMultiAgent_Call{Call: _e.mock.On("SimulateTransactionMultiAgent",
		append([]interface{}{rawTxn, sender}, options...)...)}
}

func (_c *AptosRpcClient_SimulateTransactionMultiAgent_Call) Run(run func(rawTxn *aptos.RawTransactionWithData, sender aptos.TransactionSigner, options ...interface{})) *AptosRpcClient_SimulateTransactionMultiAgent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(*aptos.RawTransactionWithData), args[1].(aptos.TransactionSigner), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_SimulateTransactionMultiAgent_Call) Return(_a0 []*api.UserTransaction, _a1 error) *AptosRpcClient_SimulateTransactionMultiAgent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_SimulateTransactionMultiAgent_Call) RunAndReturn(run func(*aptos.RawTransactionWithData, aptos.TransactionSigner, ...interface{}) ([]*api.UserTransaction, error)) *AptosRpcClient_SimulateTransactionMultiAgent_Call {
	_c.Call.Return(run)
	return _c
}

// SubmitTransaction provides a mock function with given fields: signedTransaction
func (_m *AptosRpcClient) SubmitTransaction(signedTransaction *aptos.SignedTransaction) (*api.PendingTransaction, error) {
	ret := _m.Called(signedTransaction)

	if len(ret) == 0 {
		panic("no return value specified for SubmitTransaction")
	}

	var r0 *api.PendingTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*aptos.SignedTransaction) (*api.PendingTransaction, error)); ok {
		return rf(signedTransaction)
	}
	if rf, ok := ret.Get(0).(func(*aptos.SignedTransaction) *api.PendingTransaction); ok {
		r0 = rf(signedTransaction)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.PendingTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*aptos.SignedTransaction) error); ok {
		r1 = rf(signedTransaction)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_SubmitTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubmitTransaction'
type AptosRpcClient_SubmitTransaction_Call struct {
	*mock.Call
}

// SubmitTransaction is a helper method to define mock.On call
//   - signedTransaction *aptos.SignedTransaction
func (_e *AptosRpcClient_Expecter) SubmitTransaction(signedTransaction interface{}) *AptosRpcClient_SubmitTransaction_Call {
	return &AptosRpcClient_SubmitTransaction_Call{Call: _e.mock.On("SubmitTransaction", signedTransaction)}
}

func (_c *AptosRpcClient_SubmitTransaction_Call) Run(run func(signedTransaction *aptos.SignedTransaction)) *AptosRpcClient_SubmitTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*aptos.SignedTransaction))
	})
	return _c
}

func (_c *AptosRpcClient_SubmitTransaction_Call) Return(_a0 *api.PendingTransaction, _a1 error) *AptosRpcClient_SubmitTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_SubmitTransaction_Call) RunAndReturn(run func(*aptos.SignedTransaction) (*api.PendingTransaction, error)) *AptosRpcClient_SubmitTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// TransactionByHash provides a mock function with given fields: txnHash
func (_m *AptosRpcClient) TransactionByHash(txnHash string) (*api.Transaction, error) {
	ret := _m.Called(txnHash)

	if len(ret) == 0 {
		panic("no return value specified for TransactionByHash")
	}

	var r0 *api.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*api.Transaction, error)); ok {
		return rf(txnHash)
	}
	if rf, ok := ret.Get(0).(func(string) *api.Transaction); ok {
		r0 = rf(txnHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(txnHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_TransactionByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransactionByHash'
type AptosRpcClient_TransactionByHash_Call struct {
	*mock.Call
}

// TransactionByHash is a helper method to define mock.On call
//   - txnHash string
func (_e *AptosRpcClient_Expecter) TransactionByHash(txnHash interface{}) *AptosRpcClient_TransactionByHash_Call {
	return &AptosRpcClient_TransactionByHash_Call{Call: _e.mock.On("TransactionByHash", txnHash)}
}

func (_c *AptosRpcClient_TransactionByHash_Call) Run(run func(txnHash string)) *AptosRpcClient_TransactionByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *AptosRpcClient_TransactionByHash_Call) Return(_a0 *api.Transaction, _a1 error) *AptosRpcClient_TransactionByHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_TransactionByHash_Call) RunAndReturn(run func(string) (*api.Transaction, error)) *AptosRpcClient_TransactionByHash_Call {
	_c.Call.Return(run)
	return _c
}

// TransactionByVersion provides a mock function with given fields: version
func (_m *AptosRpcClient) TransactionByVersion(version uint64) (*api.CommittedTransaction, error) {
	ret := _m.Called(version)

	if len(ret) == 0 {
		panic("no return value specified for TransactionByVersion")
	}

	var r0 *api.CommittedTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(uint64) (*api.CommittedTransaction, error)); ok {
		return rf(version)
	}
	if rf, ok := ret.Get(0).(func(uint64) *api.CommittedTransaction); ok {
		r0 = rf(version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CommittedTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_TransactionByVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransactionByVersion'
type AptosRpcClient_TransactionByVersion_Call struct {
	*mock.Call
}

// TransactionByVersion is a helper method to define mock.On call
//   - version uint64
func (_e *AptosRpcClient_Expecter) TransactionByVersion(version interface{}) *AptosRpcClient_TransactionByVersion_Call {
	return &AptosRpcClient_TransactionByVersion_Call{Call: _e.mock.On("TransactionByVersion", version)}
}

func (_c *AptosRpcClient_TransactionByVersion_Call) Run(run func(version uint64)) *AptosRpcClient_TransactionByVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *AptosRpcClient_TransactionByVersion_Call) Return(_a0 *api.CommittedTransaction, _a1 error) *AptosRpcClient_TransactionByVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_TransactionByVersion_Call) RunAndReturn(run func(uint64) (*api.CommittedTransaction, error)) *AptosRpcClient_TransactionByVersion_Call {
	_c.Call.Return(run)
	return _c
}

// Transactions provides a mock function with given fields: start, limit
func (_m *AptosRpcClient) Transactions(start *uint64, limit *uint64) ([]*api.CommittedTransaction, error) {
	ret := _m.Called(start, limit)

	if len(ret) == 0 {
		panic("no return value specified for Transactions")
	}

	var r0 []*api.CommittedTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*uint64, *uint64) ([]*api.CommittedTransaction, error)); ok {
		return rf(start, limit)
	}
	if rf, ok := ret.Get(0).(func(*uint64, *uint64) []*api.CommittedTransaction); ok {
		r0 = rf(start, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.CommittedTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*uint64, *uint64) error); ok {
		r1 = rf(start, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_Transactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Transactions'
type AptosRpcClient_Transactions_Call struct {
	*mock.Call
}

// Transactions is a helper method to define mock.On call
//   - start *uint64
//   - limit *uint64
func (_e *AptosRpcClient_Expecter) Transactions(start interface{}, limit interface{}) *AptosRpcClient_Transactions_Call {
	return &AptosRpcClient_Transactions_Call{Call: _e.mock.On("Transactions", start, limit)}
}

func (_c *AptosRpcClient_Transactions_Call) Run(run func(start *uint64, limit *uint64)) *AptosRpcClient_Transactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*uint64), args[1].(*uint64))
	})
	return _c
}

func (_c *AptosRpcClient_Transactions_Call) Return(_a0 []*api.CommittedTransaction, _a1 error) *AptosRpcClient_Transactions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_Transactions_Call) RunAndReturn(run func(*uint64, *uint64) ([]*api.CommittedTransaction, error)) *AptosRpcClient_Transactions_Call {
	_c.Call.Return(run)
	return _c
}

// View provides a mock function with given fields: payload, ledgerVersion
func (_m *AptosRpcClient) View(payload *aptos.ViewPayload, ledgerVersion ...uint64) ([]interface{}, error) {
	_va := make([]interface{}, len(ledgerVersion))
	for _i := range ledgerVersion {
		_va[_i] = ledgerVersion[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, payload)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for View")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(*aptos.ViewPayload, ...uint64) ([]interface{}, error)); ok {
		return rf(payload, ledgerVersion...)
	}
	if rf, ok := ret.Get(0).(func(*aptos.ViewPayload, ...uint64) []interface{}); ok {
		r0 = rf(payload, ledgerVersion...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(*aptos.ViewPayload, ...uint64) error); ok {
		r1 = rf(payload, ledgerVersion...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_View_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'View'
type AptosRpcClient_View_Call struct {
	*mock.Call
}

// View is a helper method to define mock.On call
//   - payload *aptos.ViewPayload
//   - ledgerVersion ...uint64
func (_e *AptosRpcClient_Expecter) View(payload interface{}, ledgerVersion ...interface{}) *AptosRpcClient_View_Call {
	return &AptosRpcClient_View_Call{Call: _e.mock.On("View",
		append([]interface{}{payload}, ledgerVersion...)...)}
}

func (_c *AptosRpcClient_View_Call) Run(run func(payload *aptos.ViewPayload, ledgerVersion ...uint64)) *AptosRpcClient_View_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]uint64, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(uint64)
			}
		}
		run(args[0].(*aptos.ViewPayload), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_View_Call) Return(_a0 []interface{}, _a1 error) *AptosRpcClient_View_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_View_Call) RunAndReturn(run func(*aptos.ViewPayload, ...uint64) ([]interface{}, error)) *AptosRpcClient_View_Call {
	_c.Call.Return(run)
	return _c
}

// WaitForTransaction provides a mock function with given fields: txnHash, options
func (_m *AptosRpcClient) WaitForTransaction(txnHash string, options ...interface{}) (*api.UserTransaction, error) {
	var _ca []interface{}
	_ca = append(_ca, txnHash)
	_ca = append(_ca, options...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WaitForTransaction")
	}

	var r0 *api.UserTransaction
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (*api.UserTransaction, error)); ok {
		return rf(txnHash, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *api.UserTransaction); ok {
		r0 = rf(txnHash, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UserTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(txnHash, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_WaitForTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitForTransaction'
type AptosRpcClient_WaitForTransaction_Call struct {
	*mock.Call
}

// WaitForTransaction is a helper method to define mock.On call
//   - txnHash string
//   - options ...interface{}
func (_e *AptosRpcClient_Expecter) WaitForTransaction(txnHash interface{}, options ...interface{}) *AptosRpcClient_WaitForTransaction_Call {
	return &AptosRpcClient_WaitForTransaction_Call{Call: _e.mock.On("WaitForTransaction",
		append([]interface{}{txnHash}, options...)...)}
}

func (_c *AptosRpcClient_WaitForTransaction_Call) Run(run func(txnHash string, options ...interface{})) *AptosRpcClient_WaitForTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *AptosRpcClient_WaitForTransaction_Call) Return(_a0 *api.UserTransaction, _a1 error) *AptosRpcClient_WaitForTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_WaitForTransaction_Call) RunAndReturn(run func(string, ...interface{}) (*api.UserTransaction, error)) *AptosRpcClient_WaitForTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// WaitTransactionByHash provides a mock function with given fields: txnHash
func (_m *AptosRpcClient) WaitTransactionByHash(txnHash string) (*api.Transaction, error) {
	ret := _m.Called(txnHash)

	if len(ret) == 0 {
		panic("no return value specified for WaitTransactionByHash")
	}

	var r0 *api.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*api.Transaction, error)); ok {
		return rf(txnHash)
	}
	if rf, ok := ret.Get(0).(func(string) *api.Transaction); ok {
		r0 = rf(txnHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(txnHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AptosRpcClient_WaitTransactionByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitTransactionByHash'
type AptosRpcClient_WaitTransactionByHash_Call struct {
	*mock.Call
}

// WaitTransactionByHash is a helper method to define mock.On call
//   - txnHash string
func (_e *AptosRpcClient_Expecter) WaitTransactionByHash(txnHash interface{}) *AptosRpcClient_WaitTransactionByHash_Call {
	return &AptosRpcClient_WaitTransactionByHash_Call{Call: _e.mock.On("WaitTransactionByHash", txnHash)}
}

func (_c *AptosRpcClient_WaitTransactionByHash_Call) Run(run func(txnHash string)) *AptosRpcClient_WaitTransactionByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *AptosRpcClient_WaitTransactionByHash_Call) Return(_a0 *api.Transaction, _a1 error) *AptosRpcClient_WaitTransactionByHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AptosRpcClient_WaitTransactionByHash_Call) RunAndReturn(run func(string) (*api.Transaction, error)) *AptosRpcClient_WaitTransactionByHash_Call {
	_c.Call.Return(run)
	return _c
}

// NewAptosRpcClient creates a new instance of AptosRpcClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAptosRpcClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *AptosRpcClient {
	mock := &AptosRpcClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

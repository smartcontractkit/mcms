// Code generated by mockery v2.53.3. DO NOT EDIT.

package mock_module_mcms

import (
	big "math/big"

	aptos "github.com/aptos-labs/aptos-go-sdk"

	bind "github.com/smartcontractkit/chainlink-aptos/bindings/bind"

	mock "github.com/stretchr/testify/mock"

	module_mcms "github.com/smartcontractkit/chainlink-aptos/bindings/mcms/mcms"
)

// MCMSEncoder is an autogenerated mock type for the MCMSEncoder type
type MCMSEncoder struct {
	mock.Mock
}

type MCMSEncoder_Expecter struct {
	mock *mock.Mock
}

func (_m *MCMSEncoder) EXPECT() *MCMSEncoder_Expecter {
	return &MCMSEncoder_Expecter{mock: &_m.Mock}
}

// BypasserRole provides a mock function with no fields
func (_m *MCMSEncoder) BypasserRole() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for BypasserRole")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bind.ModuleInformation); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func() []aptos.TypeTag); ok {
		r2 = rf()
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func() [][]byte); ok {
		r3 = rf()
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func() error); ok {
		r4 = rf()
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_BypasserRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BypasserRole'
type MCMSEncoder_BypasserRole_Call struct {
	*mock.Call
}

// BypasserRole is a helper method to define mock.On call
func (_e *MCMSEncoder_Expecter) BypasserRole() *MCMSEncoder_BypasserRole_Call {
	return &MCMSEncoder_BypasserRole_Call{Call: _e.mock.On("BypasserRole")}
}

func (_c *MCMSEncoder_BypasserRole_Call) Run(run func()) *MCMSEncoder_BypasserRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MCMSEncoder_BypasserRole_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_BypasserRole_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_BypasserRole_Call) RunAndReturn(run func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_BypasserRole_Call {
	_c.Call.Return(run)
	return _c
}

// CancellerRole provides a mock function with no fields
func (_m *MCMSEncoder) CancellerRole() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CancellerRole")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bind.ModuleInformation); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func() []aptos.TypeTag); ok {
		r2 = rf()
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func() [][]byte); ok {
		r3 = rf()
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func() error); ok {
		r4 = rf()
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_CancellerRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancellerRole'
type MCMSEncoder_CancellerRole_Call struct {
	*mock.Call
}

// CancellerRole is a helper method to define mock.On call
func (_e *MCMSEncoder_Expecter) CancellerRole() *MCMSEncoder_CancellerRole_Call {
	return &MCMSEncoder_CancellerRole_Call{Call: _e.mock.On("CancellerRole")}
}

func (_c *MCMSEncoder_CancellerRole_Call) Run(run func()) *MCMSEncoder_CancellerRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MCMSEncoder_CancellerRole_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_CancellerRole_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_CancellerRole_Call) RunAndReturn(run func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_CancellerRole_Call {
	_c.Call.Return(run)
	return _c
}

// ChainId provides a mock function with given fields: rootMetadata
func (_m *MCMSEncoder) ChainId(rootMetadata module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for ChainId")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) bind.ModuleInformation); ok {
		r0 = rf(rootMetadata)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(module_mcms.RootMetadata) string); ok {
		r1 = rf(rootMetadata)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(module_mcms.RootMetadata) []aptos.TypeTag); ok {
		r2 = rf(rootMetadata)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(module_mcms.RootMetadata) [][]byte); ok {
		r3 = rf(rootMetadata)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(module_mcms.RootMetadata) error); ok {
		r4 = rf(rootMetadata)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_ChainId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainId'
type MCMSEncoder_ChainId_Call struct {
	*mock.Call
}

// ChainId is a helper method to define mock.On call
//   - rootMetadata module_mcms.RootMetadata
func (_e *MCMSEncoder_Expecter) ChainId(rootMetadata interface{}) *MCMSEncoder_ChainId_Call {
	return &MCMSEncoder_ChainId_Call{Call: _e.mock.On("ChainId", rootMetadata)}
}

func (_c *MCMSEncoder_ChainId_Call) Run(run func(rootMetadata module_mcms.RootMetadata)) *MCMSEncoder_ChainId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *MCMSEncoder_ChainId_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_ChainId_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_ChainId_Call) RunAndReturn(run func(module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_ChainId_Call {
	_c.Call.Return(run)
	return _c
}

// ComputeEthMessageHash provides a mock function with given fields: root, validUntil
func (_m *MCMSEncoder) ComputeEthMessageHash(root []byte, validUntil uint64) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(root, validUntil)

	if len(ret) == 0 {
		panic("no return value specified for ComputeEthMessageHash")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]byte, uint64) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(root, validUntil)
	}
	if rf, ok := ret.Get(0).(func([]byte, uint64) bind.ModuleInformation); ok {
		r0 = rf(root, validUntil)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]byte, uint64) string); ok {
		r1 = rf(root, validUntil)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]byte, uint64) []aptos.TypeTag); ok {
		r2 = rf(root, validUntil)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]byte, uint64) [][]byte); ok {
		r3 = rf(root, validUntil)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]byte, uint64) error); ok {
		r4 = rf(root, validUntil)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_ComputeEthMessageHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputeEthMessageHash'
type MCMSEncoder_ComputeEthMessageHash_Call struct {
	*mock.Call
}

// ComputeEthMessageHash is a helper method to define mock.On call
//   - root []byte
//   - validUntil uint64
func (_e *MCMSEncoder_Expecter) ComputeEthMessageHash(root interface{}, validUntil interface{}) *MCMSEncoder_ComputeEthMessageHash_Call {
	return &MCMSEncoder_ComputeEthMessageHash_Call{Call: _e.mock.On("ComputeEthMessageHash", root, validUntil)}
}

func (_c *MCMSEncoder_ComputeEthMessageHash_Call) Run(run func(root []byte, validUntil uint64)) *MCMSEncoder_ComputeEthMessageHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].(uint64))
	})
	return _c
}

func (_c *MCMSEncoder_ComputeEthMessageHash_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_ComputeEthMessageHash_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_ComputeEthMessageHash_Call) RunAndReturn(run func([]byte, uint64) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_ComputeEthMessageHash_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCalls provides a mock function with given fields: targets, moduleNames, functionNames, datas
func (_m *MCMSEncoder) CreateCalls(targets []aptos.AccountAddress, moduleNames []string, functionNames []string, datas [][]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(targets, moduleNames, functionNames, datas)

	if len(ret) == 0 {
		panic("no return value specified for CreateCalls")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]aptos.AccountAddress, []string, []string, [][]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(targets, moduleNames, functionNames, datas)
	}
	if rf, ok := ret.Get(0).(func([]aptos.AccountAddress, []string, []string, [][]byte) bind.ModuleInformation); ok {
		r0 = rf(targets, moduleNames, functionNames, datas)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]aptos.AccountAddress, []string, []string, [][]byte) string); ok {
		r1 = rf(targets, moduleNames, functionNames, datas)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]aptos.AccountAddress, []string, []string, [][]byte) []aptos.TypeTag); ok {
		r2 = rf(targets, moduleNames, functionNames, datas)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]aptos.AccountAddress, []string, []string, [][]byte) [][]byte); ok {
		r3 = rf(targets, moduleNames, functionNames, datas)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]aptos.AccountAddress, []string, []string, [][]byte) error); ok {
		r4 = rf(targets, moduleNames, functionNames, datas)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_CreateCalls_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCalls'
type MCMSEncoder_CreateCalls_Call struct {
	*mock.Call
}

// CreateCalls is a helper method to define mock.On call
//   - targets []aptos.AccountAddress
//   - moduleNames []string
//   - functionNames []string
//   - datas [][]byte
func (_e *MCMSEncoder_Expecter) CreateCalls(targets interface{}, moduleNames interface{}, functionNames interface{}, datas interface{}) *MCMSEncoder_CreateCalls_Call {
	return &MCMSEncoder_CreateCalls_Call{Call: _e.mock.On("CreateCalls", targets, moduleNames, functionNames, datas)}
}

func (_c *MCMSEncoder_CreateCalls_Call) Run(run func(targets []aptos.AccountAddress, moduleNames []string, functionNames []string, datas [][]byte)) *MCMSEncoder_CreateCalls_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]aptos.AccountAddress), args[1].([]string), args[2].([]string), args[3].([][]byte))
	})
	return _c
}

func (_c *MCMSEncoder_CreateCalls_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_CreateCalls_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_CreateCalls_Call) RunAndReturn(run func([]aptos.AccountAddress, []string, []string, [][]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_CreateCalls_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMultisig provides a mock function with given fields: role
func (_m *MCMSEncoder) CreateMultisig(role byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(role)

	if len(ret) == 0 {
		panic("no return value specified for CreateMultisig")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(role)
	}
	if rf, ok := ret.Get(0).(func(byte) bind.ModuleInformation); ok {
		r0 = rf(role)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(byte) string); ok {
		r1 = rf(role)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(byte) []aptos.TypeTag); ok {
		r2 = rf(role)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(byte) [][]byte); ok {
		r3 = rf(role)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(byte) error); ok {
		r4 = rf(role)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_CreateMultisig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMultisig'
type MCMSEncoder_CreateMultisig_Call struct {
	*mock.Call
}

// CreateMultisig is a helper method to define mock.On call
//   - role byte
func (_e *MCMSEncoder_Expecter) CreateMultisig(role interface{}) *MCMSEncoder_CreateMultisig_Call {
	return &MCMSEncoder_CreateMultisig_Call{Call: _e.mock.On("CreateMultisig", role)}
}

func (_c *MCMSEncoder_CreateMultisig_Call) Run(run func(role byte)) *MCMSEncoder_CreateMultisig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(byte))
	})
	return _c
}

func (_c *MCMSEncoder_CreateMultisig_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_CreateMultisig_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_CreateMultisig_Call) RunAndReturn(run func(byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_CreateMultisig_Call {
	_c.Call.Return(run)
	return _c
}

// Data provides a mock function with given fields: call
func (_m *MCMSEncoder) Data(call module_mcms.Call) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(call)

	if len(ret) == 0 {
		panic("no return value specified for Data")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(module_mcms.Call) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(call)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.Call) bind.ModuleInformation); ok {
		r0 = rf(call)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(module_mcms.Call) string); ok {
		r1 = rf(call)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(module_mcms.Call) []aptos.TypeTag); ok {
		r2 = rf(call)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(module_mcms.Call) [][]byte); ok {
		r3 = rf(call)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(module_mcms.Call) error); ok {
		r4 = rf(call)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_Data_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Data'
type MCMSEncoder_Data_Call struct {
	*mock.Call
}

// Data is a helper method to define mock.On call
//   - call module_mcms.Call
func (_e *MCMSEncoder_Expecter) Data(call interface{}) *MCMSEncoder_Data_Call {
	return &MCMSEncoder_Data_Call{Call: _e.mock.On("Data", call)}
}

func (_c *MCMSEncoder_Data_Call) Run(run func(call module_mcms.Call)) *MCMSEncoder_Data_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.Call))
	})
	return _c
}

func (_c *MCMSEncoder_Data_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_Data_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_Data_Call) RunAndReturn(run func(module_mcms.Call) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_Data_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchToTimelock provides a mock function with given fields: role, functionName, data
func (_m *MCMSEncoder) DispatchToTimelock(role byte, functionName string, data []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(role, functionName, data)

	if len(ret) == 0 {
		panic("no return value specified for DispatchToTimelock")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(byte, string, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(role, functionName, data)
	}
	if rf, ok := ret.Get(0).(func(byte, string, []byte) bind.ModuleInformation); ok {
		r0 = rf(role, functionName, data)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(byte, string, []byte) string); ok {
		r1 = rf(role, functionName, data)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(byte, string, []byte) []aptos.TypeTag); ok {
		r2 = rf(role, functionName, data)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(byte, string, []byte) [][]byte); ok {
		r3 = rf(role, functionName, data)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(byte, string, []byte) error); ok {
		r4 = rf(role, functionName, data)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_DispatchToTimelock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchToTimelock'
type MCMSEncoder_DispatchToTimelock_Call struct {
	*mock.Call
}

// DispatchToTimelock is a helper method to define mock.On call
//   - role byte
//   - functionName string
//   - data []byte
func (_e *MCMSEncoder_Expecter) DispatchToTimelock(role interface{}, functionName interface{}, data interface{}) *MCMSEncoder_DispatchToTimelock_Call {
	return &MCMSEncoder_DispatchToTimelock_Call{Call: _e.mock.On("DispatchToTimelock", role, functionName, data)}
}

func (_c *MCMSEncoder_DispatchToTimelock_Call) Run(run func(role byte, functionName string, data []byte)) *MCMSEncoder_DispatchToTimelock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(byte), args[1].(string), args[2].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_DispatchToTimelock_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_DispatchToTimelock_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_DispatchToTimelock_Call) RunAndReturn(run func(byte, string, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_DispatchToTimelock_Call {
	_c.Call.Return(run)
	return _c
}

// EcdsaRecoverEvmAddr provides a mock function with given fields: ethSignedMessageHash, signature
func (_m *MCMSEncoder) EcdsaRecoverEvmAddr(ethSignedMessageHash []byte, signature []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(ethSignedMessageHash, signature)

	if len(ret) == 0 {
		panic("no return value specified for EcdsaRecoverEvmAddr")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(ethSignedMessageHash, signature)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte) bind.ModuleInformation); ok {
		r0 = rf(ethSignedMessageHash, signature)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte) string); ok {
		r1 = rf(ethSignedMessageHash, signature)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]byte, []byte) []aptos.TypeTag); ok {
		r2 = rf(ethSignedMessageHash, signature)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]byte, []byte) [][]byte); ok {
		r3 = rf(ethSignedMessageHash, signature)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]byte, []byte) error); ok {
		r4 = rf(ethSignedMessageHash, signature)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_EcdsaRecoverEvmAddr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EcdsaRecoverEvmAddr'
type MCMSEncoder_EcdsaRecoverEvmAddr_Call struct {
	*mock.Call
}

// EcdsaRecoverEvmAddr is a helper method to define mock.On call
//   - ethSignedMessageHash []byte
//   - signature []byte
func (_e *MCMSEncoder_Expecter) EcdsaRecoverEvmAddr(ethSignedMessageHash interface{}, signature interface{}) *MCMSEncoder_EcdsaRecoverEvmAddr_Call {
	return &MCMSEncoder_EcdsaRecoverEvmAddr_Call{Call: _e.mock.On("EcdsaRecoverEvmAddr", ethSignedMessageHash, signature)}
}

func (_c *MCMSEncoder_EcdsaRecoverEvmAddr_Call) Run(run func(ethSignedMessageHash []byte, signature []byte)) *MCMSEncoder_EcdsaRecoverEvmAddr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_EcdsaRecoverEvmAddr_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_EcdsaRecoverEvmAddr_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_EcdsaRecoverEvmAddr_Call) RunAndReturn(run func([]byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_EcdsaRecoverEvmAddr_Call {
	_c.Call.Return(run)
	return _c
}

// Execute provides a mock function with given fields: role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof
func (_m *MCMSEncoder) Execute(role byte, chainId *big.Int, multisigAddr aptos.AccountAddress, nonce uint64, to aptos.AccountAddress, moduleName string, functionName string, data []byte, proof [][]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(byte, *big.Int, aptos.AccountAddress, uint64, aptos.AccountAddress, string, string, []byte, [][]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	}
	if rf, ok := ret.Get(0).(func(byte, *big.Int, aptos.AccountAddress, uint64, aptos.AccountAddress, string, string, []byte, [][]byte) bind.ModuleInformation); ok {
		r0 = rf(role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(byte, *big.Int, aptos.AccountAddress, uint64, aptos.AccountAddress, string, string, []byte, [][]byte) string); ok {
		r1 = rf(role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(byte, *big.Int, aptos.AccountAddress, uint64, aptos.AccountAddress, string, string, []byte, [][]byte) []aptos.TypeTag); ok {
		r2 = rf(role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(byte, *big.Int, aptos.AccountAddress, uint64, aptos.AccountAddress, string, string, []byte, [][]byte) [][]byte); ok {
		r3 = rf(role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(byte, *big.Int, aptos.AccountAddress, uint64, aptos.AccountAddress, string, string, []byte, [][]byte) error); ok {
		r4 = rf(role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MCMSEncoder_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - role byte
//   - chainId *big.Int
//   - multisigAddr aptos.AccountAddress
//   - nonce uint64
//   - to aptos.AccountAddress
//   - moduleName string
//   - functionName string
//   - data []byte
//   - proof [][]byte
func (_e *MCMSEncoder_Expecter) Execute(role interface{}, chainId interface{}, multisigAddr interface{}, nonce interface{}, to interface{}, moduleName interface{}, functionName interface{}, data interface{}, proof interface{}) *MCMSEncoder_Execute_Call {
	return &MCMSEncoder_Execute_Call{Call: _e.mock.On("Execute", role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)}
}

func (_c *MCMSEncoder_Execute_Call) Run(run func(role byte, chainId *big.Int, multisigAddr aptos.AccountAddress, nonce uint64, to aptos.AccountAddress, moduleName string, functionName string, data []byte, proof [][]byte)) *MCMSEncoder_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(byte), args[1].(*big.Int), args[2].(aptos.AccountAddress), args[3].(uint64), args[4].(aptos.AccountAddress), args[5].(string), args[6].(string), args[7].([]byte), args[8].([][]byte))
	})
	return _c
}

func (_c *MCMSEncoder_Execute_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_Execute_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_Execute_Call) RunAndReturn(run func(byte, *big.Int, aptos.AccountAddress, uint64, aptos.AccountAddress, string, string, []byte, [][]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// ExpiringRootAndOpCount provides a mock function with given fields: multisig
func (_m *MCMSEncoder) ExpiringRootAndOpCount(multisig aptos.AccountAddress) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(multisig)

	if len(ret) == 0 {
		panic("no return value specified for ExpiringRootAndOpCount")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(multisig)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress) bind.ModuleInformation); ok {
		r0 = rf(multisig)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress) string); ok {
		r1 = rf(multisig)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(aptos.AccountAddress) []aptos.TypeTag); ok {
		r2 = rf(multisig)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(aptos.AccountAddress) [][]byte); ok {
		r3 = rf(multisig)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(aptos.AccountAddress) error); ok {
		r4 = rf(multisig)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_ExpiringRootAndOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpiringRootAndOpCount'
type MCMSEncoder_ExpiringRootAndOpCount_Call struct {
	*mock.Call
}

// ExpiringRootAndOpCount is a helper method to define mock.On call
//   - multisig aptos.AccountAddress
func (_e *MCMSEncoder_Expecter) ExpiringRootAndOpCount(multisig interface{}) *MCMSEncoder_ExpiringRootAndOpCount_Call {
	return &MCMSEncoder_ExpiringRootAndOpCount_Call{Call: _e.mock.On("ExpiringRootAndOpCount", multisig)}
}

func (_c *MCMSEncoder_ExpiringRootAndOpCount_Call) Run(run func(multisig aptos.AccountAddress)) *MCMSEncoder_ExpiringRootAndOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(aptos.AccountAddress))
	})
	return _c
}

func (_c *MCMSEncoder_ExpiringRootAndOpCount_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_ExpiringRootAndOpCount_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_ExpiringRootAndOpCount_Call) RunAndReturn(run func(aptos.AccountAddress) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_ExpiringRootAndOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionName provides a mock function with given fields: function
func (_m *MCMSEncoder) FunctionName(function module_mcms.Function) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(function)

	if len(ret) == 0 {
		panic("no return value specified for FunctionName")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(module_mcms.Function) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(function)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.Function) bind.ModuleInformation); ok {
		r0 = rf(function)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(module_mcms.Function) string); ok {
		r1 = rf(function)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(module_mcms.Function) []aptos.TypeTag); ok {
		r2 = rf(function)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(module_mcms.Function) [][]byte); ok {
		r3 = rf(function)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(module_mcms.Function) error); ok {
		r4 = rf(function)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_FunctionName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionName'
type MCMSEncoder_FunctionName_Call struct {
	*mock.Call
}

// FunctionName is a helper method to define mock.On call
//   - function module_mcms.Function
func (_e *MCMSEncoder_Expecter) FunctionName(function interface{}) *MCMSEncoder_FunctionName_Call {
	return &MCMSEncoder_FunctionName_Call{Call: _e.mock.On("FunctionName", function)}
}

func (_c *MCMSEncoder_FunctionName_Call) Run(run func(function module_mcms.Function)) *MCMSEncoder_FunctionName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.Function))
	})
	return _c
}

func (_c *MCMSEncoder_FunctionName_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_FunctionName_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_FunctionName_Call) RunAndReturn(run func(module_mcms.Function) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_FunctionName_Call {
	_c.Call.Return(run)
	return _c
}

// GetConfig provides a mock function with given fields: role
func (_m *MCMSEncoder) GetConfig(role byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(role)

	if len(ret) == 0 {
		panic("no return value specified for GetConfig")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(role)
	}
	if rf, ok := ret.Get(0).(func(byte) bind.ModuleInformation); ok {
		r0 = rf(role)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(byte) string); ok {
		r1 = rf(role)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(byte) []aptos.TypeTag); ok {
		r2 = rf(role)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(byte) [][]byte); ok {
		r3 = rf(role)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(byte) error); ok {
		r4 = rf(role)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_GetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConfig'
type MCMSEncoder_GetConfig_Call struct {
	*mock.Call
}

// GetConfig is a helper method to define mock.On call
//   - role byte
func (_e *MCMSEncoder_Expecter) GetConfig(role interface{}) *MCMSEncoder_GetConfig_Call {
	return &MCMSEncoder_GetConfig_Call{Call: _e.mock.On("GetConfig", role)}
}

func (_c *MCMSEncoder_GetConfig_Call) Run(run func(role byte)) *MCMSEncoder_GetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(byte))
	})
	return _c
}

func (_c *MCMSEncoder_GetConfig_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_GetConfig_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_GetConfig_Call) RunAndReturn(run func(byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_GetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetOpCount provides a mock function with given fields: role
func (_m *MCMSEncoder) GetOpCount(role byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(role)

	if len(ret) == 0 {
		panic("no return value specified for GetOpCount")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(role)
	}
	if rf, ok := ret.Get(0).(func(byte) bind.ModuleInformation); ok {
		r0 = rf(role)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(byte) string); ok {
		r1 = rf(role)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(byte) []aptos.TypeTag); ok {
		r2 = rf(role)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(byte) [][]byte); ok {
		r3 = rf(role)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(byte) error); ok {
		r4 = rf(role)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_GetOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOpCount'
type MCMSEncoder_GetOpCount_Call struct {
	*mock.Call
}

// GetOpCount is a helper method to define mock.On call
//   - role byte
func (_e *MCMSEncoder_Expecter) GetOpCount(role interface{}) *MCMSEncoder_GetOpCount_Call {
	return &MCMSEncoder_GetOpCount_Call{Call: _e.mock.On("GetOpCount", role)}
}

func (_c *MCMSEncoder_GetOpCount_Call) Run(run func(role byte)) *MCMSEncoder_GetOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(byte))
	})
	return _c
}

func (_c *MCMSEncoder_GetOpCount_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_GetOpCount_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_GetOpCount_Call) RunAndReturn(run func(byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_GetOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoot provides a mock function with given fields: role
func (_m *MCMSEncoder) GetRoot(role byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(role)

	if len(ret) == 0 {
		panic("no return value specified for GetRoot")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(role)
	}
	if rf, ok := ret.Get(0).(func(byte) bind.ModuleInformation); ok {
		r0 = rf(role)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(byte) string); ok {
		r1 = rf(role)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(byte) []aptos.TypeTag); ok {
		r2 = rf(role)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(byte) [][]byte); ok {
		r3 = rf(role)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(byte) error); ok {
		r4 = rf(role)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_GetRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoot'
type MCMSEncoder_GetRoot_Call struct {
	*mock.Call
}

// GetRoot is a helper method to define mock.On call
//   - role byte
func (_e *MCMSEncoder_Expecter) GetRoot(role interface{}) *MCMSEncoder_GetRoot_Call {
	return &MCMSEncoder_GetRoot_Call{Call: _e.mock.On("GetRoot", role)}
}

func (_c *MCMSEncoder_GetRoot_Call) Run(run func(role byte)) *MCMSEncoder_GetRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(byte))
	})
	return _c
}

func (_c *MCMSEncoder_GetRoot_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_GetRoot_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_GetRoot_Call) RunAndReturn(run func(byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_GetRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetRootMetadata provides a mock function with given fields: role
func (_m *MCMSEncoder) GetRootMetadata(role byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(role)

	if len(ret) == 0 {
		panic("no return value specified for GetRootMetadata")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(role)
	}
	if rf, ok := ret.Get(0).(func(byte) bind.ModuleInformation); ok {
		r0 = rf(role)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(byte) string); ok {
		r1 = rf(role)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(byte) []aptos.TypeTag); ok {
		r2 = rf(role)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(byte) [][]byte); ok {
		r3 = rf(role)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(byte) error); ok {
		r4 = rf(role)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_GetRootMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRootMetadata'
type MCMSEncoder_GetRootMetadata_Call struct {
	*mock.Call
}

// GetRootMetadata is a helper method to define mock.On call
//   - role byte
func (_e *MCMSEncoder_Expecter) GetRootMetadata(role interface{}) *MCMSEncoder_GetRootMetadata_Call {
	return &MCMSEncoder_GetRootMetadata_Call{Call: _e.mock.On("GetRootMetadata", role)}
}

func (_c *MCMSEncoder_GetRootMetadata_Call) Run(run func(role byte)) *MCMSEncoder_GetRootMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(byte))
	})
	return _c
}

func (_c *MCMSEncoder_GetRootMetadata_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_GetRootMetadata_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_GetRootMetadata_Call) RunAndReturn(run func(byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_GetRootMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// HashMetadataLeaf provides a mock function with given fields: metadata
func (_m *MCMSEncoder) HashMetadataLeaf(metadata module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(metadata)

	if len(ret) == 0 {
		panic("no return value specified for HashMetadataLeaf")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(metadata)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) bind.ModuleInformation); ok {
		r0 = rf(metadata)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(module_mcms.RootMetadata) string); ok {
		r1 = rf(metadata)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(module_mcms.RootMetadata) []aptos.TypeTag); ok {
		r2 = rf(metadata)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(module_mcms.RootMetadata) [][]byte); ok {
		r3 = rf(metadata)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(module_mcms.RootMetadata) error); ok {
		r4 = rf(metadata)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_HashMetadataLeaf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashMetadataLeaf'
type MCMSEncoder_HashMetadataLeaf_Call struct {
	*mock.Call
}

// HashMetadataLeaf is a helper method to define mock.On call
//   - metadata module_mcms.RootMetadata
func (_e *MCMSEncoder_Expecter) HashMetadataLeaf(metadata interface{}) *MCMSEncoder_HashMetadataLeaf_Call {
	return &MCMSEncoder_HashMetadataLeaf_Call{Call: _e.mock.On("HashMetadataLeaf", metadata)}
}

func (_c *MCMSEncoder_HashMetadataLeaf_Call) Run(run func(metadata module_mcms.RootMetadata)) *MCMSEncoder_HashMetadataLeaf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *MCMSEncoder_HashMetadataLeaf_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_HashMetadataLeaf_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_HashMetadataLeaf_Call) RunAndReturn(run func(module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_HashMetadataLeaf_Call {
	_c.Call.Return(run)
	return _c
}

// HashOpLeaf provides a mock function with given fields: domainSeparator, op
func (_m *MCMSEncoder) HashOpLeaf(domainSeparator []byte, op module_mcms.Op) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(domainSeparator, op)

	if len(ret) == 0 {
		panic("no return value specified for HashOpLeaf")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]byte, module_mcms.Op) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(domainSeparator, op)
	}
	if rf, ok := ret.Get(0).(func([]byte, module_mcms.Op) bind.ModuleInformation); ok {
		r0 = rf(domainSeparator, op)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]byte, module_mcms.Op) string); ok {
		r1 = rf(domainSeparator, op)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]byte, module_mcms.Op) []aptos.TypeTag); ok {
		r2 = rf(domainSeparator, op)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]byte, module_mcms.Op) [][]byte); ok {
		r3 = rf(domainSeparator, op)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]byte, module_mcms.Op) error); ok {
		r4 = rf(domainSeparator, op)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_HashOpLeaf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashOpLeaf'
type MCMSEncoder_HashOpLeaf_Call struct {
	*mock.Call
}

// HashOpLeaf is a helper method to define mock.On call
//   - domainSeparator []byte
//   - op module_mcms.Op
func (_e *MCMSEncoder_Expecter) HashOpLeaf(domainSeparator interface{}, op interface{}) *MCMSEncoder_HashOpLeaf_Call {
	return &MCMSEncoder_HashOpLeaf_Call{Call: _e.mock.On("HashOpLeaf", domainSeparator, op)}
}

func (_c *MCMSEncoder_HashOpLeaf_Call) Run(run func(domainSeparator []byte, op module_mcms.Op)) *MCMSEncoder_HashOpLeaf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].(module_mcms.Op))
	})
	return _c
}

func (_c *MCMSEncoder_HashOpLeaf_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_HashOpLeaf_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_HashOpLeaf_Call) RunAndReturn(run func([]byte, module_mcms.Op) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_HashOpLeaf_Call {
	_c.Call.Return(run)
	return _c
}

// HashOperationBatch provides a mock function with given fields: calls, predecessor, salt
func (_m *MCMSEncoder) HashOperationBatch(calls []module_mcms.Call, predecessor []byte, salt []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(calls, predecessor, salt)

	if len(ret) == 0 {
		panic("no return value specified for HashOperationBatch")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]module_mcms.Call, []byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(calls, predecessor, salt)
	}
	if rf, ok := ret.Get(0).(func([]module_mcms.Call, []byte, []byte) bind.ModuleInformation); ok {
		r0 = rf(calls, predecessor, salt)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]module_mcms.Call, []byte, []byte) string); ok {
		r1 = rf(calls, predecessor, salt)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]module_mcms.Call, []byte, []byte) []aptos.TypeTag); ok {
		r2 = rf(calls, predecessor, salt)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]module_mcms.Call, []byte, []byte) [][]byte); ok {
		r3 = rf(calls, predecessor, salt)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]module_mcms.Call, []byte, []byte) error); ok {
		r4 = rf(calls, predecessor, salt)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_HashOperationBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashOperationBatch'
type MCMSEncoder_HashOperationBatch_Call struct {
	*mock.Call
}

// HashOperationBatch is a helper method to define mock.On call
//   - calls []module_mcms.Call
//   - predecessor []byte
//   - salt []byte
func (_e *MCMSEncoder_Expecter) HashOperationBatch(calls interface{}, predecessor interface{}, salt interface{}) *MCMSEncoder_HashOperationBatch_Call {
	return &MCMSEncoder_HashOperationBatch_Call{Call: _e.mock.On("HashOperationBatch", calls, predecessor, salt)}
}

func (_c *MCMSEncoder_HashOperationBatch_Call) Run(run func(calls []module_mcms.Call, predecessor []byte, salt []byte)) *MCMSEncoder_HashOperationBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]module_mcms.Call), args[1].([]byte), args[2].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_HashOperationBatch_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_HashOperationBatch_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_HashOperationBatch_Call) RunAndReturn(run func([]module_mcms.Call, []byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_HashOperationBatch_Call {
	_c.Call.Return(run)
	return _c
}

// IsValidRole provides a mock function with given fields: role
func (_m *MCMSEncoder) IsValidRole(role byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(role)

	if len(ret) == 0 {
		panic("no return value specified for IsValidRole")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(role)
	}
	if rf, ok := ret.Get(0).(func(byte) bind.ModuleInformation); ok {
		r0 = rf(role)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(byte) string); ok {
		r1 = rf(role)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(byte) []aptos.TypeTag); ok {
		r2 = rf(role)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(byte) [][]byte); ok {
		r3 = rf(role)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(byte) error); ok {
		r4 = rf(role)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_IsValidRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsValidRole'
type MCMSEncoder_IsValidRole_Call struct {
	*mock.Call
}

// IsValidRole is a helper method to define mock.On call
//   - role byte
func (_e *MCMSEncoder_Expecter) IsValidRole(role interface{}) *MCMSEncoder_IsValidRole_Call {
	return &MCMSEncoder_IsValidRole_Call{Call: _e.mock.On("IsValidRole", role)}
}

func (_c *MCMSEncoder_IsValidRole_Call) Run(run func(role byte)) *MCMSEncoder_IsValidRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(byte))
	})
	return _c
}

func (_c *MCMSEncoder_IsValidRole_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_IsValidRole_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_IsValidRole_Call) RunAndReturn(run func(byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_IsValidRole_Call {
	_c.Call.Return(run)
	return _c
}

// MaxNumSigners provides a mock function with no fields
func (_m *MCMSEncoder) MaxNumSigners() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MaxNumSigners")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bind.ModuleInformation); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func() []aptos.TypeTag); ok {
		r2 = rf()
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func() [][]byte); ok {
		r3 = rf()
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func() error); ok {
		r4 = rf()
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_MaxNumSigners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxNumSigners'
type MCMSEncoder_MaxNumSigners_Call struct {
	*mock.Call
}

// MaxNumSigners is a helper method to define mock.On call
func (_e *MCMSEncoder_Expecter) MaxNumSigners() *MCMSEncoder_MaxNumSigners_Call {
	return &MCMSEncoder_MaxNumSigners_Call{Call: _e.mock.On("MaxNumSigners")}
}

func (_c *MCMSEncoder_MaxNumSigners_Call) Run(run func()) *MCMSEncoder_MaxNumSigners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MCMSEncoder_MaxNumSigners_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_MaxNumSigners_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_MaxNumSigners_Call) RunAndReturn(run func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_MaxNumSigners_Call {
	_c.Call.Return(run)
	return _c
}

// ModuleName provides a mock function with given fields: function
func (_m *MCMSEncoder) ModuleName(function module_mcms.Function) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(function)

	if len(ret) == 0 {
		panic("no return value specified for ModuleName")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(module_mcms.Function) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(function)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.Function) bind.ModuleInformation); ok {
		r0 = rf(function)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(module_mcms.Function) string); ok {
		r1 = rf(function)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(module_mcms.Function) []aptos.TypeTag); ok {
		r2 = rf(function)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(module_mcms.Function) [][]byte); ok {
		r3 = rf(function)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(module_mcms.Function) error); ok {
		r4 = rf(function)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_ModuleName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModuleName'
type MCMSEncoder_ModuleName_Call struct {
	*mock.Call
}

// ModuleName is a helper method to define mock.On call
//   - function module_mcms.Function
func (_e *MCMSEncoder_Expecter) ModuleName(function interface{}) *MCMSEncoder_ModuleName_Call {
	return &MCMSEncoder_ModuleName_Call{Call: _e.mock.On("ModuleName", function)}
}

func (_c *MCMSEncoder_ModuleName_Call) Run(run func(function module_mcms.Function)) *MCMSEncoder_ModuleName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.Function))
	})
	return _c
}

func (_c *MCMSEncoder_ModuleName_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_ModuleName_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_ModuleName_Call) RunAndReturn(run func(module_mcms.Function) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_ModuleName_Call {
	_c.Call.Return(run)
	return _c
}

// MultisigObject provides a mock function with given fields: role
func (_m *MCMSEncoder) MultisigObject(role byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(role)

	if len(ret) == 0 {
		panic("no return value specified for MultisigObject")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(role)
	}
	if rf, ok := ret.Get(0).(func(byte) bind.ModuleInformation); ok {
		r0 = rf(role)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(byte) string); ok {
		r1 = rf(role)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(byte) []aptos.TypeTag); ok {
		r2 = rf(role)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(byte) [][]byte); ok {
		r3 = rf(role)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(byte) error); ok {
		r4 = rf(role)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_MultisigObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MultisigObject'
type MCMSEncoder_MultisigObject_Call struct {
	*mock.Call
}

// MultisigObject is a helper method to define mock.On call
//   - role byte
func (_e *MCMSEncoder_Expecter) MultisigObject(role interface{}) *MCMSEncoder_MultisigObject_Call {
	return &MCMSEncoder_MultisigObject_Call{Call: _e.mock.On("MultisigObject", role)}
}

func (_c *MCMSEncoder_MultisigObject_Call) Run(run func(role byte)) *MCMSEncoder_MultisigObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(byte))
	})
	return _c
}

func (_c *MCMSEncoder_MultisigObject_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_MultisigObject_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_MultisigObject_Call) RunAndReturn(run func(byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_MultisigObject_Call {
	_c.Call.Return(run)
	return _c
}

// NumGroups provides a mock function with no fields
func (_m *MCMSEncoder) NumGroups() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for NumGroups")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bind.ModuleInformation); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func() []aptos.TypeTag); ok {
		r2 = rf()
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func() [][]byte); ok {
		r3 = rf()
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func() error); ok {
		r4 = rf()
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_NumGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NumGroups'
type MCMSEncoder_NumGroups_Call struct {
	*mock.Call
}

// NumGroups is a helper method to define mock.On call
func (_e *MCMSEncoder_Expecter) NumGroups() *MCMSEncoder_NumGroups_Call {
	return &MCMSEncoder_NumGroups_Call{Call: _e.mock.On("NumGroups")}
}

func (_c *MCMSEncoder_NumGroups_Call) Run(run func()) *MCMSEncoder_NumGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MCMSEncoder_NumGroups_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_NumGroups_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_NumGroups_Call) RunAndReturn(run func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_NumGroups_Call {
	_c.Call.Return(run)
	return _c
}

// OverridePreviousRoot provides a mock function with given fields: rootMetadata
func (_m *MCMSEncoder) OverridePreviousRoot(rootMetadata module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for OverridePreviousRoot")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) bind.ModuleInformation); ok {
		r0 = rf(rootMetadata)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(module_mcms.RootMetadata) string); ok {
		r1 = rf(rootMetadata)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(module_mcms.RootMetadata) []aptos.TypeTag); ok {
		r2 = rf(rootMetadata)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(module_mcms.RootMetadata) [][]byte); ok {
		r3 = rf(rootMetadata)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(module_mcms.RootMetadata) error); ok {
		r4 = rf(rootMetadata)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_OverridePreviousRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OverridePreviousRoot'
type MCMSEncoder_OverridePreviousRoot_Call struct {
	*mock.Call
}

// OverridePreviousRoot is a helper method to define mock.On call
//   - rootMetadata module_mcms.RootMetadata
func (_e *MCMSEncoder_Expecter) OverridePreviousRoot(rootMetadata interface{}) *MCMSEncoder_OverridePreviousRoot_Call {
	return &MCMSEncoder_OverridePreviousRoot_Call{Call: _e.mock.On("OverridePreviousRoot", rootMetadata)}
}

func (_c *MCMSEncoder_OverridePreviousRoot_Call) Run(run func(rootMetadata module_mcms.RootMetadata)) *MCMSEncoder_OverridePreviousRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *MCMSEncoder_OverridePreviousRoot_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_OverridePreviousRoot_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_OverridePreviousRoot_Call) RunAndReturn(run func(module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_OverridePreviousRoot_Call {
	_c.Call.Return(run)
	return _c
}

// PostOpCount provides a mock function with given fields: rootMetadata
func (_m *MCMSEncoder) PostOpCount(rootMetadata module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for PostOpCount")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) bind.ModuleInformation); ok {
		r0 = rf(rootMetadata)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(module_mcms.RootMetadata) string); ok {
		r1 = rf(rootMetadata)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(module_mcms.RootMetadata) []aptos.TypeTag); ok {
		r2 = rf(rootMetadata)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(module_mcms.RootMetadata) [][]byte); ok {
		r3 = rf(rootMetadata)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(module_mcms.RootMetadata) error); ok {
		r4 = rf(rootMetadata)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_PostOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PostOpCount'
type MCMSEncoder_PostOpCount_Call struct {
	*mock.Call
}

// PostOpCount is a helper method to define mock.On call
//   - rootMetadata module_mcms.RootMetadata
func (_e *MCMSEncoder_Expecter) PostOpCount(rootMetadata interface{}) *MCMSEncoder_PostOpCount_Call {
	return &MCMSEncoder_PostOpCount_Call{Call: _e.mock.On("PostOpCount", rootMetadata)}
}

func (_c *MCMSEncoder_PostOpCount_Call) Run(run func(rootMetadata module_mcms.RootMetadata)) *MCMSEncoder_PostOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *MCMSEncoder_PostOpCount_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_PostOpCount_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_PostOpCount_Call) RunAndReturn(run func(module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_PostOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// PreOpCount provides a mock function with given fields: rootMetadata
func (_m *MCMSEncoder) PreOpCount(rootMetadata module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for PreOpCount")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) bind.ModuleInformation); ok {
		r0 = rf(rootMetadata)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(module_mcms.RootMetadata) string); ok {
		r1 = rf(rootMetadata)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(module_mcms.RootMetadata) []aptos.TypeTag); ok {
		r2 = rf(rootMetadata)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(module_mcms.RootMetadata) [][]byte); ok {
		r3 = rf(rootMetadata)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(module_mcms.RootMetadata) error); ok {
		r4 = rf(rootMetadata)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_PreOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PreOpCount'
type MCMSEncoder_PreOpCount_Call struct {
	*mock.Call
}

// PreOpCount is a helper method to define mock.On call
//   - rootMetadata module_mcms.RootMetadata
func (_e *MCMSEncoder_Expecter) PreOpCount(rootMetadata interface{}) *MCMSEncoder_PreOpCount_Call {
	return &MCMSEncoder_PreOpCount_Call{Call: _e.mock.On("PreOpCount", rootMetadata)}
}

func (_c *MCMSEncoder_PreOpCount_Call) Run(run func(rootMetadata module_mcms.RootMetadata)) *MCMSEncoder_PreOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *MCMSEncoder_PreOpCount_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_PreOpCount_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_PreOpCount_Call) RunAndReturn(run func(module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_PreOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// ProposerRole provides a mock function with no fields
func (_m *MCMSEncoder) ProposerRole() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ProposerRole")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bind.ModuleInformation); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func() []aptos.TypeTag); ok {
		r2 = rf()
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func() [][]byte); ok {
		r3 = rf()
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func() error); ok {
		r4 = rf()
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_ProposerRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProposerRole'
type MCMSEncoder_ProposerRole_Call struct {
	*mock.Call
}

// ProposerRole is a helper method to define mock.On call
func (_e *MCMSEncoder_Expecter) ProposerRole() *MCMSEncoder_ProposerRole_Call {
	return &MCMSEncoder_ProposerRole_Call{Call: _e.mock.On("ProposerRole")}
}

func (_c *MCMSEncoder_ProposerRole_Call) Run(run func()) *MCMSEncoder_ProposerRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MCMSEncoder_ProposerRole_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_ProposerRole_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_ProposerRole_Call) RunAndReturn(run func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_ProposerRole_Call {
	_c.Call.Return(run)
	return _c
}

// Role provides a mock function with given fields: rootMetadata
func (_m *MCMSEncoder) Role(rootMetadata module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for Role")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) bind.ModuleInformation); ok {
		r0 = rf(rootMetadata)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(module_mcms.RootMetadata) string); ok {
		r1 = rf(rootMetadata)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(module_mcms.RootMetadata) []aptos.TypeTag); ok {
		r2 = rf(rootMetadata)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(module_mcms.RootMetadata) [][]byte); ok {
		r3 = rf(rootMetadata)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(module_mcms.RootMetadata) error); ok {
		r4 = rf(rootMetadata)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_Role_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Role'
type MCMSEncoder_Role_Call struct {
	*mock.Call
}

// Role is a helper method to define mock.On call
//   - rootMetadata module_mcms.RootMetadata
func (_e *MCMSEncoder_Expecter) Role(rootMetadata interface{}) *MCMSEncoder_Role_Call {
	return &MCMSEncoder_Role_Call{Call: _e.mock.On("Role", rootMetadata)}
}

func (_c *MCMSEncoder_Role_Call) Run(run func(rootMetadata module_mcms.RootMetadata)) *MCMSEncoder_Role_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *MCMSEncoder_Role_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_Role_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_Role_Call) RunAndReturn(run func(module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_Role_Call {
	_c.Call.Return(run)
	return _c
}

// RootMetadata provides a mock function with given fields: multisig
func (_m *MCMSEncoder) RootMetadata(multisig aptos.AccountAddress) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(multisig)

	if len(ret) == 0 {
		panic("no return value specified for RootMetadata")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(multisig)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress) bind.ModuleInformation); ok {
		r0 = rf(multisig)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress) string); ok {
		r1 = rf(multisig)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(aptos.AccountAddress) []aptos.TypeTag); ok {
		r2 = rf(multisig)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(aptos.AccountAddress) [][]byte); ok {
		r3 = rf(multisig)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(aptos.AccountAddress) error); ok {
		r4 = rf(multisig)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_RootMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RootMetadata'
type MCMSEncoder_RootMetadata_Call struct {
	*mock.Call
}

// RootMetadata is a helper method to define mock.On call
//   - multisig aptos.AccountAddress
func (_e *MCMSEncoder_Expecter) RootMetadata(multisig interface{}) *MCMSEncoder_RootMetadata_Call {
	return &MCMSEncoder_RootMetadata_Call{Call: _e.mock.On("RootMetadata", multisig)}
}

func (_c *MCMSEncoder_RootMetadata_Call) Run(run func(multisig aptos.AccountAddress)) *MCMSEncoder_RootMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(aptos.AccountAddress))
	})
	return _c
}

func (_c *MCMSEncoder_RootMetadata_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_RootMetadata_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_RootMetadata_Call) RunAndReturn(run func(aptos.AccountAddress) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_RootMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// RootMetadataMultisig provides a mock function with given fields: rootMetadata
func (_m *MCMSEncoder) RootMetadataMultisig(rootMetadata module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for RootMetadataMultisig")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) bind.ModuleInformation); ok {
		r0 = rf(rootMetadata)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(module_mcms.RootMetadata) string); ok {
		r1 = rf(rootMetadata)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(module_mcms.RootMetadata) []aptos.TypeTag); ok {
		r2 = rf(rootMetadata)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(module_mcms.RootMetadata) [][]byte); ok {
		r3 = rf(rootMetadata)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(module_mcms.RootMetadata) error); ok {
		r4 = rf(rootMetadata)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_RootMetadataMultisig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RootMetadataMultisig'
type MCMSEncoder_RootMetadataMultisig_Call struct {
	*mock.Call
}

// RootMetadataMultisig is a helper method to define mock.On call
//   - rootMetadata module_mcms.RootMetadata
func (_e *MCMSEncoder_Expecter) RootMetadataMultisig(rootMetadata interface{}) *MCMSEncoder_RootMetadataMultisig_Call {
	return &MCMSEncoder_RootMetadataMultisig_Call{Call: _e.mock.On("RootMetadataMultisig", rootMetadata)}
}

func (_c *MCMSEncoder_RootMetadataMultisig_Call) Run(run func(rootMetadata module_mcms.RootMetadata)) *MCMSEncoder_RootMetadataMultisig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *MCMSEncoder_RootMetadataMultisig_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_RootMetadataMultisig_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_RootMetadataMultisig_Call) RunAndReturn(run func(module_mcms.RootMetadata) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_RootMetadataMultisig_Call {
	_c.Call.Return(run)
	return _c
}

// SeenSignedHashes provides a mock function with given fields: multisig
func (_m *MCMSEncoder) SeenSignedHashes(multisig aptos.AccountAddress) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(multisig)

	if len(ret) == 0 {
		panic("no return value specified for SeenSignedHashes")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(multisig)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress) bind.ModuleInformation); ok {
		r0 = rf(multisig)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress) string); ok {
		r1 = rf(multisig)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(aptos.AccountAddress) []aptos.TypeTag); ok {
		r2 = rf(multisig)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(aptos.AccountAddress) [][]byte); ok {
		r3 = rf(multisig)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(aptos.AccountAddress) error); ok {
		r4 = rf(multisig)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_SeenSignedHashes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SeenSignedHashes'
type MCMSEncoder_SeenSignedHashes_Call struct {
	*mock.Call
}

// SeenSignedHashes is a helper method to define mock.On call
//   - multisig aptos.AccountAddress
func (_e *MCMSEncoder_Expecter) SeenSignedHashes(multisig interface{}) *MCMSEncoder_SeenSignedHashes_Call {
	return &MCMSEncoder_SeenSignedHashes_Call{Call: _e.mock.On("SeenSignedHashes", multisig)}
}

func (_c *MCMSEncoder_SeenSignedHashes_Call) Run(run func(multisig aptos.AccountAddress)) *MCMSEncoder_SeenSignedHashes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(aptos.AccountAddress))
	})
	return _c
}

func (_c *MCMSEncoder_SeenSignedHashes_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_SeenSignedHashes_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_SeenSignedHashes_Call) RunAndReturn(run func(aptos.AccountAddress) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_SeenSignedHashes_Call {
	_c.Call.Return(run)
	return _c
}

// SetConfig provides a mock function with given fields: role, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot
func (_m *MCMSEncoder) SetConfig(role byte, signerAddresses [][]byte, signerGroups []byte, groupQuorums []byte, groupParents []byte, clearRoot bool) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(role, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)

	if len(ret) == 0 {
		panic("no return value specified for SetConfig")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(byte, [][]byte, []byte, []byte, []byte, bool) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(role, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	}
	if rf, ok := ret.Get(0).(func(byte, [][]byte, []byte, []byte, []byte, bool) bind.ModuleInformation); ok {
		r0 = rf(role, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(byte, [][]byte, []byte, []byte, []byte, bool) string); ok {
		r1 = rf(role, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(byte, [][]byte, []byte, []byte, []byte, bool) []aptos.TypeTag); ok {
		r2 = rf(role, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(byte, [][]byte, []byte, []byte, []byte, bool) [][]byte); ok {
		r3 = rf(role, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(byte, [][]byte, []byte, []byte, []byte, bool) error); ok {
		r4 = rf(role, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_SetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetConfig'
type MCMSEncoder_SetConfig_Call struct {
	*mock.Call
}

// SetConfig is a helper method to define mock.On call
//   - role byte
//   - signerAddresses [][]byte
//   - signerGroups []byte
//   - groupQuorums []byte
//   - groupParents []byte
//   - clearRoot bool
func (_e *MCMSEncoder_Expecter) SetConfig(role interface{}, signerAddresses interface{}, signerGroups interface{}, groupQuorums interface{}, groupParents interface{}, clearRoot interface{}) *MCMSEncoder_SetConfig_Call {
	return &MCMSEncoder_SetConfig_Call{Call: _e.mock.On("SetConfig", role, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)}
}

func (_c *MCMSEncoder_SetConfig_Call) Run(run func(role byte, signerAddresses [][]byte, signerGroups []byte, groupQuorums []byte, groupParents []byte, clearRoot bool)) *MCMSEncoder_SetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(byte), args[1].([][]byte), args[2].([]byte), args[3].([]byte), args[4].([]byte), args[5].(bool))
	})
	return _c
}

func (_c *MCMSEncoder_SetConfig_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_SetConfig_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_SetConfig_Call) RunAndReturn(run func(byte, [][]byte, []byte, []byte, []byte, bool) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_SetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// SetRoot provides a mock function with given fields: role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures
func (_m *MCMSEncoder) SetRoot(role byte, root []byte, validUntil uint64, chainId *big.Int, multisigAddr aptos.AccountAddress, preOpCount uint64, postOpCount uint64, overridePreviousRoot bool, metadataProof [][]byte, signatures [][]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)

	if len(ret) == 0 {
		panic("no return value specified for SetRoot")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(byte, []byte, uint64, *big.Int, aptos.AccountAddress, uint64, uint64, bool, [][]byte, [][]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)
	}
	if rf, ok := ret.Get(0).(func(byte, []byte, uint64, *big.Int, aptos.AccountAddress, uint64, uint64, bool, [][]byte, [][]byte) bind.ModuleInformation); ok {
		r0 = rf(role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(byte, []byte, uint64, *big.Int, aptos.AccountAddress, uint64, uint64, bool, [][]byte, [][]byte) string); ok {
		r1 = rf(role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(byte, []byte, uint64, *big.Int, aptos.AccountAddress, uint64, uint64, bool, [][]byte, [][]byte) []aptos.TypeTag); ok {
		r2 = rf(role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(byte, []byte, uint64, *big.Int, aptos.AccountAddress, uint64, uint64, bool, [][]byte, [][]byte) [][]byte); ok {
		r3 = rf(role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(byte, []byte, uint64, *big.Int, aptos.AccountAddress, uint64, uint64, bool, [][]byte, [][]byte) error); ok {
		r4 = rf(role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_SetRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRoot'
type MCMSEncoder_SetRoot_Call struct {
	*mock.Call
}

// SetRoot is a helper method to define mock.On call
//   - role byte
//   - root []byte
//   - validUntil uint64
//   - chainId *big.Int
//   - multisigAddr aptos.AccountAddress
//   - preOpCount uint64
//   - postOpCount uint64
//   - overridePreviousRoot bool
//   - metadataProof [][]byte
//   - signatures [][]byte
func (_e *MCMSEncoder_Expecter) SetRoot(role interface{}, root interface{}, validUntil interface{}, chainId interface{}, multisigAddr interface{}, preOpCount interface{}, postOpCount interface{}, overridePreviousRoot interface{}, metadataProof interface{}, signatures interface{}) *MCMSEncoder_SetRoot_Call {
	return &MCMSEncoder_SetRoot_Call{Call: _e.mock.On("SetRoot", role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)}
}

func (_c *MCMSEncoder_SetRoot_Call) Run(run func(role byte, root []byte, validUntil uint64, chainId *big.Int, multisigAddr aptos.AccountAddress, preOpCount uint64, postOpCount uint64, overridePreviousRoot bool, metadataProof [][]byte, signatures [][]byte)) *MCMSEncoder_SetRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(byte), args[1].([]byte), args[2].(uint64), args[3].(*big.Int), args[4].(aptos.AccountAddress), args[5].(uint64), args[6].(uint64), args[7].(bool), args[8].([][]byte), args[9].([][]byte))
	})
	return _c
}

func (_c *MCMSEncoder_SetRoot_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_SetRoot_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_SetRoot_Call) RunAndReturn(run func(byte, []byte, uint64, *big.Int, aptos.AccountAddress, uint64, uint64, bool, [][]byte, [][]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_SetRoot_Call {
	_c.Call.Return(run)
	return _c
}

// Signers provides a mock function with given fields: multisig
func (_m *MCMSEncoder) Signers(multisig aptos.AccountAddress) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(multisig)

	if len(ret) == 0 {
		panic("no return value specified for Signers")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(multisig)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress) bind.ModuleInformation); ok {
		r0 = rf(multisig)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress) string); ok {
		r1 = rf(multisig)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(aptos.AccountAddress) []aptos.TypeTag); ok {
		r2 = rf(multisig)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(aptos.AccountAddress) [][]byte); ok {
		r3 = rf(multisig)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(aptos.AccountAddress) error); ok {
		r4 = rf(multisig)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_Signers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Signers'
type MCMSEncoder_Signers_Call struct {
	*mock.Call
}

// Signers is a helper method to define mock.On call
//   - multisig aptos.AccountAddress
func (_e *MCMSEncoder_Expecter) Signers(multisig interface{}) *MCMSEncoder_Signers_Call {
	return &MCMSEncoder_Signers_Call{Call: _e.mock.On("Signers", multisig)}
}

func (_c *MCMSEncoder_Signers_Call) Run(run func(multisig aptos.AccountAddress)) *MCMSEncoder_Signers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(aptos.AccountAddress))
	})
	return _c
}

func (_c *MCMSEncoder_Signers_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_Signers_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_Signers_Call) RunAndReturn(run func(aptos.AccountAddress) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_Signers_Call {
	_c.Call.Return(run)
	return _c
}

// Target provides a mock function with given fields: function
func (_m *MCMSEncoder) Target(function module_mcms.Function) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(function)

	if len(ret) == 0 {
		panic("no return value specified for Target")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(module_mcms.Function) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(function)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.Function) bind.ModuleInformation); ok {
		r0 = rf(function)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(module_mcms.Function) string); ok {
		r1 = rf(function)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(module_mcms.Function) []aptos.TypeTag); ok {
		r2 = rf(function)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(module_mcms.Function) [][]byte); ok {
		r3 = rf(function)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(module_mcms.Function) error); ok {
		r4 = rf(function)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_Target_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Target'
type MCMSEncoder_Target_Call struct {
	*mock.Call
}

// Target is a helper method to define mock.On call
//   - function module_mcms.Function
func (_e *MCMSEncoder_Expecter) Target(function interface{}) *MCMSEncoder_Target_Call {
	return &MCMSEncoder_Target_Call{Call: _e.mock.On("Target", function)}
}

func (_c *MCMSEncoder_Target_Call) Run(run func(function module_mcms.Function)) *MCMSEncoder_Target_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.Function))
	})
	return _c
}

func (_c *MCMSEncoder_Target_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_Target_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_Target_Call) RunAndReturn(run func(module_mcms.Function) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_Target_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockAfterCall provides a mock function with given fields: id
func (_m *MCMSEncoder) TimelockAfterCall(id []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockAfterCall")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func([]byte) bind.ModuleInformation); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]byte) string); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]byte) []aptos.TypeTag); ok {
		r2 = rf(id)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]byte) [][]byte); ok {
		r3 = rf(id)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]byte) error); ok {
		r4 = rf(id)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockAfterCall_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockAfterCall'
type MCMSEncoder_TimelockAfterCall_Call struct {
	*mock.Call
}

// TimelockAfterCall is a helper method to define mock.On call
//   - id []byte
func (_e *MCMSEncoder_Expecter) TimelockAfterCall(id interface{}) *MCMSEncoder_TimelockAfterCall_Call {
	return &MCMSEncoder_TimelockAfterCall_Call{Call: _e.mock.On("TimelockAfterCall", id)}
}

func (_c *MCMSEncoder_TimelockAfterCall_Call) Run(run func(id []byte)) *MCMSEncoder_TimelockAfterCall_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockAfterCall_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockAfterCall_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockAfterCall_Call) RunAndReturn(run func([]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockAfterCall_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockBeforeCall provides a mock function with given fields: id, predecessor
func (_m *MCMSEncoder) TimelockBeforeCall(id []byte, predecessor []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(id, predecessor)

	if len(ret) == 0 {
		panic("no return value specified for TimelockBeforeCall")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(id, predecessor)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte) bind.ModuleInformation); ok {
		r0 = rf(id, predecessor)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte) string); ok {
		r1 = rf(id, predecessor)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]byte, []byte) []aptos.TypeTag); ok {
		r2 = rf(id, predecessor)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]byte, []byte) [][]byte); ok {
		r3 = rf(id, predecessor)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]byte, []byte) error); ok {
		r4 = rf(id, predecessor)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockBeforeCall_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockBeforeCall'
type MCMSEncoder_TimelockBeforeCall_Call struct {
	*mock.Call
}

// TimelockBeforeCall is a helper method to define mock.On call
//   - id []byte
//   - predecessor []byte
func (_e *MCMSEncoder_Expecter) TimelockBeforeCall(id interface{}, predecessor interface{}) *MCMSEncoder_TimelockBeforeCall_Call {
	return &MCMSEncoder_TimelockBeforeCall_Call{Call: _e.mock.On("TimelockBeforeCall", id, predecessor)}
}

func (_c *MCMSEncoder_TimelockBeforeCall_Call) Run(run func(id []byte, predecessor []byte)) *MCMSEncoder_TimelockBeforeCall_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockBeforeCall_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockBeforeCall_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockBeforeCall_Call) RunAndReturn(run func([]byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockBeforeCall_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockBlockFunction provides a mock function with given fields: target, moduleName, functionName
func (_m *MCMSEncoder) TimelockBlockFunction(target aptos.AccountAddress, moduleName string, functionName string) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(target, moduleName, functionName)

	if len(ret) == 0 {
		panic("no return value specified for TimelockBlockFunction")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, string) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(target, moduleName, functionName)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, string) bind.ModuleInformation); ok {
		r0 = rf(target, moduleName, functionName)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, string, string) string); ok {
		r1 = rf(target, moduleName, functionName)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(aptos.AccountAddress, string, string) []aptos.TypeTag); ok {
		r2 = rf(target, moduleName, functionName)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(aptos.AccountAddress, string, string) [][]byte); ok {
		r3 = rf(target, moduleName, functionName)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(aptos.AccountAddress, string, string) error); ok {
		r4 = rf(target, moduleName, functionName)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockBlockFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockBlockFunction'
type MCMSEncoder_TimelockBlockFunction_Call struct {
	*mock.Call
}

// TimelockBlockFunction is a helper method to define mock.On call
//   - target aptos.AccountAddress
//   - moduleName string
//   - functionName string
func (_e *MCMSEncoder_Expecter) TimelockBlockFunction(target interface{}, moduleName interface{}, functionName interface{}) *MCMSEncoder_TimelockBlockFunction_Call {
	return &MCMSEncoder_TimelockBlockFunction_Call{Call: _e.mock.On("TimelockBlockFunction", target, moduleName, functionName)}
}

func (_c *MCMSEncoder_TimelockBlockFunction_Call) Run(run func(target aptos.AccountAddress, moduleName string, functionName string)) *MCMSEncoder_TimelockBlockFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(aptos.AccountAddress), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockBlockFunction_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockBlockFunction_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockBlockFunction_Call) RunAndReturn(run func(aptos.AccountAddress, string, string) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockBlockFunction_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockBypasserExecuteBatch provides a mock function with given fields: targets, moduleNames, functionNames, datas
func (_m *MCMSEncoder) TimelockBypasserExecuteBatch(targets []aptos.AccountAddress, moduleNames []string, functionNames []string, datas [][]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(targets, moduleNames, functionNames, datas)

	if len(ret) == 0 {
		panic("no return value specified for TimelockBypasserExecuteBatch")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]aptos.AccountAddress, []string, []string, [][]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(targets, moduleNames, functionNames, datas)
	}
	if rf, ok := ret.Get(0).(func([]aptos.AccountAddress, []string, []string, [][]byte) bind.ModuleInformation); ok {
		r0 = rf(targets, moduleNames, functionNames, datas)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]aptos.AccountAddress, []string, []string, [][]byte) string); ok {
		r1 = rf(targets, moduleNames, functionNames, datas)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]aptos.AccountAddress, []string, []string, [][]byte) []aptos.TypeTag); ok {
		r2 = rf(targets, moduleNames, functionNames, datas)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]aptos.AccountAddress, []string, []string, [][]byte) [][]byte); ok {
		r3 = rf(targets, moduleNames, functionNames, datas)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]aptos.AccountAddress, []string, []string, [][]byte) error); ok {
		r4 = rf(targets, moduleNames, functionNames, datas)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockBypasserExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockBypasserExecuteBatch'
type MCMSEncoder_TimelockBypasserExecuteBatch_Call struct {
	*mock.Call
}

// TimelockBypasserExecuteBatch is a helper method to define mock.On call
//   - targets []aptos.AccountAddress
//   - moduleNames []string
//   - functionNames []string
//   - datas [][]byte
func (_e *MCMSEncoder_Expecter) TimelockBypasserExecuteBatch(targets interface{}, moduleNames interface{}, functionNames interface{}, datas interface{}) *MCMSEncoder_TimelockBypasserExecuteBatch_Call {
	return &MCMSEncoder_TimelockBypasserExecuteBatch_Call{Call: _e.mock.On("TimelockBypasserExecuteBatch", targets, moduleNames, functionNames, datas)}
}

func (_c *MCMSEncoder_TimelockBypasserExecuteBatch_Call) Run(run func(targets []aptos.AccountAddress, moduleNames []string, functionNames []string, datas [][]byte)) *MCMSEncoder_TimelockBypasserExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]aptos.AccountAddress), args[1].([]string), args[2].([]string), args[3].([][]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockBypasserExecuteBatch_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockBypasserExecuteBatch_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockBypasserExecuteBatch_Call) RunAndReturn(run func([]aptos.AccountAddress, []string, []string, [][]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockBypasserExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockCancel provides a mock function with given fields: id
func (_m *MCMSEncoder) TimelockCancel(id []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockCancel")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func([]byte) bind.ModuleInformation); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]byte) string); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]byte) []aptos.TypeTag); ok {
		r2 = rf(id)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]byte) [][]byte); ok {
		r3 = rf(id)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]byte) error); ok {
		r4 = rf(id)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockCancel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockCancel'
type MCMSEncoder_TimelockCancel_Call struct {
	*mock.Call
}

// TimelockCancel is a helper method to define mock.On call
//   - id []byte
func (_e *MCMSEncoder_Expecter) TimelockCancel(id interface{}) *MCMSEncoder_TimelockCancel_Call {
	return &MCMSEncoder_TimelockCancel_Call{Call: _e.mock.On("TimelockCancel", id)}
}

func (_c *MCMSEncoder_TimelockCancel_Call) Run(run func(id []byte)) *MCMSEncoder_TimelockCancel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockCancel_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockCancel_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockCancel_Call) RunAndReturn(run func([]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockCancel_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockDispatch provides a mock function with given fields: target, moduleName, functionName, data
func (_m *MCMSEncoder) TimelockDispatch(target aptos.AccountAddress, moduleName string, functionName string, data []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(target, moduleName, functionName, data)

	if len(ret) == 0 {
		panic("no return value specified for TimelockDispatch")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, string, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(target, moduleName, functionName, data)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, string, []byte) bind.ModuleInformation); ok {
		r0 = rf(target, moduleName, functionName, data)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, string, string, []byte) string); ok {
		r1 = rf(target, moduleName, functionName, data)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(aptos.AccountAddress, string, string, []byte) []aptos.TypeTag); ok {
		r2 = rf(target, moduleName, functionName, data)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(aptos.AccountAddress, string, string, []byte) [][]byte); ok {
		r3 = rf(target, moduleName, functionName, data)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(aptos.AccountAddress, string, string, []byte) error); ok {
		r4 = rf(target, moduleName, functionName, data)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockDispatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockDispatch'
type MCMSEncoder_TimelockDispatch_Call struct {
	*mock.Call
}

// TimelockDispatch is a helper method to define mock.On call
//   - target aptos.AccountAddress
//   - moduleName string
//   - functionName string
//   - data []byte
func (_e *MCMSEncoder_Expecter) TimelockDispatch(target interface{}, moduleName interface{}, functionName interface{}, data interface{}) *MCMSEncoder_TimelockDispatch_Call {
	return &MCMSEncoder_TimelockDispatch_Call{Call: _e.mock.On("TimelockDispatch", target, moduleName, functionName, data)}
}

func (_c *MCMSEncoder_TimelockDispatch_Call) Run(run func(target aptos.AccountAddress, moduleName string, functionName string, data []byte)) *MCMSEncoder_TimelockDispatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(aptos.AccountAddress), args[1].(string), args[2].(string), args[3].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockDispatch_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockDispatch_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockDispatch_Call) RunAndReturn(run func(aptos.AccountAddress, string, string, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockDispatch_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockDispatchToAccount provides a mock function with given fields: functionNameBytes, data
func (_m *MCMSEncoder) TimelockDispatchToAccount(functionNameBytes []byte, data []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(functionNameBytes, data)

	if len(ret) == 0 {
		panic("no return value specified for TimelockDispatchToAccount")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(functionNameBytes, data)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte) bind.ModuleInformation); ok {
		r0 = rf(functionNameBytes, data)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte) string); ok {
		r1 = rf(functionNameBytes, data)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]byte, []byte) []aptos.TypeTag); ok {
		r2 = rf(functionNameBytes, data)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]byte, []byte) [][]byte); ok {
		r3 = rf(functionNameBytes, data)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]byte, []byte) error); ok {
		r4 = rf(functionNameBytes, data)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockDispatchToAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockDispatchToAccount'
type MCMSEncoder_TimelockDispatchToAccount_Call struct {
	*mock.Call
}

// TimelockDispatchToAccount is a helper method to define mock.On call
//   - functionNameBytes []byte
//   - data []byte
func (_e *MCMSEncoder_Expecter) TimelockDispatchToAccount(functionNameBytes interface{}, data interface{}) *MCMSEncoder_TimelockDispatchToAccount_Call {
	return &MCMSEncoder_TimelockDispatchToAccount_Call{Call: _e.mock.On("TimelockDispatchToAccount", functionNameBytes, data)}
}

func (_c *MCMSEncoder_TimelockDispatchToAccount_Call) Run(run func(functionNameBytes []byte, data []byte)) *MCMSEncoder_TimelockDispatchToAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockDispatchToAccount_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockDispatchToAccount_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockDispatchToAccount_Call) RunAndReturn(run func([]byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockDispatchToAccount_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockDispatchToDeployer provides a mock function with given fields: functionNameBytes, data
func (_m *MCMSEncoder) TimelockDispatchToDeployer(functionNameBytes []byte, data []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(functionNameBytes, data)

	if len(ret) == 0 {
		panic("no return value specified for TimelockDispatchToDeployer")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(functionNameBytes, data)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte) bind.ModuleInformation); ok {
		r0 = rf(functionNameBytes, data)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte) string); ok {
		r1 = rf(functionNameBytes, data)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]byte, []byte) []aptos.TypeTag); ok {
		r2 = rf(functionNameBytes, data)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]byte, []byte) [][]byte); ok {
		r3 = rf(functionNameBytes, data)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]byte, []byte) error); ok {
		r4 = rf(functionNameBytes, data)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockDispatchToDeployer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockDispatchToDeployer'
type MCMSEncoder_TimelockDispatchToDeployer_Call struct {
	*mock.Call
}

// TimelockDispatchToDeployer is a helper method to define mock.On call
//   - functionNameBytes []byte
//   - data []byte
func (_e *MCMSEncoder_Expecter) TimelockDispatchToDeployer(functionNameBytes interface{}, data interface{}) *MCMSEncoder_TimelockDispatchToDeployer_Call {
	return &MCMSEncoder_TimelockDispatchToDeployer_Call{Call: _e.mock.On("TimelockDispatchToDeployer", functionNameBytes, data)}
}

func (_c *MCMSEncoder_TimelockDispatchToDeployer_Call) Run(run func(functionNameBytes []byte, data []byte)) *MCMSEncoder_TimelockDispatchToDeployer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockDispatchToDeployer_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockDispatchToDeployer_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockDispatchToDeployer_Call) RunAndReturn(run func([]byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockDispatchToDeployer_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockDispatchToRegistry provides a mock function with given fields: functionNameBytes, data
func (_m *MCMSEncoder) TimelockDispatchToRegistry(functionNameBytes []byte, data []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(functionNameBytes, data)

	if len(ret) == 0 {
		panic("no return value specified for TimelockDispatchToRegistry")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(functionNameBytes, data)
	}
	if rf, ok := ret.Get(0).(func([]byte, []byte) bind.ModuleInformation); ok {
		r0 = rf(functionNameBytes, data)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]byte, []byte) string); ok {
		r1 = rf(functionNameBytes, data)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]byte, []byte) []aptos.TypeTag); ok {
		r2 = rf(functionNameBytes, data)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]byte, []byte) [][]byte); ok {
		r3 = rf(functionNameBytes, data)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]byte, []byte) error); ok {
		r4 = rf(functionNameBytes, data)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockDispatchToRegistry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockDispatchToRegistry'
type MCMSEncoder_TimelockDispatchToRegistry_Call struct {
	*mock.Call
}

// TimelockDispatchToRegistry is a helper method to define mock.On call
//   - functionNameBytes []byte
//   - data []byte
func (_e *MCMSEncoder_Expecter) TimelockDispatchToRegistry(functionNameBytes interface{}, data interface{}) *MCMSEncoder_TimelockDispatchToRegistry_Call {
	return &MCMSEncoder_TimelockDispatchToRegistry_Call{Call: _e.mock.On("TimelockDispatchToRegistry", functionNameBytes, data)}
}

func (_c *MCMSEncoder_TimelockDispatchToRegistry_Call) Run(run func(functionNameBytes []byte, data []byte)) *MCMSEncoder_TimelockDispatchToRegistry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockDispatchToRegistry_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockDispatchToRegistry_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockDispatchToRegistry_Call) RunAndReturn(run func([]byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockDispatchToRegistry_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockDispatchToSelf provides a mock function with given fields: functionName, data
func (_m *MCMSEncoder) TimelockDispatchToSelf(functionName string, data []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(functionName, data)

	if len(ret) == 0 {
		panic("no return value specified for TimelockDispatchToSelf")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(string, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(functionName, data)
	}
	if rf, ok := ret.Get(0).(func(string, []byte) bind.ModuleInformation); ok {
		r0 = rf(functionName, data)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(string, []byte) string); ok {
		r1 = rf(functionName, data)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(string, []byte) []aptos.TypeTag); ok {
		r2 = rf(functionName, data)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(string, []byte) [][]byte); ok {
		r3 = rf(functionName, data)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(string, []byte) error); ok {
		r4 = rf(functionName, data)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockDispatchToSelf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockDispatchToSelf'
type MCMSEncoder_TimelockDispatchToSelf_Call struct {
	*mock.Call
}

// TimelockDispatchToSelf is a helper method to define mock.On call
//   - functionName string
//   - data []byte
func (_e *MCMSEncoder_Expecter) TimelockDispatchToSelf(functionName interface{}, data interface{}) *MCMSEncoder_TimelockDispatchToSelf_Call {
	return &MCMSEncoder_TimelockDispatchToSelf_Call{Call: _e.mock.On("TimelockDispatchToSelf", functionName, data)}
}

func (_c *MCMSEncoder_TimelockDispatchToSelf_Call) Run(run func(functionName string, data []byte)) *MCMSEncoder_TimelockDispatchToSelf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockDispatchToSelf_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockDispatchToSelf_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockDispatchToSelf_Call) RunAndReturn(run func(string, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockDispatchToSelf_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockExecuteBatch provides a mock function with given fields: targets, moduleNames, functionNames, datas, predecessor, salt
func (_m *MCMSEncoder) TimelockExecuteBatch(targets []aptos.AccountAddress, moduleNames []string, functionNames []string, datas [][]byte, predecessor []byte, salt []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(targets, moduleNames, functionNames, datas, predecessor, salt)

	if len(ret) == 0 {
		panic("no return value specified for TimelockExecuteBatch")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]aptos.AccountAddress, []string, []string, [][]byte, []byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(targets, moduleNames, functionNames, datas, predecessor, salt)
	}
	if rf, ok := ret.Get(0).(func([]aptos.AccountAddress, []string, []string, [][]byte, []byte, []byte) bind.ModuleInformation); ok {
		r0 = rf(targets, moduleNames, functionNames, datas, predecessor, salt)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]aptos.AccountAddress, []string, []string, [][]byte, []byte, []byte) string); ok {
		r1 = rf(targets, moduleNames, functionNames, datas, predecessor, salt)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]aptos.AccountAddress, []string, []string, [][]byte, []byte, []byte) []aptos.TypeTag); ok {
		r2 = rf(targets, moduleNames, functionNames, datas, predecessor, salt)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]aptos.AccountAddress, []string, []string, [][]byte, []byte, []byte) [][]byte); ok {
		r3 = rf(targets, moduleNames, functionNames, datas, predecessor, salt)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]aptos.AccountAddress, []string, []string, [][]byte, []byte, []byte) error); ok {
		r4 = rf(targets, moduleNames, functionNames, datas, predecessor, salt)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockExecuteBatch'
type MCMSEncoder_TimelockExecuteBatch_Call struct {
	*mock.Call
}

// TimelockExecuteBatch is a helper method to define mock.On call
//   - targets []aptos.AccountAddress
//   - moduleNames []string
//   - functionNames []string
//   - datas [][]byte
//   - predecessor []byte
//   - salt []byte
func (_e *MCMSEncoder_Expecter) TimelockExecuteBatch(targets interface{}, moduleNames interface{}, functionNames interface{}, datas interface{}, predecessor interface{}, salt interface{}) *MCMSEncoder_TimelockExecuteBatch_Call {
	return &MCMSEncoder_TimelockExecuteBatch_Call{Call: _e.mock.On("TimelockExecuteBatch", targets, moduleNames, functionNames, datas, predecessor, salt)}
}

func (_c *MCMSEncoder_TimelockExecuteBatch_Call) Run(run func(targets []aptos.AccountAddress, moduleNames []string, functionNames []string, datas [][]byte, predecessor []byte, salt []byte)) *MCMSEncoder_TimelockExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]aptos.AccountAddress), args[1].([]string), args[2].([]string), args[3].([][]byte), args[4].([]byte), args[5].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockExecuteBatch_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockExecuteBatch_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockExecuteBatch_Call) RunAndReturn(run func([]aptos.AccountAddress, []string, []string, [][]byte, []byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunction provides a mock function with given fields: index
func (_m *MCMSEncoder) TimelockGetBlockedFunction(index uint64) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunction")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(uint64) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(index)
	}
	if rf, ok := ret.Get(0).(func(uint64) bind.ModuleInformation); ok {
		r0 = rf(index)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(uint64) string); ok {
		r1 = rf(index)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(uint64) []aptos.TypeTag); ok {
		r2 = rf(index)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(uint64) [][]byte); ok {
		r3 = rf(index)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(uint64) error); ok {
		r4 = rf(index)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockGetBlockedFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunction'
type MCMSEncoder_TimelockGetBlockedFunction_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunction is a helper method to define mock.On call
//   - index uint64
func (_e *MCMSEncoder_Expecter) TimelockGetBlockedFunction(index interface{}) *MCMSEncoder_TimelockGetBlockedFunction_Call {
	return &MCMSEncoder_TimelockGetBlockedFunction_Call{Call: _e.mock.On("TimelockGetBlockedFunction", index)}
}

func (_c *MCMSEncoder_TimelockGetBlockedFunction_Call) Run(run func(index uint64)) *MCMSEncoder_TimelockGetBlockedFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockGetBlockedFunction_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockGetBlockedFunction_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockGetBlockedFunction_Call) RunAndReturn(run func(uint64) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockGetBlockedFunction_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunctions provides a mock function with no fields
func (_m *MCMSEncoder) TimelockGetBlockedFunctions() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunctions")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bind.ModuleInformation); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func() []aptos.TypeTag); ok {
		r2 = rf()
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func() [][]byte); ok {
		r3 = rf()
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func() error); ok {
		r4 = rf()
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockGetBlockedFunctions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunctions'
type MCMSEncoder_TimelockGetBlockedFunctions_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunctions is a helper method to define mock.On call
func (_e *MCMSEncoder_Expecter) TimelockGetBlockedFunctions() *MCMSEncoder_TimelockGetBlockedFunctions_Call {
	return &MCMSEncoder_TimelockGetBlockedFunctions_Call{Call: _e.mock.On("TimelockGetBlockedFunctions")}
}

func (_c *MCMSEncoder_TimelockGetBlockedFunctions_Call) Run(run func()) *MCMSEncoder_TimelockGetBlockedFunctions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MCMSEncoder_TimelockGetBlockedFunctions_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockGetBlockedFunctions_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockGetBlockedFunctions_Call) RunAndReturn(run func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockGetBlockedFunctions_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunctionsCount provides a mock function with no fields
func (_m *MCMSEncoder) TimelockGetBlockedFunctionsCount() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunctionsCount")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bind.ModuleInformation); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func() []aptos.TypeTag); ok {
		r2 = rf()
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func() [][]byte); ok {
		r3 = rf()
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func() error); ok {
		r4 = rf()
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockGetBlockedFunctionsCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunctionsCount'
type MCMSEncoder_TimelockGetBlockedFunctionsCount_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunctionsCount is a helper method to define mock.On call
func (_e *MCMSEncoder_Expecter) TimelockGetBlockedFunctionsCount() *MCMSEncoder_TimelockGetBlockedFunctionsCount_Call {
	return &MCMSEncoder_TimelockGetBlockedFunctionsCount_Call{Call: _e.mock.On("TimelockGetBlockedFunctionsCount")}
}

func (_c *MCMSEncoder_TimelockGetBlockedFunctionsCount_Call) Run(run func()) *MCMSEncoder_TimelockGetBlockedFunctionsCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MCMSEncoder_TimelockGetBlockedFunctionsCount_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockGetBlockedFunctionsCount_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockGetBlockedFunctionsCount_Call) RunAndReturn(run func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockGetBlockedFunctionsCount_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetTimestamp provides a mock function with given fields: id
func (_m *MCMSEncoder) TimelockGetTimestamp(id []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetTimestamp")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func([]byte) bind.ModuleInformation); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]byte) string); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]byte) []aptos.TypeTag); ok {
		r2 = rf(id)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]byte) [][]byte); ok {
		r3 = rf(id)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]byte) error); ok {
		r4 = rf(id)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockGetTimestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetTimestamp'
type MCMSEncoder_TimelockGetTimestamp_Call struct {
	*mock.Call
}

// TimelockGetTimestamp is a helper method to define mock.On call
//   - id []byte
func (_e *MCMSEncoder_Expecter) TimelockGetTimestamp(id interface{}) *MCMSEncoder_TimelockGetTimestamp_Call {
	return &MCMSEncoder_TimelockGetTimestamp_Call{Call: _e.mock.On("TimelockGetTimestamp", id)}
}

func (_c *MCMSEncoder_TimelockGetTimestamp_Call) Run(run func(id []byte)) *MCMSEncoder_TimelockGetTimestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockGetTimestamp_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockGetTimestamp_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockGetTimestamp_Call) RunAndReturn(run func([]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockGetTimestamp_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperation provides a mock function with given fields: id
func (_m *MCMSEncoder) TimelockIsOperation(id []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperation")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func([]byte) bind.ModuleInformation); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]byte) string); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]byte) []aptos.TypeTag); ok {
		r2 = rf(id)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]byte) [][]byte); ok {
		r3 = rf(id)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]byte) error); ok {
		r4 = rf(id)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockIsOperation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperation'
type MCMSEncoder_TimelockIsOperation_Call struct {
	*mock.Call
}

// TimelockIsOperation is a helper method to define mock.On call
//   - id []byte
func (_e *MCMSEncoder_Expecter) TimelockIsOperation(id interface{}) *MCMSEncoder_TimelockIsOperation_Call {
	return &MCMSEncoder_TimelockIsOperation_Call{Call: _e.mock.On("TimelockIsOperation", id)}
}

func (_c *MCMSEncoder_TimelockIsOperation_Call) Run(run func(id []byte)) *MCMSEncoder_TimelockIsOperation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockIsOperation_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockIsOperation_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockIsOperation_Call) RunAndReturn(run func([]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockIsOperation_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationDone provides a mock function with given fields: id
func (_m *MCMSEncoder) TimelockIsOperationDone(id []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationDone")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func([]byte) bind.ModuleInformation); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]byte) string); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]byte) []aptos.TypeTag); ok {
		r2 = rf(id)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]byte) [][]byte); ok {
		r3 = rf(id)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]byte) error); ok {
		r4 = rf(id)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockIsOperationDone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationDone'
type MCMSEncoder_TimelockIsOperationDone_Call struct {
	*mock.Call
}

// TimelockIsOperationDone is a helper method to define mock.On call
//   - id []byte
func (_e *MCMSEncoder_Expecter) TimelockIsOperationDone(id interface{}) *MCMSEncoder_TimelockIsOperationDone_Call {
	return &MCMSEncoder_TimelockIsOperationDone_Call{Call: _e.mock.On("TimelockIsOperationDone", id)}
}

func (_c *MCMSEncoder_TimelockIsOperationDone_Call) Run(run func(id []byte)) *MCMSEncoder_TimelockIsOperationDone_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockIsOperationDone_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockIsOperationDone_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockIsOperationDone_Call) RunAndReturn(run func([]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockIsOperationDone_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationPending provides a mock function with given fields: id
func (_m *MCMSEncoder) TimelockIsOperationPending(id []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationPending")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func([]byte) bind.ModuleInformation); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]byte) string); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]byte) []aptos.TypeTag); ok {
		r2 = rf(id)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]byte) [][]byte); ok {
		r3 = rf(id)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]byte) error); ok {
		r4 = rf(id)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockIsOperationPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationPending'
type MCMSEncoder_TimelockIsOperationPending_Call struct {
	*mock.Call
}

// TimelockIsOperationPending is a helper method to define mock.On call
//   - id []byte
func (_e *MCMSEncoder_Expecter) TimelockIsOperationPending(id interface{}) *MCMSEncoder_TimelockIsOperationPending_Call {
	return &MCMSEncoder_TimelockIsOperationPending_Call{Call: _e.mock.On("TimelockIsOperationPending", id)}
}

func (_c *MCMSEncoder_TimelockIsOperationPending_Call) Run(run func(id []byte)) *MCMSEncoder_TimelockIsOperationPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockIsOperationPending_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockIsOperationPending_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockIsOperationPending_Call) RunAndReturn(run func([]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockIsOperationPending_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationReady provides a mock function with given fields: id
func (_m *MCMSEncoder) TimelockIsOperationReady(id []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationReady")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func([]byte) bind.ModuleInformation); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]byte) string); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]byte) []aptos.TypeTag); ok {
		r2 = rf(id)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]byte) [][]byte); ok {
		r3 = rf(id)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]byte) error); ok {
		r4 = rf(id)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockIsOperationReady_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationReady'
type MCMSEncoder_TimelockIsOperationReady_Call struct {
	*mock.Call
}

// TimelockIsOperationReady is a helper method to define mock.On call
//   - id []byte
func (_e *MCMSEncoder_Expecter) TimelockIsOperationReady(id interface{}) *MCMSEncoder_TimelockIsOperationReady_Call {
	return &MCMSEncoder_TimelockIsOperationReady_Call{Call: _e.mock.On("TimelockIsOperationReady", id)}
}

func (_c *MCMSEncoder_TimelockIsOperationReady_Call) Run(run func(id []byte)) *MCMSEncoder_TimelockIsOperationReady_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockIsOperationReady_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockIsOperationReady_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockIsOperationReady_Call) RunAndReturn(run func([]byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockIsOperationReady_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockMinDelay provides a mock function with no fields
func (_m *MCMSEncoder) TimelockMinDelay() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TimelockMinDelay")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bind.ModuleInformation); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func() []aptos.TypeTag); ok {
		r2 = rf()
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func() [][]byte); ok {
		r3 = rf()
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func() error); ok {
		r4 = rf()
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockMinDelay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockMinDelay'
type MCMSEncoder_TimelockMinDelay_Call struct {
	*mock.Call
}

// TimelockMinDelay is a helper method to define mock.On call
func (_e *MCMSEncoder_Expecter) TimelockMinDelay() *MCMSEncoder_TimelockMinDelay_Call {
	return &MCMSEncoder_TimelockMinDelay_Call{Call: _e.mock.On("TimelockMinDelay")}
}

func (_c *MCMSEncoder_TimelockMinDelay_Call) Run(run func()) *MCMSEncoder_TimelockMinDelay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MCMSEncoder_TimelockMinDelay_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockMinDelay_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockMinDelay_Call) RunAndReturn(run func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockMinDelay_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockRole provides a mock function with no fields
func (_m *MCMSEncoder) TimelockRole() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TimelockRole")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bind.ModuleInformation); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func() []aptos.TypeTag); ok {
		r2 = rf()
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func() [][]byte); ok {
		r3 = rf()
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func() error); ok {
		r4 = rf()
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockRole'
type MCMSEncoder_TimelockRole_Call struct {
	*mock.Call
}

// TimelockRole is a helper method to define mock.On call
func (_e *MCMSEncoder_Expecter) TimelockRole() *MCMSEncoder_TimelockRole_Call {
	return &MCMSEncoder_TimelockRole_Call{Call: _e.mock.On("TimelockRole")}
}

func (_c *MCMSEncoder_TimelockRole_Call) Run(run func()) *MCMSEncoder_TimelockRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MCMSEncoder_TimelockRole_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockRole_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockRole_Call) RunAndReturn(run func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockRole_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockScheduleBatch provides a mock function with given fields: targets, moduleNames, functionNames, datas, predecessor, salt, delay
func (_m *MCMSEncoder) TimelockScheduleBatch(targets []aptos.AccountAddress, moduleNames []string, functionNames []string, datas [][]byte, predecessor []byte, salt []byte, delay uint64) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(targets, moduleNames, functionNames, datas, predecessor, salt, delay)

	if len(ret) == 0 {
		panic("no return value specified for TimelockScheduleBatch")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([]aptos.AccountAddress, []string, []string, [][]byte, []byte, []byte, uint64) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(targets, moduleNames, functionNames, datas, predecessor, salt, delay)
	}
	if rf, ok := ret.Get(0).(func([]aptos.AccountAddress, []string, []string, [][]byte, []byte, []byte, uint64) bind.ModuleInformation); ok {
		r0 = rf(targets, moduleNames, functionNames, datas, predecessor, salt, delay)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([]aptos.AccountAddress, []string, []string, [][]byte, []byte, []byte, uint64) string); ok {
		r1 = rf(targets, moduleNames, functionNames, datas, predecessor, salt, delay)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([]aptos.AccountAddress, []string, []string, [][]byte, []byte, []byte, uint64) []aptos.TypeTag); ok {
		r2 = rf(targets, moduleNames, functionNames, datas, predecessor, salt, delay)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([]aptos.AccountAddress, []string, []string, [][]byte, []byte, []byte, uint64) [][]byte); ok {
		r3 = rf(targets, moduleNames, functionNames, datas, predecessor, salt, delay)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([]aptos.AccountAddress, []string, []string, [][]byte, []byte, []byte, uint64) error); ok {
		r4 = rf(targets, moduleNames, functionNames, datas, predecessor, salt, delay)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockScheduleBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockScheduleBatch'
type MCMSEncoder_TimelockScheduleBatch_Call struct {
	*mock.Call
}

// TimelockScheduleBatch is a helper method to define mock.On call
//   - targets []aptos.AccountAddress
//   - moduleNames []string
//   - functionNames []string
//   - datas [][]byte
//   - predecessor []byte
//   - salt []byte
//   - delay uint64
func (_e *MCMSEncoder_Expecter) TimelockScheduleBatch(targets interface{}, moduleNames interface{}, functionNames interface{}, datas interface{}, predecessor interface{}, salt interface{}, delay interface{}) *MCMSEncoder_TimelockScheduleBatch_Call {
	return &MCMSEncoder_TimelockScheduleBatch_Call{Call: _e.mock.On("TimelockScheduleBatch", targets, moduleNames, functionNames, datas, predecessor, salt, delay)}
}

func (_c *MCMSEncoder_TimelockScheduleBatch_Call) Run(run func(targets []aptos.AccountAddress, moduleNames []string, functionNames []string, datas [][]byte, predecessor []byte, salt []byte, delay uint64)) *MCMSEncoder_TimelockScheduleBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]aptos.AccountAddress), args[1].([]string), args[2].([]string), args[3].([][]byte), args[4].([]byte), args[5].([]byte), args[6].(uint64))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockScheduleBatch_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockScheduleBatch_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockScheduleBatch_Call) RunAndReturn(run func([]aptos.AccountAddress, []string, []string, [][]byte, []byte, []byte, uint64) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockScheduleBatch_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockUnblockFunction provides a mock function with given fields: target, moduleName, functionName
func (_m *MCMSEncoder) TimelockUnblockFunction(target aptos.AccountAddress, moduleName string, functionName string) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(target, moduleName, functionName)

	if len(ret) == 0 {
		panic("no return value specified for TimelockUnblockFunction")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, string) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(target, moduleName, functionName)
	}
	if rf, ok := ret.Get(0).(func(aptos.AccountAddress, string, string) bind.ModuleInformation); ok {
		r0 = rf(target, moduleName, functionName)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(aptos.AccountAddress, string, string) string); ok {
		r1 = rf(target, moduleName, functionName)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(aptos.AccountAddress, string, string) []aptos.TypeTag); ok {
		r2 = rf(target, moduleName, functionName)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(aptos.AccountAddress, string, string) [][]byte); ok {
		r3 = rf(target, moduleName, functionName)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(aptos.AccountAddress, string, string) error); ok {
		r4 = rf(target, moduleName, functionName)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockUnblockFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockUnblockFunction'
type MCMSEncoder_TimelockUnblockFunction_Call struct {
	*mock.Call
}

// TimelockUnblockFunction is a helper method to define mock.On call
//   - target aptos.AccountAddress
//   - moduleName string
//   - functionName string
func (_e *MCMSEncoder_Expecter) TimelockUnblockFunction(target interface{}, moduleName interface{}, functionName interface{}) *MCMSEncoder_TimelockUnblockFunction_Call {
	return &MCMSEncoder_TimelockUnblockFunction_Call{Call: _e.mock.On("TimelockUnblockFunction", target, moduleName, functionName)}
}

func (_c *MCMSEncoder_TimelockUnblockFunction_Call) Run(run func(target aptos.AccountAddress, moduleName string, functionName string)) *MCMSEncoder_TimelockUnblockFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(aptos.AccountAddress), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockUnblockFunction_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockUnblockFunction_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockUnblockFunction_Call) RunAndReturn(run func(aptos.AccountAddress, string, string) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockUnblockFunction_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockUpdateMinDelay provides a mock function with given fields: newMinDelay
func (_m *MCMSEncoder) TimelockUpdateMinDelay(newMinDelay uint64) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(newMinDelay)

	if len(ret) == 0 {
		panic("no return value specified for TimelockUpdateMinDelay")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func(uint64) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(newMinDelay)
	}
	if rf, ok := ret.Get(0).(func(uint64) bind.ModuleInformation); ok {
		r0 = rf(newMinDelay)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func(uint64) string); ok {
		r1 = rf(newMinDelay)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(uint64) []aptos.TypeTag); ok {
		r2 = rf(newMinDelay)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func(uint64) [][]byte); ok {
		r3 = rf(newMinDelay)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func(uint64) error); ok {
		r4 = rf(newMinDelay)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_TimelockUpdateMinDelay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockUpdateMinDelay'
type MCMSEncoder_TimelockUpdateMinDelay_Call struct {
	*mock.Call
}

// TimelockUpdateMinDelay is a helper method to define mock.On call
//   - newMinDelay uint64
func (_e *MCMSEncoder_Expecter) TimelockUpdateMinDelay(newMinDelay interface{}) *MCMSEncoder_TimelockUpdateMinDelay_Call {
	return &MCMSEncoder_TimelockUpdateMinDelay_Call{Call: _e.mock.On("TimelockUpdateMinDelay", newMinDelay)}
}

func (_c *MCMSEncoder_TimelockUpdateMinDelay_Call) Run(run func(newMinDelay uint64)) *MCMSEncoder_TimelockUpdateMinDelay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *MCMSEncoder_TimelockUpdateMinDelay_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_TimelockUpdateMinDelay_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_TimelockUpdateMinDelay_Call) RunAndReturn(run func(uint64) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_TimelockUpdateMinDelay_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyMerkleProof provides a mock function with given fields: proof, root, leaf
func (_m *MCMSEncoder) VerifyMerkleProof(proof [][]byte, root []byte, leaf []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called(proof, root, leaf)

	if len(ret) == 0 {
		panic("no return value specified for VerifyMerkleProof")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func([][]byte, []byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf(proof, root, leaf)
	}
	if rf, ok := ret.Get(0).(func([][]byte, []byte, []byte) bind.ModuleInformation); ok {
		r0 = rf(proof, root, leaf)
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func([][]byte, []byte, []byte) string); ok {
		r1 = rf(proof, root, leaf)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func([][]byte, []byte, []byte) []aptos.TypeTag); ok {
		r2 = rf(proof, root, leaf)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func([][]byte, []byte, []byte) [][]byte); ok {
		r3 = rf(proof, root, leaf)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func([][]byte, []byte, []byte) error); ok {
		r4 = rf(proof, root, leaf)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_VerifyMerkleProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyMerkleProof'
type MCMSEncoder_VerifyMerkleProof_Call struct {
	*mock.Call
}

// VerifyMerkleProof is a helper method to define mock.On call
//   - proof [][]byte
//   - root []byte
//   - leaf []byte
func (_e *MCMSEncoder_Expecter) VerifyMerkleProof(proof interface{}, root interface{}, leaf interface{}) *MCMSEncoder_VerifyMerkleProof_Call {
	return &MCMSEncoder_VerifyMerkleProof_Call{Call: _e.mock.On("VerifyMerkleProof", proof, root, leaf)}
}

func (_c *MCMSEncoder_VerifyMerkleProof_Call) Run(run func(proof [][]byte, root []byte, leaf []byte)) *MCMSEncoder_VerifyMerkleProof_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]byte), args[1].([]byte), args[2].([]byte))
	})
	return _c
}

func (_c *MCMSEncoder_VerifyMerkleProof_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_VerifyMerkleProof_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_VerifyMerkleProof_Call) RunAndReturn(run func([][]byte, []byte, []byte) (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_VerifyMerkleProof_Call {
	_c.Call.Return(run)
	return _c
}

// ZeroHash provides a mock function with no fields
func (_m *MCMSEncoder) ZeroHash() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ZeroHash")
	}

	var r0 bind.ModuleInformation
	var r1 string
	var r2 []aptos.TypeTag
	var r3 [][]byte
	var r4 error
	if rf, ok := ret.Get(0).(func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bind.ModuleInformation); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bind.ModuleInformation)
	}

	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func() []aptos.TypeTag); ok {
		r2 = rf()
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]aptos.TypeTag)
		}
	}

	if rf, ok := ret.Get(3).(func() [][]byte); ok {
		r3 = rf()
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).([][]byte)
		}
	}

	if rf, ok := ret.Get(4).(func() error); ok {
		r4 = rf()
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// MCMSEncoder_ZeroHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZeroHash'
type MCMSEncoder_ZeroHash_Call struct {
	*mock.Call
}

// ZeroHash is a helper method to define mock.On call
func (_e *MCMSEncoder_Expecter) ZeroHash() *MCMSEncoder_ZeroHash_Call {
	return &MCMSEncoder_ZeroHash_Call{Call: _e.mock.On("ZeroHash")}
}

func (_c *MCMSEncoder_ZeroHash_Call) Run(run func()) *MCMSEncoder_ZeroHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MCMSEncoder_ZeroHash_Call) Return(_a0 bind.ModuleInformation, _a1 string, _a2 []aptos.TypeTag, _a3 [][]byte, _a4 error) *MCMSEncoder_ZeroHash_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3, _a4)
	return _c
}

func (_c *MCMSEncoder_ZeroHash_Call) RunAndReturn(run func() (bind.ModuleInformation, string, []aptos.TypeTag, [][]byte, error)) *MCMSEncoder_ZeroHash_Call {
	_c.Call.Return(run)
	return _c
}

// NewMCMSEncoder creates a new instance of MCMSEncoder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMCMSEncoder(t interface {
	mock.TestingT
	Cleanup(func())
}) *MCMSEncoder {
	mock := &MCMSEncoder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Code generated by mockery v2.53.5. DO NOT EDIT.

package mock_ton

import (
	address "github.com/xssnick/tonutils-go/address"
	cell "github.com/xssnick/tonutils-go/tvm/cell"

	context "context"

	liteclient "github.com/xssnick/tonutils-go/liteclient"

	mock "github.com/stretchr/testify/mock"

	time "time"

	tlb "github.com/xssnick/tonutils-go/tlb"

	ton "github.com/xssnick/tonutils-go/ton"
)

// APIClientWrapped is an autogenerated mock type for the APIClientWrapped type
type APIClientWrapped struct {
	mock.Mock
}

type APIClientWrapped_Expecter struct {
	mock *mock.Mock
}

func (_m *APIClientWrapped) EXPECT() *APIClientWrapped_Expecter {
	return &APIClientWrapped_Expecter{mock: &_m.Mock}
}

// Client provides a mock function with no fields
func (_m *APIClientWrapped) Client() ton.LiteClient {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Client")
	}

	var r0 ton.LiteClient
	if rf, ok := ret.Get(0).(func() ton.LiteClient); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ton.LiteClient)
		}
	}

	return r0
}

// APIClientWrapped_Client_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Client'
type APIClientWrapped_Client_Call struct {
	*mock.Call
}

// Client is a helper method to define mock.On call
func (_e *APIClientWrapped_Expecter) Client() *APIClientWrapped_Client_Call {
	return &APIClientWrapped_Client_Call{Call: _e.mock.On("Client")}
}

func (_c *APIClientWrapped_Client_Call) Run(run func()) *APIClientWrapped_Client_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *APIClientWrapped_Client_Call) Return(_a0 ton.LiteClient) *APIClientWrapped_Client_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *APIClientWrapped_Client_Call) RunAndReturn(run func() ton.LiteClient) *APIClientWrapped_Client_Call {
	_c.Call.Return(run)
	return _c
}

// CurrentMasterchainInfo provides a mock function with given fields: ctx
func (_m *APIClientWrapped) CurrentMasterchainInfo(ctx context.Context) (*tlb.BlockInfo, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CurrentMasterchainInfo")
	}

	var r0 *tlb.BlockInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*tlb.BlockInfo, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *tlb.BlockInfo); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tlb.BlockInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_CurrentMasterchainInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurrentMasterchainInfo'
type APIClientWrapped_CurrentMasterchainInfo_Call struct {
	*mock.Call
}

// CurrentMasterchainInfo is a helper method to define mock.On call
//   - ctx context.Context
func (_e *APIClientWrapped_Expecter) CurrentMasterchainInfo(ctx interface{}) *APIClientWrapped_CurrentMasterchainInfo_Call {
	return &APIClientWrapped_CurrentMasterchainInfo_Call{Call: _e.mock.On("CurrentMasterchainInfo", ctx)}
}

func (_c *APIClientWrapped_CurrentMasterchainInfo_Call) Run(run func(ctx context.Context)) *APIClientWrapped_CurrentMasterchainInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *APIClientWrapped_CurrentMasterchainInfo_Call) Return(_a0 *tlb.BlockInfo, err error) *APIClientWrapped_CurrentMasterchainInfo_Call {
	_c.Call.Return(_a0, err)
	return _c
}

func (_c *APIClientWrapped_CurrentMasterchainInfo_Call) RunAndReturn(run func(context.Context) (*tlb.BlockInfo, error)) *APIClientWrapped_CurrentMasterchainInfo_Call {
	_c.Call.Return(run)
	return _c
}

// FindLastTransactionByInMsgHash provides a mock function with given fields: ctx, addr, msgHash, maxTxNumToScan
func (_m *APIClientWrapped) FindLastTransactionByInMsgHash(ctx context.Context, addr *address.Address, msgHash []byte, maxTxNumToScan ...int) (*tlb.Transaction, error) {
	_va := make([]interface{}, len(maxTxNumToScan))
	for _i := range maxTxNumToScan {
		_va[_i] = maxTxNumToScan[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, addr, msgHash)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindLastTransactionByInMsgHash")
	}

	var r0 *tlb.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, []byte, ...int) (*tlb.Transaction, error)); ok {
		return rf(ctx, addr, msgHash, maxTxNumToScan...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, []byte, ...int) *tlb.Transaction); ok {
		r0 = rf(ctx, addr, msgHash, maxTxNumToScan...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tlb.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *address.Address, []byte, ...int) error); ok {
		r1 = rf(ctx, addr, msgHash, maxTxNumToScan...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_FindLastTransactionByInMsgHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindLastTransactionByInMsgHash'
type APIClientWrapped_FindLastTransactionByInMsgHash_Call struct {
	*mock.Call
}

// FindLastTransactionByInMsgHash is a helper method to define mock.On call
//   - ctx context.Context
//   - addr *address.Address
//   - msgHash []byte
//   - maxTxNumToScan ...int
func (_e *APIClientWrapped_Expecter) FindLastTransactionByInMsgHash(ctx interface{}, addr interface{}, msgHash interface{}, maxTxNumToScan ...interface{}) *APIClientWrapped_FindLastTransactionByInMsgHash_Call {
	return &APIClientWrapped_FindLastTransactionByInMsgHash_Call{Call: _e.mock.On("FindLastTransactionByInMsgHash",
		append([]interface{}{ctx, addr, msgHash}, maxTxNumToScan...)...)}
}

func (_c *APIClientWrapped_FindLastTransactionByInMsgHash_Call) Run(run func(ctx context.Context, addr *address.Address, msgHash []byte, maxTxNumToScan ...int)) *APIClientWrapped_FindLastTransactionByInMsgHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(context.Context), args[1].(*address.Address), args[2].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *APIClientWrapped_FindLastTransactionByInMsgHash_Call) Return(_a0 *tlb.Transaction, _a1 error) *APIClientWrapped_FindLastTransactionByInMsgHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *APIClientWrapped_FindLastTransactionByInMsgHash_Call) RunAndReturn(run func(context.Context, *address.Address, []byte, ...int) (*tlb.Transaction, error)) *APIClientWrapped_FindLastTransactionByInMsgHash_Call {
	_c.Call.Return(run)
	return _c
}

// FindLastTransactionByOutMsgHash provides a mock function with given fields: ctx, addr, msgHash, maxTxNumToScan
func (_m *APIClientWrapped) FindLastTransactionByOutMsgHash(ctx context.Context, addr *address.Address, msgHash []byte, maxTxNumToScan ...int) (*tlb.Transaction, error) {
	_va := make([]interface{}, len(maxTxNumToScan))
	for _i := range maxTxNumToScan {
		_va[_i] = maxTxNumToScan[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, addr, msgHash)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindLastTransactionByOutMsgHash")
	}

	var r0 *tlb.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, []byte, ...int) (*tlb.Transaction, error)); ok {
		return rf(ctx, addr, msgHash, maxTxNumToScan...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, []byte, ...int) *tlb.Transaction); ok {
		r0 = rf(ctx, addr, msgHash, maxTxNumToScan...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tlb.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *address.Address, []byte, ...int) error); ok {
		r1 = rf(ctx, addr, msgHash, maxTxNumToScan...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_FindLastTransactionByOutMsgHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindLastTransactionByOutMsgHash'
type APIClientWrapped_FindLastTransactionByOutMsgHash_Call struct {
	*mock.Call
}

// FindLastTransactionByOutMsgHash is a helper method to define mock.On call
//   - ctx context.Context
//   - addr *address.Address
//   - msgHash []byte
//   - maxTxNumToScan ...int
func (_e *APIClientWrapped_Expecter) FindLastTransactionByOutMsgHash(ctx interface{}, addr interface{}, msgHash interface{}, maxTxNumToScan ...interface{}) *APIClientWrapped_FindLastTransactionByOutMsgHash_Call {
	return &APIClientWrapped_FindLastTransactionByOutMsgHash_Call{Call: _e.mock.On("FindLastTransactionByOutMsgHash",
		append([]interface{}{ctx, addr, msgHash}, maxTxNumToScan...)...)}
}

func (_c *APIClientWrapped_FindLastTransactionByOutMsgHash_Call) Run(run func(ctx context.Context, addr *address.Address, msgHash []byte, maxTxNumToScan ...int)) *APIClientWrapped_FindLastTransactionByOutMsgHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(context.Context), args[1].(*address.Address), args[2].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *APIClientWrapped_FindLastTransactionByOutMsgHash_Call) Return(_a0 *tlb.Transaction, _a1 error) *APIClientWrapped_FindLastTransactionByOutMsgHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *APIClientWrapped_FindLastTransactionByOutMsgHash_Call) RunAndReturn(run func(context.Context, *address.Address, []byte, ...int) (*tlb.Transaction, error)) *APIClientWrapped_FindLastTransactionByOutMsgHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccount provides a mock function with given fields: ctx, block, addr
func (_m *APIClientWrapped) GetAccount(ctx context.Context, block *tlb.BlockInfo, addr *address.Address) (*tlb.Account, error) {
	ret := _m.Called(ctx, block, addr)

	if len(ret) == 0 {
		panic("no return value specified for GetAccount")
	}

	var r0 *tlb.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo, *address.Address) (*tlb.Account, error)); ok {
		return rf(ctx, block, addr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo, *address.Address) *tlb.Account); ok {
		r0 = rf(ctx, block, addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tlb.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *tlb.BlockInfo, *address.Address) error); ok {
		r1 = rf(ctx, block, addr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_GetAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccount'
type APIClientWrapped_GetAccount_Call struct {
	*mock.Call
}

// GetAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - block *tlb.BlockInfo
//   - addr *address.Address
func (_e *APIClientWrapped_Expecter) GetAccount(ctx interface{}, block interface{}, addr interface{}) *APIClientWrapped_GetAccount_Call {
	return &APIClientWrapped_GetAccount_Call{Call: _e.mock.On("GetAccount", ctx, block, addr)}
}

func (_c *APIClientWrapped_GetAccount_Call) Run(run func(ctx context.Context, block *tlb.BlockInfo, addr *address.Address)) *APIClientWrapped_GetAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*tlb.BlockInfo), args[2].(*address.Address))
	})
	return _c
}

func (_c *APIClientWrapped_GetAccount_Call) Return(_a0 *tlb.Account, _a1 error) *APIClientWrapped_GetAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *APIClientWrapped_GetAccount_Call) RunAndReturn(run func(context.Context, *tlb.BlockInfo, *address.Address) (*tlb.Account, error)) *APIClientWrapped_GetAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockData provides a mock function with given fields: ctx, block
func (_m *APIClientWrapped) GetBlockData(ctx context.Context, block *tlb.BlockInfo) (*tlb.Block, error) {
	ret := _m.Called(ctx, block)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockData")
	}

	var r0 *tlb.Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo) (*tlb.Block, error)); ok {
		return rf(ctx, block)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo) *tlb.Block); ok {
		r0 = rf(ctx, block)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tlb.Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *tlb.BlockInfo) error); ok {
		r1 = rf(ctx, block)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_GetBlockData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockData'
type APIClientWrapped_GetBlockData_Call struct {
	*mock.Call
}

// GetBlockData is a helper method to define mock.On call
//   - ctx context.Context
//   - block *tlb.BlockInfo
func (_e *APIClientWrapped_Expecter) GetBlockData(ctx interface{}, block interface{}) *APIClientWrapped_GetBlockData_Call {
	return &APIClientWrapped_GetBlockData_Call{Call: _e.mock.On("GetBlockData", ctx, block)}
}

func (_c *APIClientWrapped_GetBlockData_Call) Run(run func(ctx context.Context, block *tlb.BlockInfo)) *APIClientWrapped_GetBlockData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*tlb.BlockInfo))
	})
	return _c
}

func (_c *APIClientWrapped_GetBlockData_Call) Return(_a0 *tlb.Block, _a1 error) *APIClientWrapped_GetBlockData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *APIClientWrapped_GetBlockData_Call) RunAndReturn(run func(context.Context, *tlb.BlockInfo) (*tlb.Block, error)) *APIClientWrapped_GetBlockData_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockProof provides a mock function with given fields: ctx, known, target
func (_m *APIClientWrapped) GetBlockProof(ctx context.Context, known *tlb.BlockInfo, target *tlb.BlockInfo) (*ton.PartialBlockProof, error) {
	ret := _m.Called(ctx, known, target)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockProof")
	}

	var r0 *ton.PartialBlockProof
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo, *tlb.BlockInfo) (*ton.PartialBlockProof, error)); ok {
		return rf(ctx, known, target)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo, *tlb.BlockInfo) *ton.PartialBlockProof); ok {
		r0 = rf(ctx, known, target)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ton.PartialBlockProof)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *tlb.BlockInfo, *tlb.BlockInfo) error); ok {
		r1 = rf(ctx, known, target)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_GetBlockProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockProof'
type APIClientWrapped_GetBlockProof_Call struct {
	*mock.Call
}

// GetBlockProof is a helper method to define mock.On call
//   - ctx context.Context
//   - known *tlb.BlockInfo
//   - target *tlb.BlockInfo
func (_e *APIClientWrapped_Expecter) GetBlockProof(ctx interface{}, known interface{}, target interface{}) *APIClientWrapped_GetBlockProof_Call {
	return &APIClientWrapped_GetBlockProof_Call{Call: _e.mock.On("GetBlockProof", ctx, known, target)}
}

func (_c *APIClientWrapped_GetBlockProof_Call) Run(run func(ctx context.Context, known *tlb.BlockInfo, target *tlb.BlockInfo)) *APIClientWrapped_GetBlockProof_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*tlb.BlockInfo), args[2].(*tlb.BlockInfo))
	})
	return _c
}

func (_c *APIClientWrapped_GetBlockProof_Call) Return(_a0 *ton.PartialBlockProof, _a1 error) *APIClientWrapped_GetBlockProof_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *APIClientWrapped_GetBlockProof_Call) RunAndReturn(run func(context.Context, *tlb.BlockInfo, *tlb.BlockInfo) (*ton.PartialBlockProof, error)) *APIClientWrapped_GetBlockProof_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockShardsInfo provides a mock function with given fields: ctx, master
func (_m *APIClientWrapped) GetBlockShardsInfo(ctx context.Context, master *tlb.BlockInfo) ([]*tlb.BlockInfo, error) {
	ret := _m.Called(ctx, master)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockShardsInfo")
	}

	var r0 []*tlb.BlockInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo) ([]*tlb.BlockInfo, error)); ok {
		return rf(ctx, master)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo) []*tlb.BlockInfo); ok {
		r0 = rf(ctx, master)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*tlb.BlockInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *tlb.BlockInfo) error); ok {
		r1 = rf(ctx, master)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_GetBlockShardsInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockShardsInfo'
type APIClientWrapped_GetBlockShardsInfo_Call struct {
	*mock.Call
}

// GetBlockShardsInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - master *tlb.BlockInfo
func (_e *APIClientWrapped_Expecter) GetBlockShardsInfo(ctx interface{}, master interface{}) *APIClientWrapped_GetBlockShardsInfo_Call {
	return &APIClientWrapped_GetBlockShardsInfo_Call{Call: _e.mock.On("GetBlockShardsInfo", ctx, master)}
}

func (_c *APIClientWrapped_GetBlockShardsInfo_Call) Run(run func(ctx context.Context, master *tlb.BlockInfo)) *APIClientWrapped_GetBlockShardsInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*tlb.BlockInfo))
	})
	return _c
}

func (_c *APIClientWrapped_GetBlockShardsInfo_Call) Return(_a0 []*tlb.BlockInfo, _a1 error) *APIClientWrapped_GetBlockShardsInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *APIClientWrapped_GetBlockShardsInfo_Call) RunAndReturn(run func(context.Context, *tlb.BlockInfo) ([]*tlb.BlockInfo, error)) *APIClientWrapped_GetBlockShardsInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockTransactionsV2 provides a mock function with given fields: ctx, block, count, after
func (_m *APIClientWrapped) GetBlockTransactionsV2(ctx context.Context, block *tlb.BlockInfo, count uint32, after ...*ton.TransactionID3) ([]ton.TransactionShortInfo, bool, error) {
	_va := make([]interface{}, len(after))
	for _i := range after {
		_va[_i] = after[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, block, count)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockTransactionsV2")
	}

	var r0 []ton.TransactionShortInfo
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo, uint32, ...*ton.TransactionID3) ([]ton.TransactionShortInfo, bool, error)); ok {
		return rf(ctx, block, count, after...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo, uint32, ...*ton.TransactionID3) []ton.TransactionShortInfo); ok {
		r0 = rf(ctx, block, count, after...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ton.TransactionShortInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *tlb.BlockInfo, uint32, ...*ton.TransactionID3) bool); ok {
		r1 = rf(ctx, block, count, after...)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *tlb.BlockInfo, uint32, ...*ton.TransactionID3) error); ok {
		r2 = rf(ctx, block, count, after...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// APIClientWrapped_GetBlockTransactionsV2_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockTransactionsV2'
type APIClientWrapped_GetBlockTransactionsV2_Call struct {
	*mock.Call
}

// GetBlockTransactionsV2 is a helper method to define mock.On call
//   - ctx context.Context
//   - block *tlb.BlockInfo
//   - count uint32
//   - after ...*ton.TransactionID3
func (_e *APIClientWrapped_Expecter) GetBlockTransactionsV2(ctx interface{}, block interface{}, count interface{}, after ...interface{}) *APIClientWrapped_GetBlockTransactionsV2_Call {
	return &APIClientWrapped_GetBlockTransactionsV2_Call{Call: _e.mock.On("GetBlockTransactionsV2",
		append([]interface{}{ctx, block, count}, after...)...)}
}

func (_c *APIClientWrapped_GetBlockTransactionsV2_Call) Run(run func(ctx context.Context, block *tlb.BlockInfo, count uint32, after ...*ton.TransactionID3)) *APIClientWrapped_GetBlockTransactionsV2_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*ton.TransactionID3, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(*ton.TransactionID3)
			}
		}
		run(args[0].(context.Context), args[1].(*tlb.BlockInfo), args[2].(uint32), variadicArgs...)
	})
	return _c
}

func (_c *APIClientWrapped_GetBlockTransactionsV2_Call) Return(_a0 []ton.TransactionShortInfo, _a1 bool, _a2 error) *APIClientWrapped_GetBlockTransactionsV2_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *APIClientWrapped_GetBlockTransactionsV2_Call) RunAndReturn(run func(context.Context, *tlb.BlockInfo, uint32, ...*ton.TransactionID3) ([]ton.TransactionShortInfo, bool, error)) *APIClientWrapped_GetBlockTransactionsV2_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockchainConfig provides a mock function with given fields: ctx, block, onlyParams
func (_m *APIClientWrapped) GetBlockchainConfig(ctx context.Context, block *tlb.BlockInfo, onlyParams ...int32) (*ton.BlockchainConfig, error) {
	_va := make([]interface{}, len(onlyParams))
	for _i := range onlyParams {
		_va[_i] = onlyParams[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, block)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockchainConfig")
	}

	var r0 *ton.BlockchainConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo, ...int32) (*ton.BlockchainConfig, error)); ok {
		return rf(ctx, block, onlyParams...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo, ...int32) *ton.BlockchainConfig); ok {
		r0 = rf(ctx, block, onlyParams...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ton.BlockchainConfig)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *tlb.BlockInfo, ...int32) error); ok {
		r1 = rf(ctx, block, onlyParams...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_GetBlockchainConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockchainConfig'
type APIClientWrapped_GetBlockchainConfig_Call struct {
	*mock.Call
}

// GetBlockchainConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - block *tlb.BlockInfo
//   - onlyParams ...int32
func (_e *APIClientWrapped_Expecter) GetBlockchainConfig(ctx interface{}, block interface{}, onlyParams ...interface{}) *APIClientWrapped_GetBlockchainConfig_Call {
	return &APIClientWrapped_GetBlockchainConfig_Call{Call: _e.mock.On("GetBlockchainConfig",
		append([]interface{}{ctx, block}, onlyParams...)...)}
}

func (_c *APIClientWrapped_GetBlockchainConfig_Call) Run(run func(ctx context.Context, block *tlb.BlockInfo, onlyParams ...int32)) *APIClientWrapped_GetBlockchainConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int32, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(int32)
			}
		}
		run(args[0].(context.Context), args[1].(*tlb.BlockInfo), variadicArgs...)
	})
	return _c
}

func (_c *APIClientWrapped_GetBlockchainConfig_Call) Return(_a0 *ton.BlockchainConfig, _a1 error) *APIClientWrapped_GetBlockchainConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *APIClientWrapped_GetBlockchainConfig_Call) RunAndReturn(run func(context.Context, *tlb.BlockInfo, ...int32) (*ton.BlockchainConfig, error)) *APIClientWrapped_GetBlockchainConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetLibraries provides a mock function with given fields: ctx, list
func (_m *APIClientWrapped) GetLibraries(ctx context.Context, list ...[]byte) ([]*cell.Cell, error) {
	_va := make([]interface{}, len(list))
	for _i := range list {
		_va[_i] = list[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLibraries")
	}

	var r0 []*cell.Cell
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...[]byte) ([]*cell.Cell, error)); ok {
		return rf(ctx, list...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...[]byte) []*cell.Cell); ok {
		r0 = rf(ctx, list...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*cell.Cell)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...[]byte) error); ok {
		r1 = rf(ctx, list...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_GetLibraries_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLibraries'
type APIClientWrapped_GetLibraries_Call struct {
	*mock.Call
}

// GetLibraries is a helper method to define mock.On call
//   - ctx context.Context
//   - list ...[]byte
func (_e *APIClientWrapped_Expecter) GetLibraries(ctx interface{}, list ...interface{}) *APIClientWrapped_GetLibraries_Call {
	return &APIClientWrapped_GetLibraries_Call{Call: _e.mock.On("GetLibraries",
		append([]interface{}{ctx}, list...)...)}
}

func (_c *APIClientWrapped_GetLibraries_Call) Run(run func(ctx context.Context, list ...[]byte)) *APIClientWrapped_GetLibraries_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([][]byte, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.([]byte)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *APIClientWrapped_GetLibraries_Call) Return(_a0 []*cell.Cell, _a1 error) *APIClientWrapped_GetLibraries_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *APIClientWrapped_GetLibraries_Call) RunAndReturn(run func(context.Context, ...[]byte) ([]*cell.Cell, error)) *APIClientWrapped_GetLibraries_Call {
	_c.Call.Return(run)
	return _c
}

// GetMasterchainInfo provides a mock function with given fields: ctx
func (_m *APIClientWrapped) GetMasterchainInfo(ctx context.Context) (*tlb.BlockInfo, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetMasterchainInfo")
	}

	var r0 *tlb.BlockInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*tlb.BlockInfo, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *tlb.BlockInfo); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tlb.BlockInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_GetMasterchainInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMasterchainInfo'
type APIClientWrapped_GetMasterchainInfo_Call struct {
	*mock.Call
}

// GetMasterchainInfo is a helper method to define mock.On call
//   - ctx context.Context
func (_e *APIClientWrapped_Expecter) GetMasterchainInfo(ctx interface{}) *APIClientWrapped_GetMasterchainInfo_Call {
	return &APIClientWrapped_GetMasterchainInfo_Call{Call: _e.mock.On("GetMasterchainInfo", ctx)}
}

func (_c *APIClientWrapped_GetMasterchainInfo_Call) Run(run func(ctx context.Context)) *APIClientWrapped_GetMasterchainInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *APIClientWrapped_GetMasterchainInfo_Call) Return(_a0 *tlb.BlockInfo, _a1 error) *APIClientWrapped_GetMasterchainInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *APIClientWrapped_GetMasterchainInfo_Call) RunAndReturn(run func(context.Context) (*tlb.BlockInfo, error)) *APIClientWrapped_GetMasterchainInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetTime provides a mock function with given fields: ctx
func (_m *APIClientWrapped) GetTime(ctx context.Context) (uint32, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetTime")
	}

	var r0 uint32
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (uint32, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) uint32); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_GetTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTime'
type APIClientWrapped_GetTime_Call struct {
	*mock.Call
}

// GetTime is a helper method to define mock.On call
//   - ctx context.Context
func (_e *APIClientWrapped_Expecter) GetTime(ctx interface{}) *APIClientWrapped_GetTime_Call {
	return &APIClientWrapped_GetTime_Call{Call: _e.mock.On("GetTime", ctx)}
}

func (_c *APIClientWrapped_GetTime_Call) Run(run func(ctx context.Context)) *APIClientWrapped_GetTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *APIClientWrapped_GetTime_Call) Return(_a0 uint32, _a1 error) *APIClientWrapped_GetTime_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *APIClientWrapped_GetTime_Call) RunAndReturn(run func(context.Context) (uint32, error)) *APIClientWrapped_GetTime_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransaction provides a mock function with given fields: ctx, block, addr, lt
func (_m *APIClientWrapped) GetTransaction(ctx context.Context, block *tlb.BlockInfo, addr *address.Address, lt uint64) (*tlb.Transaction, error) {
	ret := _m.Called(ctx, block, addr, lt)

	if len(ret) == 0 {
		panic("no return value specified for GetTransaction")
	}

	var r0 *tlb.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo, *address.Address, uint64) (*tlb.Transaction, error)); ok {
		return rf(ctx, block, addr, lt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo, *address.Address, uint64) *tlb.Transaction); ok {
		r0 = rf(ctx, block, addr, lt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tlb.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *tlb.BlockInfo, *address.Address, uint64) error); ok {
		r1 = rf(ctx, block, addr, lt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_GetTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransaction'
type APIClientWrapped_GetTransaction_Call struct {
	*mock.Call
}

// GetTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - block *tlb.BlockInfo
//   - addr *address.Address
//   - lt uint64
func (_e *APIClientWrapped_Expecter) GetTransaction(ctx interface{}, block interface{}, addr interface{}, lt interface{}) *APIClientWrapped_GetTransaction_Call {
	return &APIClientWrapped_GetTransaction_Call{Call: _e.mock.On("GetTransaction", ctx, block, addr, lt)}
}

func (_c *APIClientWrapped_GetTransaction_Call) Run(run func(ctx context.Context, block *tlb.BlockInfo, addr *address.Address, lt uint64)) *APIClientWrapped_GetTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*tlb.BlockInfo), args[2].(*address.Address), args[3].(uint64))
	})
	return _c
}

func (_c *APIClientWrapped_GetTransaction_Call) Return(_a0 *tlb.Transaction, _a1 error) *APIClientWrapped_GetTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *APIClientWrapped_GetTransaction_Call) RunAndReturn(run func(context.Context, *tlb.BlockInfo, *address.Address, uint64) (*tlb.Transaction, error)) *APIClientWrapped_GetTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// ListTransactions provides a mock function with given fields: ctx, addr, num, lt, txHash
func (_m *APIClientWrapped) ListTransactions(ctx context.Context, addr *address.Address, num uint32, lt uint64, txHash []byte) ([]*tlb.Transaction, error) {
	ret := _m.Called(ctx, addr, num, lt, txHash)

	if len(ret) == 0 {
		panic("no return value specified for ListTransactions")
	}

	var r0 []*tlb.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, uint32, uint64, []byte) ([]*tlb.Transaction, error)); ok {
		return rf(ctx, addr, num, lt, txHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, uint32, uint64, []byte) []*tlb.Transaction); ok {
		r0 = rf(ctx, addr, num, lt, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*tlb.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *address.Address, uint32, uint64, []byte) error); ok {
		r1 = rf(ctx, addr, num, lt, txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_ListTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTransactions'
type APIClientWrapped_ListTransactions_Call struct {
	*mock.Call
}

// ListTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - addr *address.Address
//   - num uint32
//   - lt uint64
//   - txHash []byte
func (_e *APIClientWrapped_Expecter) ListTransactions(ctx interface{}, addr interface{}, num interface{}, lt interface{}, txHash interface{}) *APIClientWrapped_ListTransactions_Call {
	return &APIClientWrapped_ListTransactions_Call{Call: _e.mock.On("ListTransactions", ctx, addr, num, lt, txHash)}
}

func (_c *APIClientWrapped_ListTransactions_Call) Run(run func(ctx context.Context, addr *address.Address, num uint32, lt uint64, txHash []byte)) *APIClientWrapped_ListTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*address.Address), args[2].(uint32), args[3].(uint64), args[4].([]byte))
	})
	return _c
}

func (_c *APIClientWrapped_ListTransactions_Call) Return(_a0 []*tlb.Transaction, _a1 error) *APIClientWrapped_ListTransactions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *APIClientWrapped_ListTransactions_Call) RunAndReturn(run func(context.Context, *address.Address, uint32, uint64, []byte) ([]*tlb.Transaction, error)) *APIClientWrapped_ListTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// LookupBlock provides a mock function with given fields: ctx, workchain, shard, seqno
func (_m *APIClientWrapped) LookupBlock(ctx context.Context, workchain int32, shard int64, seqno uint32) (*tlb.BlockInfo, error) {
	ret := _m.Called(ctx, workchain, shard, seqno)

	if len(ret) == 0 {
		panic("no return value specified for LookupBlock")
	}

	var r0 *tlb.BlockInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, int64, uint32) (*tlb.BlockInfo, error)); ok {
		return rf(ctx, workchain, shard, seqno)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, int64, uint32) *tlb.BlockInfo); ok {
		r0 = rf(ctx, workchain, shard, seqno)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tlb.BlockInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, int64, uint32) error); ok {
		r1 = rf(ctx, workchain, shard, seqno)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_LookupBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LookupBlock'
type APIClientWrapped_LookupBlock_Call struct {
	*mock.Call
}

// LookupBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - workchain int32
//   - shard int64
//   - seqno uint32
func (_e *APIClientWrapped_Expecter) LookupBlock(ctx interface{}, workchain interface{}, shard interface{}, seqno interface{}) *APIClientWrapped_LookupBlock_Call {
	return &APIClientWrapped_LookupBlock_Call{Call: _e.mock.On("LookupBlock", ctx, workchain, shard, seqno)}
}

func (_c *APIClientWrapped_LookupBlock_Call) Run(run func(ctx context.Context, workchain int32, shard int64, seqno uint32)) *APIClientWrapped_LookupBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(int64), args[3].(uint32))
	})
	return _c
}

func (_c *APIClientWrapped_LookupBlock_Call) Return(_a0 *tlb.BlockInfo, _a1 error) *APIClientWrapped_LookupBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *APIClientWrapped_LookupBlock_Call) RunAndReturn(run func(context.Context, int32, int64, uint32) (*tlb.BlockInfo, error)) *APIClientWrapped_LookupBlock_Call {
	_c.Call.Return(run)
	return _c
}

// RunGetMethod provides a mock function with given fields: ctx, blockInfo, addr, method, params
func (_m *APIClientWrapped) RunGetMethod(ctx context.Context, blockInfo *tlb.BlockInfo, addr *address.Address, method string, params ...interface{}) (*ton.ExecutionResult, error) {
	var _ca []interface{}
	_ca = append(_ca, ctx, blockInfo, addr, method)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RunGetMethod")
	}

	var r0 *ton.ExecutionResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo, *address.Address, string, ...interface{}) (*ton.ExecutionResult, error)); ok {
		return rf(ctx, blockInfo, addr, method, params...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo, *address.Address, string, ...interface{}) *ton.ExecutionResult); ok {
		r0 = rf(ctx, blockInfo, addr, method, params...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ton.ExecutionResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *tlb.BlockInfo, *address.Address, string, ...interface{}) error); ok {
		r1 = rf(ctx, blockInfo, addr, method, params...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// APIClientWrapped_RunGetMethod_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunGetMethod'
type APIClientWrapped_RunGetMethod_Call struct {
	*mock.Call
}

// RunGetMethod is a helper method to define mock.On call
//   - ctx context.Context
//   - blockInfo *tlb.BlockInfo
//   - addr *address.Address
//   - method string
//   - params ...interface{}
func (_e *APIClientWrapped_Expecter) RunGetMethod(ctx interface{}, blockInfo interface{}, addr interface{}, method interface{}, params ...interface{}) *APIClientWrapped_RunGetMethod_Call {
	return &APIClientWrapped_RunGetMethod_Call{Call: _e.mock.On("RunGetMethod",
		append([]interface{}{ctx, blockInfo, addr, method}, params...)...)}
}

func (_c *APIClientWrapped_RunGetMethod_Call) Run(run func(ctx context.Context, blockInfo *tlb.BlockInfo, addr *address.Address, method string, params ...interface{})) *APIClientWrapped_RunGetMethod_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(*tlb.BlockInfo), args[2].(*address.Address), args[3].(string), variadicArgs...)
	})
	return _c
}

func (_c *APIClientWrapped_RunGetMethod_Call) Return(_a0 *ton.ExecutionResult, _a1 error) *APIClientWrapped_RunGetMethod_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *APIClientWrapped_RunGetMethod_Call) RunAndReturn(run func(context.Context, *tlb.BlockInfo, *address.Address, string, ...interface{}) (*ton.ExecutionResult, error)) *APIClientWrapped_RunGetMethod_Call {
	_c.Call.Return(run)
	return _c
}

// SendExternalMessage provides a mock function with given fields: ctx, msg
func (_m *APIClientWrapped) SendExternalMessage(ctx context.Context, msg *tlb.ExternalMessage) error {
	ret := _m.Called(ctx, msg)

	if len(ret) == 0 {
		panic("no return value specified for SendExternalMessage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.ExternalMessage) error); ok {
		r0 = rf(ctx, msg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// APIClientWrapped_SendExternalMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendExternalMessage'
type APIClientWrapped_SendExternalMessage_Call struct {
	*mock.Call
}

// SendExternalMessage is a helper method to define mock.On call
//   - ctx context.Context
//   - msg *tlb.ExternalMessage
func (_e *APIClientWrapped_Expecter) SendExternalMessage(ctx interface{}, msg interface{}) *APIClientWrapped_SendExternalMessage_Call {
	return &APIClientWrapped_SendExternalMessage_Call{Call: _e.mock.On("SendExternalMessage", ctx, msg)}
}

func (_c *APIClientWrapped_SendExternalMessage_Call) Run(run func(ctx context.Context, msg *tlb.ExternalMessage)) *APIClientWrapped_SendExternalMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*tlb.ExternalMessage))
	})
	return _c
}

func (_c *APIClientWrapped_SendExternalMessage_Call) Return(_a0 error) *APIClientWrapped_SendExternalMessage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *APIClientWrapped_SendExternalMessage_Call) RunAndReturn(run func(context.Context, *tlb.ExternalMessage) error) *APIClientWrapped_SendExternalMessage_Call {
	_c.Call.Return(run)
	return _c
}

// SendExternalMessageWaitTransaction provides a mock function with given fields: ctx, msg
func (_m *APIClientWrapped) SendExternalMessageWaitTransaction(ctx context.Context, msg *tlb.ExternalMessage) (*tlb.Transaction, *tlb.BlockInfo, []byte, error) {
	ret := _m.Called(ctx, msg)

	if len(ret) == 0 {
		panic("no return value specified for SendExternalMessageWaitTransaction")
	}

	var r0 *tlb.Transaction
	var r1 *tlb.BlockInfo
	var r2 []byte
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.ExternalMessage) (*tlb.Transaction, *tlb.BlockInfo, []byte, error)); ok {
		return rf(ctx, msg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.ExternalMessage) *tlb.Transaction); ok {
		r0 = rf(ctx, msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tlb.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *tlb.ExternalMessage) *tlb.BlockInfo); ok {
		r1 = rf(ctx, msg)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*tlb.BlockInfo)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *tlb.ExternalMessage) []byte); ok {
		r2 = rf(ctx, msg)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]byte)
		}
	}

	if rf, ok := ret.Get(3).(func(context.Context, *tlb.ExternalMessage) error); ok {
		r3 = rf(ctx, msg)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// APIClientWrapped_SendExternalMessageWaitTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendExternalMessageWaitTransaction'
type APIClientWrapped_SendExternalMessageWaitTransaction_Call struct {
	*mock.Call
}

// SendExternalMessageWaitTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - msg *tlb.ExternalMessage
func (_e *APIClientWrapped_Expecter) SendExternalMessageWaitTransaction(ctx interface{}, msg interface{}) *APIClientWrapped_SendExternalMessageWaitTransaction_Call {
	return &APIClientWrapped_SendExternalMessageWaitTransaction_Call{Call: _e.mock.On("SendExternalMessageWaitTransaction", ctx, msg)}
}

func (_c *APIClientWrapped_SendExternalMessageWaitTransaction_Call) Run(run func(ctx context.Context, msg *tlb.ExternalMessage)) *APIClientWrapped_SendExternalMessageWaitTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*tlb.ExternalMessage))
	})
	return _c
}

func (_c *APIClientWrapped_SendExternalMessageWaitTransaction_Call) Return(_a0 *tlb.Transaction, _a1 *tlb.BlockInfo, _a2 []byte, _a3 error) *APIClientWrapped_SendExternalMessageWaitTransaction_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *APIClientWrapped_SendExternalMessageWaitTransaction_Call) RunAndReturn(run func(context.Context, *tlb.ExternalMessage) (*tlb.Transaction, *tlb.BlockInfo, []byte, error)) *APIClientWrapped_SendExternalMessageWaitTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// SetTrustedBlock provides a mock function with given fields: block
func (_m *APIClientWrapped) SetTrustedBlock(block *tlb.BlockInfo) {
	_m.Called(block)
}

// APIClientWrapped_SetTrustedBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTrustedBlock'
type APIClientWrapped_SetTrustedBlock_Call struct {
	*mock.Call
}

// SetTrustedBlock is a helper method to define mock.On call
//   - block *tlb.BlockInfo
func (_e *APIClientWrapped_Expecter) SetTrustedBlock(block interface{}) *APIClientWrapped_SetTrustedBlock_Call {
	return &APIClientWrapped_SetTrustedBlock_Call{Call: _e.mock.On("SetTrustedBlock", block)}
}

func (_c *APIClientWrapped_SetTrustedBlock_Call) Run(run func(block *tlb.BlockInfo)) *APIClientWrapped_SetTrustedBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*tlb.BlockInfo))
	})
	return _c
}

func (_c *APIClientWrapped_SetTrustedBlock_Call) Return() *APIClientWrapped_SetTrustedBlock_Call {
	_c.Call.Return()
	return _c
}

func (_c *APIClientWrapped_SetTrustedBlock_Call) RunAndReturn(run func(*tlb.BlockInfo)) *APIClientWrapped_SetTrustedBlock_Call {
	_c.Run(run)
	return _c
}

// SetTrustedBlockFromConfig provides a mock function with given fields: cfg
func (_m *APIClientWrapped) SetTrustedBlockFromConfig(cfg *liteclient.GlobalConfig) {
	_m.Called(cfg)
}

// APIClientWrapped_SetTrustedBlockFromConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTrustedBlockFromConfig'
type APIClientWrapped_SetTrustedBlockFromConfig_Call struct {
	*mock.Call
}

// SetTrustedBlockFromConfig is a helper method to define mock.On call
//   - cfg *liteclient.GlobalConfig
func (_e *APIClientWrapped_Expecter) SetTrustedBlockFromConfig(cfg interface{}) *APIClientWrapped_SetTrustedBlockFromConfig_Call {
	return &APIClientWrapped_SetTrustedBlockFromConfig_Call{Call: _e.mock.On("SetTrustedBlockFromConfig", cfg)}
}

func (_c *APIClientWrapped_SetTrustedBlockFromConfig_Call) Run(run func(cfg *liteclient.GlobalConfig)) *APIClientWrapped_SetTrustedBlockFromConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*liteclient.GlobalConfig))
	})
	return _c
}

func (_c *APIClientWrapped_SetTrustedBlockFromConfig_Call) Return() *APIClientWrapped_SetTrustedBlockFromConfig_Call {
	_c.Call.Return()
	return _c
}

func (_c *APIClientWrapped_SetTrustedBlockFromConfig_Call) RunAndReturn(run func(*liteclient.GlobalConfig)) *APIClientWrapped_SetTrustedBlockFromConfig_Call {
	_c.Run(run)
	return _c
}

// SubscribeOnTransactions provides a mock function with given fields: workerCtx, addr, lastProcessedLT, channel
func (_m *APIClientWrapped) SubscribeOnTransactions(workerCtx context.Context, addr *address.Address, lastProcessedLT uint64, channel chan<- *tlb.Transaction) {
	_m.Called(workerCtx, addr, lastProcessedLT, channel)
}

// APIClientWrapped_SubscribeOnTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeOnTransactions'
type APIClientWrapped_SubscribeOnTransactions_Call struct {
	*mock.Call
}

// SubscribeOnTransactions is a helper method to define mock.On call
//   - workerCtx context.Context
//   - addr *address.Address
//   - lastProcessedLT uint64
//   - channel chan<- *tlb.Transaction
func (_e *APIClientWrapped_Expecter) SubscribeOnTransactions(workerCtx interface{}, addr interface{}, lastProcessedLT interface{}, channel interface{}) *APIClientWrapped_SubscribeOnTransactions_Call {
	return &APIClientWrapped_SubscribeOnTransactions_Call{Call: _e.mock.On("SubscribeOnTransactions", workerCtx, addr, lastProcessedLT, channel)}
}

func (_c *APIClientWrapped_SubscribeOnTransactions_Call) Run(run func(workerCtx context.Context, addr *address.Address, lastProcessedLT uint64, channel chan<- *tlb.Transaction)) *APIClientWrapped_SubscribeOnTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*address.Address), args[2].(uint64), args[3].(chan<- *tlb.Transaction))
	})
	return _c
}

func (_c *APIClientWrapped_SubscribeOnTransactions_Call) Return() *APIClientWrapped_SubscribeOnTransactions_Call {
	_c.Call.Return()
	return _c
}

func (_c *APIClientWrapped_SubscribeOnTransactions_Call) RunAndReturn(run func(context.Context, *address.Address, uint64, chan<- *tlb.Transaction)) *APIClientWrapped_SubscribeOnTransactions_Call {
	_c.Run(run)
	return _c
}

// VerifyProofChain provides a mock function with given fields: ctx, from, to
func (_m *APIClientWrapped) VerifyProofChain(ctx context.Context, from *tlb.BlockInfo, to *tlb.BlockInfo) error {
	ret := _m.Called(ctx, from, to)

	if len(ret) == 0 {
		panic("no return value specified for VerifyProofChain")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *tlb.BlockInfo, *tlb.BlockInfo) error); ok {
		r0 = rf(ctx, from, to)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// APIClientWrapped_VerifyProofChain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyProofChain'
type APIClientWrapped_VerifyProofChain_Call struct {
	*mock.Call
}

// VerifyProofChain is a helper method to define mock.On call
//   - ctx context.Context
//   - from *tlb.BlockInfo
//   - to *tlb.BlockInfo
func (_e *APIClientWrapped_Expecter) VerifyProofChain(ctx interface{}, from interface{}, to interface{}) *APIClientWrapped_VerifyProofChain_Call {
	return &APIClientWrapped_VerifyProofChain_Call{Call: _e.mock.On("VerifyProofChain", ctx, from, to)}
}

func (_c *APIClientWrapped_VerifyProofChain_Call) Run(run func(ctx context.Context, from *tlb.BlockInfo, to *tlb.BlockInfo)) *APIClientWrapped_VerifyProofChain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*tlb.BlockInfo), args[2].(*tlb.BlockInfo))
	})
	return _c
}

func (_c *APIClientWrapped_VerifyProofChain_Call) Return(_a0 error) *APIClientWrapped_VerifyProofChain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *APIClientWrapped_VerifyProofChain_Call) RunAndReturn(run func(context.Context, *tlb.BlockInfo, *tlb.BlockInfo) error) *APIClientWrapped_VerifyProofChain_Call {
	_c.Call.Return(run)
	return _c
}

// WaitForBlock provides a mock function with given fields: seqno
func (_m *APIClientWrapped) WaitForBlock(seqno uint32) ton.APIClientWrapped {
	ret := _m.Called(seqno)

	if len(ret) == 0 {
		panic("no return value specified for WaitForBlock")
	}

	var r0 ton.APIClientWrapped
	if rf, ok := ret.Get(0).(func(uint32) ton.APIClientWrapped); ok {
		r0 = rf(seqno)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ton.APIClientWrapped)
		}
	}

	return r0
}

// APIClientWrapped_WaitForBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitForBlock'
type APIClientWrapped_WaitForBlock_Call struct {
	*mock.Call
}

// WaitForBlock is a helper method to define mock.On call
//   - seqno uint32
func (_e *APIClientWrapped_Expecter) WaitForBlock(seqno interface{}) *APIClientWrapped_WaitForBlock_Call {
	return &APIClientWrapped_WaitForBlock_Call{Call: _e.mock.On("WaitForBlock", seqno)}
}

func (_c *APIClientWrapped_WaitForBlock_Call) Run(run func(seqno uint32)) *APIClientWrapped_WaitForBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint32))
	})
	return _c
}

func (_c *APIClientWrapped_WaitForBlock_Call) Return(_a0 ton.APIClientWrapped) *APIClientWrapped_WaitForBlock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *APIClientWrapped_WaitForBlock_Call) RunAndReturn(run func(uint32) ton.APIClientWrapped) *APIClientWrapped_WaitForBlock_Call {
	_c.Call.Return(run)
	return _c
}

// WithRetry provides a mock function with given fields: maxRetries
func (_m *APIClientWrapped) WithRetry(maxRetries ...int) ton.APIClientWrapped {
	_va := make([]interface{}, len(maxRetries))
	for _i := range maxRetries {
		_va[_i] = maxRetries[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WithRetry")
	}

	var r0 ton.APIClientWrapped
	if rf, ok := ret.Get(0).(func(...int) ton.APIClientWrapped); ok {
		r0 = rf(maxRetries...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ton.APIClientWrapped)
		}
	}

	return r0
}

// APIClientWrapped_WithRetry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithRetry'
type APIClientWrapped_WithRetry_Call struct {
	*mock.Call
}

// WithRetry is a helper method to define mock.On call
//   - maxRetries ...int
func (_e *APIClientWrapped_Expecter) WithRetry(maxRetries ...interface{}) *APIClientWrapped_WithRetry_Call {
	return &APIClientWrapped_WithRetry_Call{Call: _e.mock.On("WithRetry",
		append([]interface{}{}, maxRetries...)...)}
}

func (_c *APIClientWrapped_WithRetry_Call) Run(run func(maxRetries ...int)) *APIClientWrapped_WithRetry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *APIClientWrapped_WithRetry_Call) Return(_a0 ton.APIClientWrapped) *APIClientWrapped_WithRetry_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *APIClientWrapped_WithRetry_Call) RunAndReturn(run func(...int) ton.APIClientWrapped) *APIClientWrapped_WithRetry_Call {
	_c.Call.Return(run)
	return _c
}

// WithTimeout provides a mock function with given fields: timeout
func (_m *APIClientWrapped) WithTimeout(timeout time.Duration) ton.APIClientWrapped {
	ret := _m.Called(timeout)

	if len(ret) == 0 {
		panic("no return value specified for WithTimeout")
	}

	var r0 ton.APIClientWrapped
	if rf, ok := ret.Get(0).(func(time.Duration) ton.APIClientWrapped); ok {
		r0 = rf(timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ton.APIClientWrapped)
		}
	}

	return r0
}

// APIClientWrapped_WithTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTimeout'
type APIClientWrapped_WithTimeout_Call struct {
	*mock.Call
}

// WithTimeout is a helper method to define mock.On call
//   - timeout time.Duration
func (_e *APIClientWrapped_Expecter) WithTimeout(timeout interface{}) *APIClientWrapped_WithTimeout_Call {
	return &APIClientWrapped_WithTimeout_Call{Call: _e.mock.On("WithTimeout", timeout)}
}

func (_c *APIClientWrapped_WithTimeout_Call) Run(run func(timeout time.Duration)) *APIClientWrapped_WithTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Duration))
	})
	return _c
}

func (_c *APIClientWrapped_WithTimeout_Call) Return(_a0 ton.APIClientWrapped) *APIClientWrapped_WithTimeout_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *APIClientWrapped_WithTimeout_Call) RunAndReturn(run func(time.Duration) ton.APIClientWrapped) *APIClientWrapped_WithTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// NewAPIClientWrapped creates a new instance of APIClientWrapped. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAPIClientWrapped(t interface {
	mock.TestingT
	Cleanup(func())
}) *APIClientWrapped {
	mock := &APIClientWrapped{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

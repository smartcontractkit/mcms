// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	big "math/big"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind/v2"
	bindings "github.com/smartcontractkit/mcms/sdk/evm/bindings"

	common "github.com/ethereum/go-ethereum/common"

	event "github.com/ethereum/go-ethereum/event"

	mock "github.com/stretchr/testify/mock"

	types "github.com/ethereum/go-ethereum/core/types"
)

// RBACTimelockInterface is an autogenerated mock type for the RBACTimelockInterface type
type RBACTimelockInterface struct {
	mock.Mock
}

type RBACTimelockInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *RBACTimelockInterface) EXPECT() *RBACTimelockInterface_Expecter {
	return &RBACTimelockInterface_Expecter{mock: &_m.Mock}
}

// ADMINROLE provides a mock function with given fields: opts
func (_m *RBACTimelockInterface) ADMINROLE(opts *bind.CallOpts) ([32]byte, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for ADMINROLE")
	}

	var r0 [32]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([32]byte, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) [32]byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_ADMINROLE_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ADMINROLE'
type RBACTimelockInterface_ADMINROLE_Call struct {
	*mock.Call
}

// ADMINROLE is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RBACTimelockInterface_Expecter) ADMINROLE(opts interface{}) *RBACTimelockInterface_ADMINROLE_Call {
	return &RBACTimelockInterface_ADMINROLE_Call{Call: _e.mock.On("ADMINROLE", opts)}
}

func (_c *RBACTimelockInterface_ADMINROLE_Call) Run(run func(opts *bind.CallOpts)) *RBACTimelockInterface_ADMINROLE_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RBACTimelockInterface_ADMINROLE_Call) Return(_a0 [32]byte, _a1 error) *RBACTimelockInterface_ADMINROLE_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_ADMINROLE_Call) RunAndReturn(run func(*bind.CallOpts) ([32]byte, error)) *RBACTimelockInterface_ADMINROLE_Call {
	_c.Call.Return(run)
	return _c
}

// Address provides a mock function with no fields
func (_m *RBACTimelockInterface) Address() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Address")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// RBACTimelockInterface_Address_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Address'
type RBACTimelockInterface_Address_Call struct {
	*mock.Call
}

// Address is a helper method to define mock.On call
func (_e *RBACTimelockInterface_Expecter) Address() *RBACTimelockInterface_Address_Call {
	return &RBACTimelockInterface_Address_Call{Call: _e.mock.On("Address")}
}

func (_c *RBACTimelockInterface_Address_Call) Run(run func()) *RBACTimelockInterface_Address_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RBACTimelockInterface_Address_Call) Return(_a0 common.Address) *RBACTimelockInterface_Address_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RBACTimelockInterface_Address_Call) RunAndReturn(run func() common.Address) *RBACTimelockInterface_Address_Call {
	_c.Call.Return(run)
	return _c
}

// BYPASSERROLE provides a mock function with given fields: opts
func (_m *RBACTimelockInterface) BYPASSERROLE(opts *bind.CallOpts) ([32]byte, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for BYPASSERROLE")
	}

	var r0 [32]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([32]byte, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) [32]byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_BYPASSERROLE_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BYPASSERROLE'
type RBACTimelockInterface_BYPASSERROLE_Call struct {
	*mock.Call
}

// BYPASSERROLE is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RBACTimelockInterface_Expecter) BYPASSERROLE(opts interface{}) *RBACTimelockInterface_BYPASSERROLE_Call {
	return &RBACTimelockInterface_BYPASSERROLE_Call{Call: _e.mock.On("BYPASSERROLE", opts)}
}

func (_c *RBACTimelockInterface_BYPASSERROLE_Call) Run(run func(opts *bind.CallOpts)) *RBACTimelockInterface_BYPASSERROLE_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RBACTimelockInterface_BYPASSERROLE_Call) Return(_a0 [32]byte, _a1 error) *RBACTimelockInterface_BYPASSERROLE_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_BYPASSERROLE_Call) RunAndReturn(run func(*bind.CallOpts) ([32]byte, error)) *RBACTimelockInterface_BYPASSERROLE_Call {
	_c.Call.Return(run)
	return _c
}

// BlockFunctionSelector provides a mock function with given fields: opts, selector
func (_m *RBACTimelockInterface) BlockFunctionSelector(opts *bind.TransactOpts, selector [4]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, selector)

	if len(ret) == 0 {
		panic("no return value specified for BlockFunctionSelector")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [4]byte) (*types.Transaction, error)); ok {
		return rf(opts, selector)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [4]byte) *types.Transaction); ok {
		r0 = rf(opts, selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [4]byte) error); ok {
		r1 = rf(opts, selector)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_BlockFunctionSelector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockFunctionSelector'
type RBACTimelockInterface_BlockFunctionSelector_Call struct {
	*mock.Call
}

// BlockFunctionSelector is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - selector [4]byte
func (_e *RBACTimelockInterface_Expecter) BlockFunctionSelector(opts interface{}, selector interface{}) *RBACTimelockInterface_BlockFunctionSelector_Call {
	return &RBACTimelockInterface_BlockFunctionSelector_Call{Call: _e.mock.On("BlockFunctionSelector", opts, selector)}
}

func (_c *RBACTimelockInterface_BlockFunctionSelector_Call) Run(run func(opts *bind.TransactOpts, selector [4]byte)) *RBACTimelockInterface_BlockFunctionSelector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([4]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_BlockFunctionSelector_Call) Return(_a0 *types.Transaction, _a1 error) *RBACTimelockInterface_BlockFunctionSelector_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_BlockFunctionSelector_Call) RunAndReturn(run func(*bind.TransactOpts, [4]byte) (*types.Transaction, error)) *RBACTimelockInterface_BlockFunctionSelector_Call {
	_c.Call.Return(run)
	return _c
}

// BypasserExecuteBatch provides a mock function with given fields: opts, calls
func (_m *RBACTimelockInterface) BypasserExecuteBatch(opts *bind.TransactOpts, calls []bindings.RBACTimelockCall) (*types.Transaction, error) {
	ret := _m.Called(opts, calls)

	if len(ret) == 0 {
		panic("no return value specified for BypasserExecuteBatch")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []bindings.RBACTimelockCall) (*types.Transaction, error)); ok {
		return rf(opts, calls)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []bindings.RBACTimelockCall) *types.Transaction); ok {
		r0 = rf(opts, calls)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []bindings.RBACTimelockCall) error); ok {
		r1 = rf(opts, calls)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_BypasserExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BypasserExecuteBatch'
type RBACTimelockInterface_BypasserExecuteBatch_Call struct {
	*mock.Call
}

// BypasserExecuteBatch is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - calls []bindings.RBACTimelockCall
func (_e *RBACTimelockInterface_Expecter) BypasserExecuteBatch(opts interface{}, calls interface{}) *RBACTimelockInterface_BypasserExecuteBatch_Call {
	return &RBACTimelockInterface_BypasserExecuteBatch_Call{Call: _e.mock.On("BypasserExecuteBatch", opts, calls)}
}

func (_c *RBACTimelockInterface_BypasserExecuteBatch_Call) Run(run func(opts *bind.TransactOpts, calls []bindings.RBACTimelockCall)) *RBACTimelockInterface_BypasserExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([]bindings.RBACTimelockCall))
	})
	return _c
}

func (_c *RBACTimelockInterface_BypasserExecuteBatch_Call) Return(_a0 *types.Transaction, _a1 error) *RBACTimelockInterface_BypasserExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_BypasserExecuteBatch_Call) RunAndReturn(run func(*bind.TransactOpts, []bindings.RBACTimelockCall) (*types.Transaction, error)) *RBACTimelockInterface_BypasserExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// CANCELLERROLE provides a mock function with given fields: opts
func (_m *RBACTimelockInterface) CANCELLERROLE(opts *bind.CallOpts) ([32]byte, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for CANCELLERROLE")
	}

	var r0 [32]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([32]byte, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) [32]byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_CANCELLERROLE_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CANCELLERROLE'
type RBACTimelockInterface_CANCELLERROLE_Call struct {
	*mock.Call
}

// CANCELLERROLE is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RBACTimelockInterface_Expecter) CANCELLERROLE(opts interface{}) *RBACTimelockInterface_CANCELLERROLE_Call {
	return &RBACTimelockInterface_CANCELLERROLE_Call{Call: _e.mock.On("CANCELLERROLE", opts)}
}

func (_c *RBACTimelockInterface_CANCELLERROLE_Call) Run(run func(opts *bind.CallOpts)) *RBACTimelockInterface_CANCELLERROLE_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RBACTimelockInterface_CANCELLERROLE_Call) Return(_a0 [32]byte, _a1 error) *RBACTimelockInterface_CANCELLERROLE_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_CANCELLERROLE_Call) RunAndReturn(run func(*bind.CallOpts) ([32]byte, error)) *RBACTimelockInterface_CANCELLERROLE_Call {
	_c.Call.Return(run)
	return _c
}

// Cancel provides a mock function with given fields: opts, id
func (_m *RBACTimelockInterface) Cancel(opts *bind.TransactOpts, id [32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, id)

	if len(ret) == 0 {
		panic("no return value specified for Cancel")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte) (*types.Transaction, error)); ok {
		return rf(opts, id)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte) *types.Transaction); ok {
		r0 = rf(opts, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [32]byte) error); ok {
		r1 = rf(opts, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_Cancel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Cancel'
type RBACTimelockInterface_Cancel_Call struct {
	*mock.Call
}

// Cancel is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - id [32]byte
func (_e *RBACTimelockInterface_Expecter) Cancel(opts interface{}, id interface{}) *RBACTimelockInterface_Cancel_Call {
	return &RBACTimelockInterface_Cancel_Call{Call: _e.mock.On("Cancel", opts, id)}
}

func (_c *RBACTimelockInterface_Cancel_Call) Run(run func(opts *bind.TransactOpts, id [32]byte)) *RBACTimelockInterface_Cancel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_Cancel_Call) Return(_a0 *types.Transaction, _a1 error) *RBACTimelockInterface_Cancel_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_Cancel_Call) RunAndReturn(run func(*bind.TransactOpts, [32]byte) (*types.Transaction, error)) *RBACTimelockInterface_Cancel_Call {
	_c.Call.Return(run)
	return _c
}

// DEFAULTADMINROLE provides a mock function with given fields: opts
func (_m *RBACTimelockInterface) DEFAULTADMINROLE(opts *bind.CallOpts) ([32]byte, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for DEFAULTADMINROLE")
	}

	var r0 [32]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([32]byte, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) [32]byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_DEFAULTADMINROLE_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DEFAULTADMINROLE'
type RBACTimelockInterface_DEFAULTADMINROLE_Call struct {
	*mock.Call
}

// DEFAULTADMINROLE is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RBACTimelockInterface_Expecter) DEFAULTADMINROLE(opts interface{}) *RBACTimelockInterface_DEFAULTADMINROLE_Call {
	return &RBACTimelockInterface_DEFAULTADMINROLE_Call{Call: _e.mock.On("DEFAULTADMINROLE", opts)}
}

func (_c *RBACTimelockInterface_DEFAULTADMINROLE_Call) Run(run func(opts *bind.CallOpts)) *RBACTimelockInterface_DEFAULTADMINROLE_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RBACTimelockInterface_DEFAULTADMINROLE_Call) Return(_a0 [32]byte, _a1 error) *RBACTimelockInterface_DEFAULTADMINROLE_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_DEFAULTADMINROLE_Call) RunAndReturn(run func(*bind.CallOpts) ([32]byte, error)) *RBACTimelockInterface_DEFAULTADMINROLE_Call {
	_c.Call.Return(run)
	return _c
}

// EXECUTORROLE provides a mock function with given fields: opts
func (_m *RBACTimelockInterface) EXECUTORROLE(opts *bind.CallOpts) ([32]byte, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for EXECUTORROLE")
	}

	var r0 [32]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([32]byte, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) [32]byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_EXECUTORROLE_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EXECUTORROLE'
type RBACTimelockInterface_EXECUTORROLE_Call struct {
	*mock.Call
}

// EXECUTORROLE is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RBACTimelockInterface_Expecter) EXECUTORROLE(opts interface{}) *RBACTimelockInterface_EXECUTORROLE_Call {
	return &RBACTimelockInterface_EXECUTORROLE_Call{Call: _e.mock.On("EXECUTORROLE", opts)}
}

func (_c *RBACTimelockInterface_EXECUTORROLE_Call) Run(run func(opts *bind.CallOpts)) *RBACTimelockInterface_EXECUTORROLE_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RBACTimelockInterface_EXECUTORROLE_Call) Return(_a0 [32]byte, _a1 error) *RBACTimelockInterface_EXECUTORROLE_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_EXECUTORROLE_Call) RunAndReturn(run func(*bind.CallOpts) ([32]byte, error)) *RBACTimelockInterface_EXECUTORROLE_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteBatch provides a mock function with given fields: opts, calls, predecessor, salt
func (_m *RBACTimelockInterface) ExecuteBatch(opts *bind.TransactOpts, calls []bindings.RBACTimelockCall, predecessor [32]byte, salt [32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, calls, predecessor, salt)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteBatch")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []bindings.RBACTimelockCall, [32]byte, [32]byte) (*types.Transaction, error)); ok {
		return rf(opts, calls, predecessor, salt)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []bindings.RBACTimelockCall, [32]byte, [32]byte) *types.Transaction); ok {
		r0 = rf(opts, calls, predecessor, salt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []bindings.RBACTimelockCall, [32]byte, [32]byte) error); ok {
		r1 = rf(opts, calls, predecessor, salt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_ExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteBatch'
type RBACTimelockInterface_ExecuteBatch_Call struct {
	*mock.Call
}

// ExecuteBatch is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - calls []bindings.RBACTimelockCall
//   - predecessor [32]byte
//   - salt [32]byte
func (_e *RBACTimelockInterface_Expecter) ExecuteBatch(opts interface{}, calls interface{}, predecessor interface{}, salt interface{}) *RBACTimelockInterface_ExecuteBatch_Call {
	return &RBACTimelockInterface_ExecuteBatch_Call{Call: _e.mock.On("ExecuteBatch", opts, calls, predecessor, salt)}
}

func (_c *RBACTimelockInterface_ExecuteBatch_Call) Run(run func(opts *bind.TransactOpts, calls []bindings.RBACTimelockCall, predecessor [32]byte, salt [32]byte)) *RBACTimelockInterface_ExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([]bindings.RBACTimelockCall), args[2].([32]byte), args[3].([32]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_ExecuteBatch_Call) Return(_a0 *types.Transaction, _a1 error) *RBACTimelockInterface_ExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_ExecuteBatch_Call) RunAndReturn(run func(*bind.TransactOpts, []bindings.RBACTimelockCall, [32]byte, [32]byte) (*types.Transaction, error)) *RBACTimelockInterface_ExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// FilterBypasserCallExecuted provides a mock function with given fields: opts, index
func (_m *RBACTimelockInterface) FilterBypasserCallExecuted(opts *bind.FilterOpts, index []*big.Int) (*bindings.RBACTimelockBypasserCallExecutedIterator, error) {
	ret := _m.Called(opts, index)

	if len(ret) == 0 {
		panic("no return value specified for FilterBypasserCallExecuted")
	}

	var r0 *bindings.RBACTimelockBypasserCallExecutedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []*big.Int) (*bindings.RBACTimelockBypasserCallExecutedIterator, error)); ok {
		return rf(opts, index)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []*big.Int) *bindings.RBACTimelockBypasserCallExecutedIterator); ok {
		r0 = rf(opts, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockBypasserCallExecutedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []*big.Int) error); ok {
		r1 = rf(opts, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_FilterBypasserCallExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterBypasserCallExecuted'
type RBACTimelockInterface_FilterBypasserCallExecuted_Call struct {
	*mock.Call
}

// FilterBypasserCallExecuted is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - index []*big.Int
func (_e *RBACTimelockInterface_Expecter) FilterBypasserCallExecuted(opts interface{}, index interface{}) *RBACTimelockInterface_FilterBypasserCallExecuted_Call {
	return &RBACTimelockInterface_FilterBypasserCallExecuted_Call{Call: _e.mock.On("FilterBypasserCallExecuted", opts, index)}
}

func (_c *RBACTimelockInterface_FilterBypasserCallExecuted_Call) Run(run func(opts *bind.FilterOpts, index []*big.Int)) *RBACTimelockInterface_FilterBypasserCallExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]*big.Int))
	})
	return _c
}

func (_c *RBACTimelockInterface_FilterBypasserCallExecuted_Call) Return(_a0 *bindings.RBACTimelockBypasserCallExecutedIterator, _a1 error) *RBACTimelockInterface_FilterBypasserCallExecuted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_FilterBypasserCallExecuted_Call) RunAndReturn(run func(*bind.FilterOpts, []*big.Int) (*bindings.RBACTimelockBypasserCallExecutedIterator, error)) *RBACTimelockInterface_FilterBypasserCallExecuted_Call {
	_c.Call.Return(run)
	return _c
}

// FilterCallExecuted provides a mock function with given fields: opts, id, index
func (_m *RBACTimelockInterface) FilterCallExecuted(opts *bind.FilterOpts, id [][32]byte, index []*big.Int) (*bindings.RBACTimelockCallExecutedIterator, error) {
	ret := _m.Called(opts, id, index)

	if len(ret) == 0 {
		panic("no return value specified for FilterCallExecuted")
	}

	var r0 *bindings.RBACTimelockCallExecutedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []*big.Int) (*bindings.RBACTimelockCallExecutedIterator, error)); ok {
		return rf(opts, id, index)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []*big.Int) *bindings.RBACTimelockCallExecutedIterator); ok {
		r0 = rf(opts, id, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockCallExecutedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte, []*big.Int) error); ok {
		r1 = rf(opts, id, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_FilterCallExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterCallExecuted'
type RBACTimelockInterface_FilterCallExecuted_Call struct {
	*mock.Call
}

// FilterCallExecuted is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - id [][32]byte
//   - index []*big.Int
func (_e *RBACTimelockInterface_Expecter) FilterCallExecuted(opts interface{}, id interface{}, index interface{}) *RBACTimelockInterface_FilterCallExecuted_Call {
	return &RBACTimelockInterface_FilterCallExecuted_Call{Call: _e.mock.On("FilterCallExecuted", opts, id, index)}
}

func (_c *RBACTimelockInterface_FilterCallExecuted_Call) Run(run func(opts *bind.FilterOpts, id [][32]byte, index []*big.Int)) *RBACTimelockInterface_FilterCallExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte), args[2].([]*big.Int))
	})
	return _c
}

func (_c *RBACTimelockInterface_FilterCallExecuted_Call) Return(_a0 *bindings.RBACTimelockCallExecutedIterator, _a1 error) *RBACTimelockInterface_FilterCallExecuted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_FilterCallExecuted_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte, []*big.Int) (*bindings.RBACTimelockCallExecutedIterator, error)) *RBACTimelockInterface_FilterCallExecuted_Call {
	_c.Call.Return(run)
	return _c
}

// FilterCallScheduled provides a mock function with given fields: opts, id, index
func (_m *RBACTimelockInterface) FilterCallScheduled(opts *bind.FilterOpts, id [][32]byte, index []*big.Int) (*bindings.RBACTimelockCallScheduledIterator, error) {
	ret := _m.Called(opts, id, index)

	if len(ret) == 0 {
		panic("no return value specified for FilterCallScheduled")
	}

	var r0 *bindings.RBACTimelockCallScheduledIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []*big.Int) (*bindings.RBACTimelockCallScheduledIterator, error)); ok {
		return rf(opts, id, index)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []*big.Int) *bindings.RBACTimelockCallScheduledIterator); ok {
		r0 = rf(opts, id, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockCallScheduledIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte, []*big.Int) error); ok {
		r1 = rf(opts, id, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_FilterCallScheduled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterCallScheduled'
type RBACTimelockInterface_FilterCallScheduled_Call struct {
	*mock.Call
}

// FilterCallScheduled is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - id [][32]byte
//   - index []*big.Int
func (_e *RBACTimelockInterface_Expecter) FilterCallScheduled(opts interface{}, id interface{}, index interface{}) *RBACTimelockInterface_FilterCallScheduled_Call {
	return &RBACTimelockInterface_FilterCallScheduled_Call{Call: _e.mock.On("FilterCallScheduled", opts, id, index)}
}

func (_c *RBACTimelockInterface_FilterCallScheduled_Call) Run(run func(opts *bind.FilterOpts, id [][32]byte, index []*big.Int)) *RBACTimelockInterface_FilterCallScheduled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte), args[2].([]*big.Int))
	})
	return _c
}

func (_c *RBACTimelockInterface_FilterCallScheduled_Call) Return(_a0 *bindings.RBACTimelockCallScheduledIterator, _a1 error) *RBACTimelockInterface_FilterCallScheduled_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_FilterCallScheduled_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte, []*big.Int) (*bindings.RBACTimelockCallScheduledIterator, error)) *RBACTimelockInterface_FilterCallScheduled_Call {
	_c.Call.Return(run)
	return _c
}

// FilterCancelled provides a mock function with given fields: opts, id
func (_m *RBACTimelockInterface) FilterCancelled(opts *bind.FilterOpts, id [][32]byte) (*bindings.RBACTimelockCancelledIterator, error) {
	ret := _m.Called(opts, id)

	if len(ret) == 0 {
		panic("no return value specified for FilterCancelled")
	}

	var r0 *bindings.RBACTimelockCancelledIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte) (*bindings.RBACTimelockCancelledIterator, error)); ok {
		return rf(opts, id)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte) *bindings.RBACTimelockCancelledIterator); ok {
		r0 = rf(opts, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockCancelledIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte) error); ok {
		r1 = rf(opts, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_FilterCancelled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterCancelled'
type RBACTimelockInterface_FilterCancelled_Call struct {
	*mock.Call
}

// FilterCancelled is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - id [][32]byte
func (_e *RBACTimelockInterface_Expecter) FilterCancelled(opts interface{}, id interface{}) *RBACTimelockInterface_FilterCancelled_Call {
	return &RBACTimelockInterface_FilterCancelled_Call{Call: _e.mock.On("FilterCancelled", opts, id)}
}

func (_c *RBACTimelockInterface_FilterCancelled_Call) Run(run func(opts *bind.FilterOpts, id [][32]byte)) *RBACTimelockInterface_FilterCancelled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_FilterCancelled_Call) Return(_a0 *bindings.RBACTimelockCancelledIterator, _a1 error) *RBACTimelockInterface_FilterCancelled_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_FilterCancelled_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte) (*bindings.RBACTimelockCancelledIterator, error)) *RBACTimelockInterface_FilterCancelled_Call {
	_c.Call.Return(run)
	return _c
}

// FilterFunctionSelectorBlocked provides a mock function with given fields: opts, selector
func (_m *RBACTimelockInterface) FilterFunctionSelectorBlocked(opts *bind.FilterOpts, selector [][4]byte) (*bindings.RBACTimelockFunctionSelectorBlockedIterator, error) {
	ret := _m.Called(opts, selector)

	if len(ret) == 0 {
		panic("no return value specified for FilterFunctionSelectorBlocked")
	}

	var r0 *bindings.RBACTimelockFunctionSelectorBlockedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][4]byte) (*bindings.RBACTimelockFunctionSelectorBlockedIterator, error)); ok {
		return rf(opts, selector)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][4]byte) *bindings.RBACTimelockFunctionSelectorBlockedIterator); ok {
		r0 = rf(opts, selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockFunctionSelectorBlockedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][4]byte) error); ok {
		r1 = rf(opts, selector)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_FilterFunctionSelectorBlocked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterFunctionSelectorBlocked'
type RBACTimelockInterface_FilterFunctionSelectorBlocked_Call struct {
	*mock.Call
}

// FilterFunctionSelectorBlocked is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - selector [][4]byte
func (_e *RBACTimelockInterface_Expecter) FilterFunctionSelectorBlocked(opts interface{}, selector interface{}) *RBACTimelockInterface_FilterFunctionSelectorBlocked_Call {
	return &RBACTimelockInterface_FilterFunctionSelectorBlocked_Call{Call: _e.mock.On("FilterFunctionSelectorBlocked", opts, selector)}
}

func (_c *RBACTimelockInterface_FilterFunctionSelectorBlocked_Call) Run(run func(opts *bind.FilterOpts, selector [][4]byte)) *RBACTimelockInterface_FilterFunctionSelectorBlocked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][4]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_FilterFunctionSelectorBlocked_Call) Return(_a0 *bindings.RBACTimelockFunctionSelectorBlockedIterator, _a1 error) *RBACTimelockInterface_FilterFunctionSelectorBlocked_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_FilterFunctionSelectorBlocked_Call) RunAndReturn(run func(*bind.FilterOpts, [][4]byte) (*bindings.RBACTimelockFunctionSelectorBlockedIterator, error)) *RBACTimelockInterface_FilterFunctionSelectorBlocked_Call {
	_c.Call.Return(run)
	return _c
}

// FilterFunctionSelectorUnblocked provides a mock function with given fields: opts, selector
func (_m *RBACTimelockInterface) FilterFunctionSelectorUnblocked(opts *bind.FilterOpts, selector [][4]byte) (*bindings.RBACTimelockFunctionSelectorUnblockedIterator, error) {
	ret := _m.Called(opts, selector)

	if len(ret) == 0 {
		panic("no return value specified for FilterFunctionSelectorUnblocked")
	}

	var r0 *bindings.RBACTimelockFunctionSelectorUnblockedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][4]byte) (*bindings.RBACTimelockFunctionSelectorUnblockedIterator, error)); ok {
		return rf(opts, selector)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][4]byte) *bindings.RBACTimelockFunctionSelectorUnblockedIterator); ok {
		r0 = rf(opts, selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockFunctionSelectorUnblockedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][4]byte) error); ok {
		r1 = rf(opts, selector)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_FilterFunctionSelectorUnblocked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterFunctionSelectorUnblocked'
type RBACTimelockInterface_FilterFunctionSelectorUnblocked_Call struct {
	*mock.Call
}

// FilterFunctionSelectorUnblocked is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - selector [][4]byte
func (_e *RBACTimelockInterface_Expecter) FilterFunctionSelectorUnblocked(opts interface{}, selector interface{}) *RBACTimelockInterface_FilterFunctionSelectorUnblocked_Call {
	return &RBACTimelockInterface_FilterFunctionSelectorUnblocked_Call{Call: _e.mock.On("FilterFunctionSelectorUnblocked", opts, selector)}
}

func (_c *RBACTimelockInterface_FilterFunctionSelectorUnblocked_Call) Run(run func(opts *bind.FilterOpts, selector [][4]byte)) *RBACTimelockInterface_FilterFunctionSelectorUnblocked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][4]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_FilterFunctionSelectorUnblocked_Call) Return(_a0 *bindings.RBACTimelockFunctionSelectorUnblockedIterator, _a1 error) *RBACTimelockInterface_FilterFunctionSelectorUnblocked_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_FilterFunctionSelectorUnblocked_Call) RunAndReturn(run func(*bind.FilterOpts, [][4]byte) (*bindings.RBACTimelockFunctionSelectorUnblockedIterator, error)) *RBACTimelockInterface_FilterFunctionSelectorUnblocked_Call {
	_c.Call.Return(run)
	return _c
}

// FilterMinDelayChange provides a mock function with given fields: opts
func (_m *RBACTimelockInterface) FilterMinDelayChange(opts *bind.FilterOpts) (*bindings.RBACTimelockMinDelayChangeIterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterMinDelayChange")
	}

	var r0 *bindings.RBACTimelockMinDelayChangeIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*bindings.RBACTimelockMinDelayChangeIterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *bindings.RBACTimelockMinDelayChangeIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockMinDelayChangeIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_FilterMinDelayChange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterMinDelayChange'
type RBACTimelockInterface_FilterMinDelayChange_Call struct {
	*mock.Call
}

// FilterMinDelayChange is a helper method to define mock.On call
//   - opts *bind.FilterOpts
func (_e *RBACTimelockInterface_Expecter) FilterMinDelayChange(opts interface{}) *RBACTimelockInterface_FilterMinDelayChange_Call {
	return &RBACTimelockInterface_FilterMinDelayChange_Call{Call: _e.mock.On("FilterMinDelayChange", opts)}
}

func (_c *RBACTimelockInterface_FilterMinDelayChange_Call) Run(run func(opts *bind.FilterOpts)) *RBACTimelockInterface_FilterMinDelayChange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts))
	})
	return _c
}

func (_c *RBACTimelockInterface_FilterMinDelayChange_Call) Return(_a0 *bindings.RBACTimelockMinDelayChangeIterator, _a1 error) *RBACTimelockInterface_FilterMinDelayChange_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_FilterMinDelayChange_Call) RunAndReturn(run func(*bind.FilterOpts) (*bindings.RBACTimelockMinDelayChangeIterator, error)) *RBACTimelockInterface_FilterMinDelayChange_Call {
	_c.Call.Return(run)
	return _c
}

// FilterRoleAdminChanged provides a mock function with given fields: opts, role, previousAdminRole, newAdminRole
func (_m *RBACTimelockInterface) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (*bindings.RBACTimelockRoleAdminChangedIterator, error) {
	ret := _m.Called(opts, role, previousAdminRole, newAdminRole)

	if len(ret) == 0 {
		panic("no return value specified for FilterRoleAdminChanged")
	}

	var r0 *bindings.RBACTimelockRoleAdminChangedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, [][32]byte, [][32]byte) (*bindings.RBACTimelockRoleAdminChangedIterator, error)); ok {
		return rf(opts, role, previousAdminRole, newAdminRole)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, [][32]byte, [][32]byte) *bindings.RBACTimelockRoleAdminChangedIterator); ok {
		r0 = rf(opts, role, previousAdminRole, newAdminRole)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockRoleAdminChangedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte, [][32]byte, [][32]byte) error); ok {
		r1 = rf(opts, role, previousAdminRole, newAdminRole)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_FilterRoleAdminChanged_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterRoleAdminChanged'
type RBACTimelockInterface_FilterRoleAdminChanged_Call struct {
	*mock.Call
}

// FilterRoleAdminChanged is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - role [][32]byte
//   - previousAdminRole [][32]byte
//   - newAdminRole [][32]byte
func (_e *RBACTimelockInterface_Expecter) FilterRoleAdminChanged(opts interface{}, role interface{}, previousAdminRole interface{}, newAdminRole interface{}) *RBACTimelockInterface_FilterRoleAdminChanged_Call {
	return &RBACTimelockInterface_FilterRoleAdminChanged_Call{Call: _e.mock.On("FilterRoleAdminChanged", opts, role, previousAdminRole, newAdminRole)}
}

func (_c *RBACTimelockInterface_FilterRoleAdminChanged_Call) Run(run func(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte)) *RBACTimelockInterface_FilterRoleAdminChanged_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte), args[2].([][32]byte), args[3].([][32]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_FilterRoleAdminChanged_Call) Return(_a0 *bindings.RBACTimelockRoleAdminChangedIterator, _a1 error) *RBACTimelockInterface_FilterRoleAdminChanged_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_FilterRoleAdminChanged_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte, [][32]byte, [][32]byte) (*bindings.RBACTimelockRoleAdminChangedIterator, error)) *RBACTimelockInterface_FilterRoleAdminChanged_Call {
	_c.Call.Return(run)
	return _c
}

// FilterRoleGranted provides a mock function with given fields: opts, role, account, sender
func (_m *RBACTimelockInterface) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*bindings.RBACTimelockRoleGrantedIterator, error) {
	ret := _m.Called(opts, role, account, sender)

	if len(ret) == 0 {
		panic("no return value specified for FilterRoleGranted")
	}

	var r0 *bindings.RBACTimelockRoleGrantedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []common.Address) (*bindings.RBACTimelockRoleGrantedIterator, error)); ok {
		return rf(opts, role, account, sender)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []common.Address) *bindings.RBACTimelockRoleGrantedIterator); ok {
		r0 = rf(opts, role, account, sender)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockRoleGrantedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, role, account, sender)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_FilterRoleGranted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterRoleGranted'
type RBACTimelockInterface_FilterRoleGranted_Call struct {
	*mock.Call
}

// FilterRoleGranted is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - role [][32]byte
//   - account []common.Address
//   - sender []common.Address
func (_e *RBACTimelockInterface_Expecter) FilterRoleGranted(opts interface{}, role interface{}, account interface{}, sender interface{}) *RBACTimelockInterface_FilterRoleGranted_Call {
	return &RBACTimelockInterface_FilterRoleGranted_Call{Call: _e.mock.On("FilterRoleGranted", opts, role, account, sender)}
}

func (_c *RBACTimelockInterface_FilterRoleGranted_Call) Run(run func(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address)) *RBACTimelockInterface_FilterRoleGranted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte), args[2].([]common.Address), args[3].([]common.Address))
	})
	return _c
}

func (_c *RBACTimelockInterface_FilterRoleGranted_Call) Return(_a0 *bindings.RBACTimelockRoleGrantedIterator, _a1 error) *RBACTimelockInterface_FilterRoleGranted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_FilterRoleGranted_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte, []common.Address, []common.Address) (*bindings.RBACTimelockRoleGrantedIterator, error)) *RBACTimelockInterface_FilterRoleGranted_Call {
	_c.Call.Return(run)
	return _c
}

// FilterRoleRevoked provides a mock function with given fields: opts, role, account, sender
func (_m *RBACTimelockInterface) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*bindings.RBACTimelockRoleRevokedIterator, error) {
	ret := _m.Called(opts, role, account, sender)

	if len(ret) == 0 {
		panic("no return value specified for FilterRoleRevoked")
	}

	var r0 *bindings.RBACTimelockRoleRevokedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []common.Address) (*bindings.RBACTimelockRoleRevokedIterator, error)); ok {
		return rf(opts, role, account, sender)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []common.Address) *bindings.RBACTimelockRoleRevokedIterator); ok {
		r0 = rf(opts, role, account, sender)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockRoleRevokedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, role, account, sender)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_FilterRoleRevoked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterRoleRevoked'
type RBACTimelockInterface_FilterRoleRevoked_Call struct {
	*mock.Call
}

// FilterRoleRevoked is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - role [][32]byte
//   - account []common.Address
//   - sender []common.Address
func (_e *RBACTimelockInterface_Expecter) FilterRoleRevoked(opts interface{}, role interface{}, account interface{}, sender interface{}) *RBACTimelockInterface_FilterRoleRevoked_Call {
	return &RBACTimelockInterface_FilterRoleRevoked_Call{Call: _e.mock.On("FilterRoleRevoked", opts, role, account, sender)}
}

func (_c *RBACTimelockInterface_FilterRoleRevoked_Call) Run(run func(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address)) *RBACTimelockInterface_FilterRoleRevoked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte), args[2].([]common.Address), args[3].([]common.Address))
	})
	return _c
}

func (_c *RBACTimelockInterface_FilterRoleRevoked_Call) Return(_a0 *bindings.RBACTimelockRoleRevokedIterator, _a1 error) *RBACTimelockInterface_FilterRoleRevoked_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_FilterRoleRevoked_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte, []common.Address, []common.Address) (*bindings.RBACTimelockRoleRevokedIterator, error)) *RBACTimelockInterface_FilterRoleRevoked_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockedFunctionSelectorAt provides a mock function with given fields: opts, index
func (_m *RBACTimelockInterface) GetBlockedFunctionSelectorAt(opts *bind.CallOpts, index *big.Int) ([4]byte, error) {
	ret := _m.Called(opts, index)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockedFunctionSelectorAt")
	}

	var r0 [4]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) ([4]byte, error)); ok {
		return rf(opts, index)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) [4]byte); ok {
		r0 = rf(opts, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([4]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, *big.Int) error); ok {
		r1 = rf(opts, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_GetBlockedFunctionSelectorAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockedFunctionSelectorAt'
type RBACTimelockInterface_GetBlockedFunctionSelectorAt_Call struct {
	*mock.Call
}

// GetBlockedFunctionSelectorAt is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - index *big.Int
func (_e *RBACTimelockInterface_Expecter) GetBlockedFunctionSelectorAt(opts interface{}, index interface{}) *RBACTimelockInterface_GetBlockedFunctionSelectorAt_Call {
	return &RBACTimelockInterface_GetBlockedFunctionSelectorAt_Call{Call: _e.mock.On("GetBlockedFunctionSelectorAt", opts, index)}
}

func (_c *RBACTimelockInterface_GetBlockedFunctionSelectorAt_Call) Run(run func(opts *bind.CallOpts, index *big.Int)) *RBACTimelockInterface_GetBlockedFunctionSelectorAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].(*big.Int))
	})
	return _c
}

func (_c *RBACTimelockInterface_GetBlockedFunctionSelectorAt_Call) Return(_a0 [4]byte, _a1 error) *RBACTimelockInterface_GetBlockedFunctionSelectorAt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_GetBlockedFunctionSelectorAt_Call) RunAndReturn(run func(*bind.CallOpts, *big.Int) ([4]byte, error)) *RBACTimelockInterface_GetBlockedFunctionSelectorAt_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockedFunctionSelectorCount provides a mock function with given fields: opts
func (_m *RBACTimelockInterface) GetBlockedFunctionSelectorCount(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockedFunctionSelectorCount")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_GetBlockedFunctionSelectorCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockedFunctionSelectorCount'
type RBACTimelockInterface_GetBlockedFunctionSelectorCount_Call struct {
	*mock.Call
}

// GetBlockedFunctionSelectorCount is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RBACTimelockInterface_Expecter) GetBlockedFunctionSelectorCount(opts interface{}) *RBACTimelockInterface_GetBlockedFunctionSelectorCount_Call {
	return &RBACTimelockInterface_GetBlockedFunctionSelectorCount_Call{Call: _e.mock.On("GetBlockedFunctionSelectorCount", opts)}
}

func (_c *RBACTimelockInterface_GetBlockedFunctionSelectorCount_Call) Run(run func(opts *bind.CallOpts)) *RBACTimelockInterface_GetBlockedFunctionSelectorCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RBACTimelockInterface_GetBlockedFunctionSelectorCount_Call) Return(_a0 *big.Int, _a1 error) *RBACTimelockInterface_GetBlockedFunctionSelectorCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_GetBlockedFunctionSelectorCount_Call) RunAndReturn(run func(*bind.CallOpts) (*big.Int, error)) *RBACTimelockInterface_GetBlockedFunctionSelectorCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetMinDelay provides a mock function with given fields: opts
func (_m *RBACTimelockInterface) GetMinDelay(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetMinDelay")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_GetMinDelay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMinDelay'
type RBACTimelockInterface_GetMinDelay_Call struct {
	*mock.Call
}

// GetMinDelay is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RBACTimelockInterface_Expecter) GetMinDelay(opts interface{}) *RBACTimelockInterface_GetMinDelay_Call {
	return &RBACTimelockInterface_GetMinDelay_Call{Call: _e.mock.On("GetMinDelay", opts)}
}

func (_c *RBACTimelockInterface_GetMinDelay_Call) Run(run func(opts *bind.CallOpts)) *RBACTimelockInterface_GetMinDelay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RBACTimelockInterface_GetMinDelay_Call) Return(_a0 *big.Int, _a1 error) *RBACTimelockInterface_GetMinDelay_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_GetMinDelay_Call) RunAndReturn(run func(*bind.CallOpts) (*big.Int, error)) *RBACTimelockInterface_GetMinDelay_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoleAdmin provides a mock function with given fields: opts, role
func (_m *RBACTimelockInterface) GetRoleAdmin(opts *bind.CallOpts, role [32]byte) ([32]byte, error) {
	ret := _m.Called(opts, role)

	if len(ret) == 0 {
		panic("no return value specified for GetRoleAdmin")
	}

	var r0 [32]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) ([32]byte, error)); ok {
		return rf(opts, role)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) [32]byte); ok {
		r0 = rf(opts, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_GetRoleAdmin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoleAdmin'
type RBACTimelockInterface_GetRoleAdmin_Call struct {
	*mock.Call
}

// GetRoleAdmin is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - role [32]byte
func (_e *RBACTimelockInterface_Expecter) GetRoleAdmin(opts interface{}, role interface{}) *RBACTimelockInterface_GetRoleAdmin_Call {
	return &RBACTimelockInterface_GetRoleAdmin_Call{Call: _e.mock.On("GetRoleAdmin", opts, role)}
}

func (_c *RBACTimelockInterface_GetRoleAdmin_Call) Run(run func(opts *bind.CallOpts, role [32]byte)) *RBACTimelockInterface_GetRoleAdmin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_GetRoleAdmin_Call) Return(_a0 [32]byte, _a1 error) *RBACTimelockInterface_GetRoleAdmin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_GetRoleAdmin_Call) RunAndReturn(run func(*bind.CallOpts, [32]byte) ([32]byte, error)) *RBACTimelockInterface_GetRoleAdmin_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoleMember provides a mock function with given fields: opts, role, index
func (_m *RBACTimelockInterface) GetRoleMember(opts *bind.CallOpts, role [32]byte, index *big.Int) (common.Address, error) {
	ret := _m.Called(opts, role, index)

	if len(ret) == 0 {
		panic("no return value specified for GetRoleMember")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte, *big.Int) (common.Address, error)); ok {
		return rf(opts, role, index)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte, *big.Int) common.Address); ok {
		r0 = rf(opts, role, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte, *big.Int) error); ok {
		r1 = rf(opts, role, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_GetRoleMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoleMember'
type RBACTimelockInterface_GetRoleMember_Call struct {
	*mock.Call
}

// GetRoleMember is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - role [32]byte
//   - index *big.Int
func (_e *RBACTimelockInterface_Expecter) GetRoleMember(opts interface{}, role interface{}, index interface{}) *RBACTimelockInterface_GetRoleMember_Call {
	return &RBACTimelockInterface_GetRoleMember_Call{Call: _e.mock.On("GetRoleMember", opts, role, index)}
}

func (_c *RBACTimelockInterface_GetRoleMember_Call) Run(run func(opts *bind.CallOpts, role [32]byte, index *big.Int)) *RBACTimelockInterface_GetRoleMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([32]byte), args[2].(*big.Int))
	})
	return _c
}

func (_c *RBACTimelockInterface_GetRoleMember_Call) Return(_a0 common.Address, _a1 error) *RBACTimelockInterface_GetRoleMember_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_GetRoleMember_Call) RunAndReturn(run func(*bind.CallOpts, [32]byte, *big.Int) (common.Address, error)) *RBACTimelockInterface_GetRoleMember_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoleMemberCount provides a mock function with given fields: opts, role
func (_m *RBACTimelockInterface) GetRoleMemberCount(opts *bind.CallOpts, role [32]byte) (*big.Int, error) {
	ret := _m.Called(opts, role)

	if len(ret) == 0 {
		panic("no return value specified for GetRoleMemberCount")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) (*big.Int, error)); ok {
		return rf(opts, role)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) *big.Int); ok {
		r0 = rf(opts, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_GetRoleMemberCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoleMemberCount'
type RBACTimelockInterface_GetRoleMemberCount_Call struct {
	*mock.Call
}

// GetRoleMemberCount is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - role [32]byte
func (_e *RBACTimelockInterface_Expecter) GetRoleMemberCount(opts interface{}, role interface{}) *RBACTimelockInterface_GetRoleMemberCount_Call {
	return &RBACTimelockInterface_GetRoleMemberCount_Call{Call: _e.mock.On("GetRoleMemberCount", opts, role)}
}

func (_c *RBACTimelockInterface_GetRoleMemberCount_Call) Run(run func(opts *bind.CallOpts, role [32]byte)) *RBACTimelockInterface_GetRoleMemberCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_GetRoleMemberCount_Call) Return(_a0 *big.Int, _a1 error) *RBACTimelockInterface_GetRoleMemberCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_GetRoleMemberCount_Call) RunAndReturn(run func(*bind.CallOpts, [32]byte) (*big.Int, error)) *RBACTimelockInterface_GetRoleMemberCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetTimestamp provides a mock function with given fields: opts, id
func (_m *RBACTimelockInterface) GetTimestamp(opts *bind.CallOpts, id [32]byte) (*big.Int, error) {
	ret := _m.Called(opts, id)

	if len(ret) == 0 {
		panic("no return value specified for GetTimestamp")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) (*big.Int, error)); ok {
		return rf(opts, id)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) *big.Int); ok {
		r0 = rf(opts, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_GetTimestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTimestamp'
type RBACTimelockInterface_GetTimestamp_Call struct {
	*mock.Call
}

// GetTimestamp is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - id [32]byte
func (_e *RBACTimelockInterface_Expecter) GetTimestamp(opts interface{}, id interface{}) *RBACTimelockInterface_GetTimestamp_Call {
	return &RBACTimelockInterface_GetTimestamp_Call{Call: _e.mock.On("GetTimestamp", opts, id)}
}

func (_c *RBACTimelockInterface_GetTimestamp_Call) Run(run func(opts *bind.CallOpts, id [32]byte)) *RBACTimelockInterface_GetTimestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_GetTimestamp_Call) Return(_a0 *big.Int, _a1 error) *RBACTimelockInterface_GetTimestamp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_GetTimestamp_Call) RunAndReturn(run func(*bind.CallOpts, [32]byte) (*big.Int, error)) *RBACTimelockInterface_GetTimestamp_Call {
	_c.Call.Return(run)
	return _c
}

// GrantRole provides a mock function with given fields: opts, role, account
func (_m *RBACTimelockInterface) GrantRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, role, account)

	if len(ret) == 0 {
		panic("no return value specified for GrantRole")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, common.Address) (*types.Transaction, error)); ok {
		return rf(opts, role, account)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, common.Address) *types.Transaction); ok {
		r0 = rf(opts, role, account)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [32]byte, common.Address) error); ok {
		r1 = rf(opts, role, account)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_GrantRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GrantRole'
type RBACTimelockInterface_GrantRole_Call struct {
	*mock.Call
}

// GrantRole is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - role [32]byte
//   - account common.Address
func (_e *RBACTimelockInterface_Expecter) GrantRole(opts interface{}, role interface{}, account interface{}) *RBACTimelockInterface_GrantRole_Call {
	return &RBACTimelockInterface_GrantRole_Call{Call: _e.mock.On("GrantRole", opts, role, account)}
}

func (_c *RBACTimelockInterface_GrantRole_Call) Run(run func(opts *bind.TransactOpts, role [32]byte, account common.Address)) *RBACTimelockInterface_GrantRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([32]byte), args[2].(common.Address))
	})
	return _c
}

func (_c *RBACTimelockInterface_GrantRole_Call) Return(_a0 *types.Transaction, _a1 error) *RBACTimelockInterface_GrantRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_GrantRole_Call) RunAndReturn(run func(*bind.TransactOpts, [32]byte, common.Address) (*types.Transaction, error)) *RBACTimelockInterface_GrantRole_Call {
	_c.Call.Return(run)
	return _c
}

// HasRole provides a mock function with given fields: opts, role, account
func (_m *RBACTimelockInterface) HasRole(opts *bind.CallOpts, role [32]byte, account common.Address) (bool, error) {
	ret := _m.Called(opts, role, account)

	if len(ret) == 0 {
		panic("no return value specified for HasRole")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte, common.Address) (bool, error)); ok {
		return rf(opts, role, account)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte, common.Address) bool); ok {
		r0 = rf(opts, role, account)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte, common.Address) error); ok {
		r1 = rf(opts, role, account)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_HasRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasRole'
type RBACTimelockInterface_HasRole_Call struct {
	*mock.Call
}

// HasRole is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - role [32]byte
//   - account common.Address
func (_e *RBACTimelockInterface_Expecter) HasRole(opts interface{}, role interface{}, account interface{}) *RBACTimelockInterface_HasRole_Call {
	return &RBACTimelockInterface_HasRole_Call{Call: _e.mock.On("HasRole", opts, role, account)}
}

func (_c *RBACTimelockInterface_HasRole_Call) Run(run func(opts *bind.CallOpts, role [32]byte, account common.Address)) *RBACTimelockInterface_HasRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([32]byte), args[2].(common.Address))
	})
	return _c
}

func (_c *RBACTimelockInterface_HasRole_Call) Return(_a0 bool, _a1 error) *RBACTimelockInterface_HasRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_HasRole_Call) RunAndReturn(run func(*bind.CallOpts, [32]byte, common.Address) (bool, error)) *RBACTimelockInterface_HasRole_Call {
	_c.Call.Return(run)
	return _c
}

// HashOperationBatch provides a mock function with given fields: opts, calls, predecessor, salt
func (_m *RBACTimelockInterface) HashOperationBatch(opts *bind.CallOpts, calls []bindings.RBACTimelockCall, predecessor [32]byte, salt [32]byte) ([32]byte, error) {
	ret := _m.Called(opts, calls, predecessor, salt)

	if len(ret) == 0 {
		panic("no return value specified for HashOperationBatch")
	}

	var r0 [32]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, []bindings.RBACTimelockCall, [32]byte, [32]byte) ([32]byte, error)); ok {
		return rf(opts, calls, predecessor, salt)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, []bindings.RBACTimelockCall, [32]byte, [32]byte) [32]byte); ok {
		r0 = rf(opts, calls, predecessor, salt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, []bindings.RBACTimelockCall, [32]byte, [32]byte) error); ok {
		r1 = rf(opts, calls, predecessor, salt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_HashOperationBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashOperationBatch'
type RBACTimelockInterface_HashOperationBatch_Call struct {
	*mock.Call
}

// HashOperationBatch is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - calls []bindings.RBACTimelockCall
//   - predecessor [32]byte
//   - salt [32]byte
func (_e *RBACTimelockInterface_Expecter) HashOperationBatch(opts interface{}, calls interface{}, predecessor interface{}, salt interface{}) *RBACTimelockInterface_HashOperationBatch_Call {
	return &RBACTimelockInterface_HashOperationBatch_Call{Call: _e.mock.On("HashOperationBatch", opts, calls, predecessor, salt)}
}

func (_c *RBACTimelockInterface_HashOperationBatch_Call) Run(run func(opts *bind.CallOpts, calls []bindings.RBACTimelockCall, predecessor [32]byte, salt [32]byte)) *RBACTimelockInterface_HashOperationBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([]bindings.RBACTimelockCall), args[2].([32]byte), args[3].([32]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_HashOperationBatch_Call) Return(_a0 [32]byte, _a1 error) *RBACTimelockInterface_HashOperationBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_HashOperationBatch_Call) RunAndReturn(run func(*bind.CallOpts, []bindings.RBACTimelockCall, [32]byte, [32]byte) ([32]byte, error)) *RBACTimelockInterface_HashOperationBatch_Call {
	_c.Call.Return(run)
	return _c
}

// IsOperation provides a mock function with given fields: opts, id
func (_m *RBACTimelockInterface) IsOperation(opts *bind.CallOpts, id [32]byte) (bool, error) {
	ret := _m.Called(opts, id)

	if len(ret) == 0 {
		panic("no return value specified for IsOperation")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) (bool, error)); ok {
		return rf(opts, id)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) bool); ok {
		r0 = rf(opts, id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_IsOperation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsOperation'
type RBACTimelockInterface_IsOperation_Call struct {
	*mock.Call
}

// IsOperation is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - id [32]byte
func (_e *RBACTimelockInterface_Expecter) IsOperation(opts interface{}, id interface{}) *RBACTimelockInterface_IsOperation_Call {
	return &RBACTimelockInterface_IsOperation_Call{Call: _e.mock.On("IsOperation", opts, id)}
}

func (_c *RBACTimelockInterface_IsOperation_Call) Run(run func(opts *bind.CallOpts, id [32]byte)) *RBACTimelockInterface_IsOperation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_IsOperation_Call) Return(_a0 bool, _a1 error) *RBACTimelockInterface_IsOperation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_IsOperation_Call) RunAndReturn(run func(*bind.CallOpts, [32]byte) (bool, error)) *RBACTimelockInterface_IsOperation_Call {
	_c.Call.Return(run)
	return _c
}

// IsOperationDone provides a mock function with given fields: opts, id
func (_m *RBACTimelockInterface) IsOperationDone(opts *bind.CallOpts, id [32]byte) (bool, error) {
	ret := _m.Called(opts, id)

	if len(ret) == 0 {
		panic("no return value specified for IsOperationDone")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) (bool, error)); ok {
		return rf(opts, id)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) bool); ok {
		r0 = rf(opts, id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_IsOperationDone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsOperationDone'
type RBACTimelockInterface_IsOperationDone_Call struct {
	*mock.Call
}

// IsOperationDone is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - id [32]byte
func (_e *RBACTimelockInterface_Expecter) IsOperationDone(opts interface{}, id interface{}) *RBACTimelockInterface_IsOperationDone_Call {
	return &RBACTimelockInterface_IsOperationDone_Call{Call: _e.mock.On("IsOperationDone", opts, id)}
}

func (_c *RBACTimelockInterface_IsOperationDone_Call) Run(run func(opts *bind.CallOpts, id [32]byte)) *RBACTimelockInterface_IsOperationDone_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_IsOperationDone_Call) Return(_a0 bool, _a1 error) *RBACTimelockInterface_IsOperationDone_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_IsOperationDone_Call) RunAndReturn(run func(*bind.CallOpts, [32]byte) (bool, error)) *RBACTimelockInterface_IsOperationDone_Call {
	_c.Call.Return(run)
	return _c
}

// IsOperationPending provides a mock function with given fields: opts, id
func (_m *RBACTimelockInterface) IsOperationPending(opts *bind.CallOpts, id [32]byte) (bool, error) {
	ret := _m.Called(opts, id)

	if len(ret) == 0 {
		panic("no return value specified for IsOperationPending")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) (bool, error)); ok {
		return rf(opts, id)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) bool); ok {
		r0 = rf(opts, id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_IsOperationPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsOperationPending'
type RBACTimelockInterface_IsOperationPending_Call struct {
	*mock.Call
}

// IsOperationPending is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - id [32]byte
func (_e *RBACTimelockInterface_Expecter) IsOperationPending(opts interface{}, id interface{}) *RBACTimelockInterface_IsOperationPending_Call {
	return &RBACTimelockInterface_IsOperationPending_Call{Call: _e.mock.On("IsOperationPending", opts, id)}
}

func (_c *RBACTimelockInterface_IsOperationPending_Call) Run(run func(opts *bind.CallOpts, id [32]byte)) *RBACTimelockInterface_IsOperationPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_IsOperationPending_Call) Return(_a0 bool, _a1 error) *RBACTimelockInterface_IsOperationPending_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_IsOperationPending_Call) RunAndReturn(run func(*bind.CallOpts, [32]byte) (bool, error)) *RBACTimelockInterface_IsOperationPending_Call {
	_c.Call.Return(run)
	return _c
}

// IsOperationReady provides a mock function with given fields: opts, id
func (_m *RBACTimelockInterface) IsOperationReady(opts *bind.CallOpts, id [32]byte) (bool, error) {
	ret := _m.Called(opts, id)

	if len(ret) == 0 {
		panic("no return value specified for IsOperationReady")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) (bool, error)); ok {
		return rf(opts, id)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) bool); ok {
		r0 = rf(opts, id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_IsOperationReady_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsOperationReady'
type RBACTimelockInterface_IsOperationReady_Call struct {
	*mock.Call
}

// IsOperationReady is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - id [32]byte
func (_e *RBACTimelockInterface_Expecter) IsOperationReady(opts interface{}, id interface{}) *RBACTimelockInterface_IsOperationReady_Call {
	return &RBACTimelockInterface_IsOperationReady_Call{Call: _e.mock.On("IsOperationReady", opts, id)}
}

func (_c *RBACTimelockInterface_IsOperationReady_Call) Run(run func(opts *bind.CallOpts, id [32]byte)) *RBACTimelockInterface_IsOperationReady_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_IsOperationReady_Call) Return(_a0 bool, _a1 error) *RBACTimelockInterface_IsOperationReady_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_IsOperationReady_Call) RunAndReturn(run func(*bind.CallOpts, [32]byte) (bool, error)) *RBACTimelockInterface_IsOperationReady_Call {
	_c.Call.Return(run)
	return _c
}

// OnERC1155BatchReceived provides a mock function with given fields: opts, arg0, arg1, arg2, arg3, arg4
func (_m *RBACTimelockInterface) OnERC1155BatchReceived(opts *bind.TransactOpts, arg0 common.Address, arg1 common.Address, arg2 []*big.Int, arg3 []*big.Int, arg4 []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, arg0, arg1, arg2, arg3, arg4)

	if len(ret) == 0 {
		panic("no return value specified for OnERC1155BatchReceived")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, common.Address, []*big.Int, []*big.Int, []byte) (*types.Transaction, error)); ok {
		return rf(opts, arg0, arg1, arg2, arg3, arg4)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, common.Address, []*big.Int, []*big.Int, []byte) *types.Transaction); ok {
		r0 = rf(opts, arg0, arg1, arg2, arg3, arg4)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address, common.Address, []*big.Int, []*big.Int, []byte) error); ok {
		r1 = rf(opts, arg0, arg1, arg2, arg3, arg4)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_OnERC1155BatchReceived_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnERC1155BatchReceived'
type RBACTimelockInterface_OnERC1155BatchReceived_Call struct {
	*mock.Call
}

// OnERC1155BatchReceived is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - arg0 common.Address
//   - arg1 common.Address
//   - arg2 []*big.Int
//   - arg3 []*big.Int
//   - arg4 []byte
func (_e *RBACTimelockInterface_Expecter) OnERC1155BatchReceived(opts interface{}, arg0 interface{}, arg1 interface{}, arg2 interface{}, arg3 interface{}, arg4 interface{}) *RBACTimelockInterface_OnERC1155BatchReceived_Call {
	return &RBACTimelockInterface_OnERC1155BatchReceived_Call{Call: _e.mock.On("OnERC1155BatchReceived", opts, arg0, arg1, arg2, arg3, arg4)}
}

func (_c *RBACTimelockInterface_OnERC1155BatchReceived_Call) Run(run func(opts *bind.TransactOpts, arg0 common.Address, arg1 common.Address, arg2 []*big.Int, arg3 []*big.Int, arg4 []byte)) *RBACTimelockInterface_OnERC1155BatchReceived_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].(common.Address), args[2].(common.Address), args[3].([]*big.Int), args[4].([]*big.Int), args[5].([]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_OnERC1155BatchReceived_Call) Return(_a0 *types.Transaction, _a1 error) *RBACTimelockInterface_OnERC1155BatchReceived_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_OnERC1155BatchReceived_Call) RunAndReturn(run func(*bind.TransactOpts, common.Address, common.Address, []*big.Int, []*big.Int, []byte) (*types.Transaction, error)) *RBACTimelockInterface_OnERC1155BatchReceived_Call {
	_c.Call.Return(run)
	return _c
}

// OnERC1155Received provides a mock function with given fields: opts, arg0, arg1, arg2, arg3, arg4
func (_m *RBACTimelockInterface) OnERC1155Received(opts *bind.TransactOpts, arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, arg0, arg1, arg2, arg3, arg4)

	if len(ret) == 0 {
		panic("no return value specified for OnERC1155Received")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, common.Address, *big.Int, *big.Int, []byte) (*types.Transaction, error)); ok {
		return rf(opts, arg0, arg1, arg2, arg3, arg4)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, common.Address, *big.Int, *big.Int, []byte) *types.Transaction); ok {
		r0 = rf(opts, arg0, arg1, arg2, arg3, arg4)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address, common.Address, *big.Int, *big.Int, []byte) error); ok {
		r1 = rf(opts, arg0, arg1, arg2, arg3, arg4)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_OnERC1155Received_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnERC1155Received'
type RBACTimelockInterface_OnERC1155Received_Call struct {
	*mock.Call
}

// OnERC1155Received is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - arg0 common.Address
//   - arg1 common.Address
//   - arg2 *big.Int
//   - arg3 *big.Int
//   - arg4 []byte
func (_e *RBACTimelockInterface_Expecter) OnERC1155Received(opts interface{}, arg0 interface{}, arg1 interface{}, arg2 interface{}, arg3 interface{}, arg4 interface{}) *RBACTimelockInterface_OnERC1155Received_Call {
	return &RBACTimelockInterface_OnERC1155Received_Call{Call: _e.mock.On("OnERC1155Received", opts, arg0, arg1, arg2, arg3, arg4)}
}

func (_c *RBACTimelockInterface_OnERC1155Received_Call) Run(run func(opts *bind.TransactOpts, arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 *big.Int, arg4 []byte)) *RBACTimelockInterface_OnERC1155Received_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].(common.Address), args[2].(common.Address), args[3].(*big.Int), args[4].(*big.Int), args[5].([]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_OnERC1155Received_Call) Return(_a0 *types.Transaction, _a1 error) *RBACTimelockInterface_OnERC1155Received_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_OnERC1155Received_Call) RunAndReturn(run func(*bind.TransactOpts, common.Address, common.Address, *big.Int, *big.Int, []byte) (*types.Transaction, error)) *RBACTimelockInterface_OnERC1155Received_Call {
	_c.Call.Return(run)
	return _c
}

// OnERC721Received provides a mock function with given fields: opts, arg0, arg1, arg2, arg3
func (_m *RBACTimelockInterface) OnERC721Received(opts *bind.TransactOpts, arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, arg0, arg1, arg2, arg3)

	if len(ret) == 0 {
		panic("no return value specified for OnERC721Received")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, common.Address, *big.Int, []byte) (*types.Transaction, error)); ok {
		return rf(opts, arg0, arg1, arg2, arg3)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, common.Address, *big.Int, []byte) *types.Transaction); ok {
		r0 = rf(opts, arg0, arg1, arg2, arg3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address, common.Address, *big.Int, []byte) error); ok {
		r1 = rf(opts, arg0, arg1, arg2, arg3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_OnERC721Received_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnERC721Received'
type RBACTimelockInterface_OnERC721Received_Call struct {
	*mock.Call
}

// OnERC721Received is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - arg0 common.Address
//   - arg1 common.Address
//   - arg2 *big.Int
//   - arg3 []byte
func (_e *RBACTimelockInterface_Expecter) OnERC721Received(opts interface{}, arg0 interface{}, arg1 interface{}, arg2 interface{}, arg3 interface{}) *RBACTimelockInterface_OnERC721Received_Call {
	return &RBACTimelockInterface_OnERC721Received_Call{Call: _e.mock.On("OnERC721Received", opts, arg0, arg1, arg2, arg3)}
}

func (_c *RBACTimelockInterface_OnERC721Received_Call) Run(run func(opts *bind.TransactOpts, arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 []byte)) *RBACTimelockInterface_OnERC721Received_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].(common.Address), args[2].(common.Address), args[3].(*big.Int), args[4].([]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_OnERC721Received_Call) Return(_a0 *types.Transaction, _a1 error) *RBACTimelockInterface_OnERC721Received_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_OnERC721Received_Call) RunAndReturn(run func(*bind.TransactOpts, common.Address, common.Address, *big.Int, []byte) (*types.Transaction, error)) *RBACTimelockInterface_OnERC721Received_Call {
	_c.Call.Return(run)
	return _c
}

// PROPOSERROLE provides a mock function with given fields: opts
func (_m *RBACTimelockInterface) PROPOSERROLE(opts *bind.CallOpts) ([32]byte, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for PROPOSERROLE")
	}

	var r0 [32]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([32]byte, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) [32]byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_PROPOSERROLE_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PROPOSERROLE'
type RBACTimelockInterface_PROPOSERROLE_Call struct {
	*mock.Call
}

// PROPOSERROLE is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *RBACTimelockInterface_Expecter) PROPOSERROLE(opts interface{}) *RBACTimelockInterface_PROPOSERROLE_Call {
	return &RBACTimelockInterface_PROPOSERROLE_Call{Call: _e.mock.On("PROPOSERROLE", opts)}
}

func (_c *RBACTimelockInterface_PROPOSERROLE_Call) Run(run func(opts *bind.CallOpts)) *RBACTimelockInterface_PROPOSERROLE_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *RBACTimelockInterface_PROPOSERROLE_Call) Return(_a0 [32]byte, _a1 error) *RBACTimelockInterface_PROPOSERROLE_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_PROPOSERROLE_Call) RunAndReturn(run func(*bind.CallOpts) ([32]byte, error)) *RBACTimelockInterface_PROPOSERROLE_Call {
	_c.Call.Return(run)
	return _c
}

// ParseBypasserCallExecuted provides a mock function with given fields: log
func (_m *RBACTimelockInterface) ParseBypasserCallExecuted(log types.Log) (*bindings.RBACTimelockBypasserCallExecuted, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseBypasserCallExecuted")
	}

	var r0 *bindings.RBACTimelockBypasserCallExecuted
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.RBACTimelockBypasserCallExecuted, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.RBACTimelockBypasserCallExecuted); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockBypasserCallExecuted)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_ParseBypasserCallExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseBypasserCallExecuted'
type RBACTimelockInterface_ParseBypasserCallExecuted_Call struct {
	*mock.Call
}

// ParseBypasserCallExecuted is a helper method to define mock.On call
//   - log types.Log
func (_e *RBACTimelockInterface_Expecter) ParseBypasserCallExecuted(log interface{}) *RBACTimelockInterface_ParseBypasserCallExecuted_Call {
	return &RBACTimelockInterface_ParseBypasserCallExecuted_Call{Call: _e.mock.On("ParseBypasserCallExecuted", log)}
}

func (_c *RBACTimelockInterface_ParseBypasserCallExecuted_Call) Run(run func(log types.Log)) *RBACTimelockInterface_ParseBypasserCallExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *RBACTimelockInterface_ParseBypasserCallExecuted_Call) Return(_a0 *bindings.RBACTimelockBypasserCallExecuted, _a1 error) *RBACTimelockInterface_ParseBypasserCallExecuted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_ParseBypasserCallExecuted_Call) RunAndReturn(run func(types.Log) (*bindings.RBACTimelockBypasserCallExecuted, error)) *RBACTimelockInterface_ParseBypasserCallExecuted_Call {
	_c.Call.Return(run)
	return _c
}

// ParseCallExecuted provides a mock function with given fields: log
func (_m *RBACTimelockInterface) ParseCallExecuted(log types.Log) (*bindings.RBACTimelockCallExecuted, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseCallExecuted")
	}

	var r0 *bindings.RBACTimelockCallExecuted
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.RBACTimelockCallExecuted, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.RBACTimelockCallExecuted); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockCallExecuted)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_ParseCallExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseCallExecuted'
type RBACTimelockInterface_ParseCallExecuted_Call struct {
	*mock.Call
}

// ParseCallExecuted is a helper method to define mock.On call
//   - log types.Log
func (_e *RBACTimelockInterface_Expecter) ParseCallExecuted(log interface{}) *RBACTimelockInterface_ParseCallExecuted_Call {
	return &RBACTimelockInterface_ParseCallExecuted_Call{Call: _e.mock.On("ParseCallExecuted", log)}
}

func (_c *RBACTimelockInterface_ParseCallExecuted_Call) Run(run func(log types.Log)) *RBACTimelockInterface_ParseCallExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *RBACTimelockInterface_ParseCallExecuted_Call) Return(_a0 *bindings.RBACTimelockCallExecuted, _a1 error) *RBACTimelockInterface_ParseCallExecuted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_ParseCallExecuted_Call) RunAndReturn(run func(types.Log) (*bindings.RBACTimelockCallExecuted, error)) *RBACTimelockInterface_ParseCallExecuted_Call {
	_c.Call.Return(run)
	return _c
}

// ParseCallScheduled provides a mock function with given fields: log
func (_m *RBACTimelockInterface) ParseCallScheduled(log types.Log) (*bindings.RBACTimelockCallScheduled, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseCallScheduled")
	}

	var r0 *bindings.RBACTimelockCallScheduled
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.RBACTimelockCallScheduled, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.RBACTimelockCallScheduled); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockCallScheduled)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_ParseCallScheduled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseCallScheduled'
type RBACTimelockInterface_ParseCallScheduled_Call struct {
	*mock.Call
}

// ParseCallScheduled is a helper method to define mock.On call
//   - log types.Log
func (_e *RBACTimelockInterface_Expecter) ParseCallScheduled(log interface{}) *RBACTimelockInterface_ParseCallScheduled_Call {
	return &RBACTimelockInterface_ParseCallScheduled_Call{Call: _e.mock.On("ParseCallScheduled", log)}
}

func (_c *RBACTimelockInterface_ParseCallScheduled_Call) Run(run func(log types.Log)) *RBACTimelockInterface_ParseCallScheduled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *RBACTimelockInterface_ParseCallScheduled_Call) Return(_a0 *bindings.RBACTimelockCallScheduled, _a1 error) *RBACTimelockInterface_ParseCallScheduled_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_ParseCallScheduled_Call) RunAndReturn(run func(types.Log) (*bindings.RBACTimelockCallScheduled, error)) *RBACTimelockInterface_ParseCallScheduled_Call {
	_c.Call.Return(run)
	return _c
}

// ParseCancelled provides a mock function with given fields: log
func (_m *RBACTimelockInterface) ParseCancelled(log types.Log) (*bindings.RBACTimelockCancelled, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseCancelled")
	}

	var r0 *bindings.RBACTimelockCancelled
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.RBACTimelockCancelled, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.RBACTimelockCancelled); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockCancelled)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_ParseCancelled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseCancelled'
type RBACTimelockInterface_ParseCancelled_Call struct {
	*mock.Call
}

// ParseCancelled is a helper method to define mock.On call
//   - log types.Log
func (_e *RBACTimelockInterface_Expecter) ParseCancelled(log interface{}) *RBACTimelockInterface_ParseCancelled_Call {
	return &RBACTimelockInterface_ParseCancelled_Call{Call: _e.mock.On("ParseCancelled", log)}
}

func (_c *RBACTimelockInterface_ParseCancelled_Call) Run(run func(log types.Log)) *RBACTimelockInterface_ParseCancelled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *RBACTimelockInterface_ParseCancelled_Call) Return(_a0 *bindings.RBACTimelockCancelled, _a1 error) *RBACTimelockInterface_ParseCancelled_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_ParseCancelled_Call) RunAndReturn(run func(types.Log) (*bindings.RBACTimelockCancelled, error)) *RBACTimelockInterface_ParseCancelled_Call {
	_c.Call.Return(run)
	return _c
}

// ParseFunctionSelectorBlocked provides a mock function with given fields: log
func (_m *RBACTimelockInterface) ParseFunctionSelectorBlocked(log types.Log) (*bindings.RBACTimelockFunctionSelectorBlocked, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseFunctionSelectorBlocked")
	}

	var r0 *bindings.RBACTimelockFunctionSelectorBlocked
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.RBACTimelockFunctionSelectorBlocked, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.RBACTimelockFunctionSelectorBlocked); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockFunctionSelectorBlocked)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_ParseFunctionSelectorBlocked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseFunctionSelectorBlocked'
type RBACTimelockInterface_ParseFunctionSelectorBlocked_Call struct {
	*mock.Call
}

// ParseFunctionSelectorBlocked is a helper method to define mock.On call
//   - log types.Log
func (_e *RBACTimelockInterface_Expecter) ParseFunctionSelectorBlocked(log interface{}) *RBACTimelockInterface_ParseFunctionSelectorBlocked_Call {
	return &RBACTimelockInterface_ParseFunctionSelectorBlocked_Call{Call: _e.mock.On("ParseFunctionSelectorBlocked", log)}
}

func (_c *RBACTimelockInterface_ParseFunctionSelectorBlocked_Call) Run(run func(log types.Log)) *RBACTimelockInterface_ParseFunctionSelectorBlocked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *RBACTimelockInterface_ParseFunctionSelectorBlocked_Call) Return(_a0 *bindings.RBACTimelockFunctionSelectorBlocked, _a1 error) *RBACTimelockInterface_ParseFunctionSelectorBlocked_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_ParseFunctionSelectorBlocked_Call) RunAndReturn(run func(types.Log) (*bindings.RBACTimelockFunctionSelectorBlocked, error)) *RBACTimelockInterface_ParseFunctionSelectorBlocked_Call {
	_c.Call.Return(run)
	return _c
}

// ParseFunctionSelectorUnblocked provides a mock function with given fields: log
func (_m *RBACTimelockInterface) ParseFunctionSelectorUnblocked(log types.Log) (*bindings.RBACTimelockFunctionSelectorUnblocked, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseFunctionSelectorUnblocked")
	}

	var r0 *bindings.RBACTimelockFunctionSelectorUnblocked
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.RBACTimelockFunctionSelectorUnblocked, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.RBACTimelockFunctionSelectorUnblocked); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockFunctionSelectorUnblocked)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_ParseFunctionSelectorUnblocked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseFunctionSelectorUnblocked'
type RBACTimelockInterface_ParseFunctionSelectorUnblocked_Call struct {
	*mock.Call
}

// ParseFunctionSelectorUnblocked is a helper method to define mock.On call
//   - log types.Log
func (_e *RBACTimelockInterface_Expecter) ParseFunctionSelectorUnblocked(log interface{}) *RBACTimelockInterface_ParseFunctionSelectorUnblocked_Call {
	return &RBACTimelockInterface_ParseFunctionSelectorUnblocked_Call{Call: _e.mock.On("ParseFunctionSelectorUnblocked", log)}
}

func (_c *RBACTimelockInterface_ParseFunctionSelectorUnblocked_Call) Run(run func(log types.Log)) *RBACTimelockInterface_ParseFunctionSelectorUnblocked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *RBACTimelockInterface_ParseFunctionSelectorUnblocked_Call) Return(_a0 *bindings.RBACTimelockFunctionSelectorUnblocked, _a1 error) *RBACTimelockInterface_ParseFunctionSelectorUnblocked_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_ParseFunctionSelectorUnblocked_Call) RunAndReturn(run func(types.Log) (*bindings.RBACTimelockFunctionSelectorUnblocked, error)) *RBACTimelockInterface_ParseFunctionSelectorUnblocked_Call {
	_c.Call.Return(run)
	return _c
}

// ParseLog provides a mock function with given fields: log
func (_m *RBACTimelockInterface) ParseLog(log types.Log) (bindings.AbigenLog, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseLog")
	}

	var r0 bindings.AbigenLog
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (bindings.AbigenLog, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) bindings.AbigenLog); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(bindings.AbigenLog)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_ParseLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseLog'
type RBACTimelockInterface_ParseLog_Call struct {
	*mock.Call
}

// ParseLog is a helper method to define mock.On call
//   - log types.Log
func (_e *RBACTimelockInterface_Expecter) ParseLog(log interface{}) *RBACTimelockInterface_ParseLog_Call {
	return &RBACTimelockInterface_ParseLog_Call{Call: _e.mock.On("ParseLog", log)}
}

func (_c *RBACTimelockInterface_ParseLog_Call) Run(run func(log types.Log)) *RBACTimelockInterface_ParseLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *RBACTimelockInterface_ParseLog_Call) Return(_a0 bindings.AbigenLog, _a1 error) *RBACTimelockInterface_ParseLog_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_ParseLog_Call) RunAndReturn(run func(types.Log) (bindings.AbigenLog, error)) *RBACTimelockInterface_ParseLog_Call {
	_c.Call.Return(run)
	return _c
}

// ParseMinDelayChange provides a mock function with given fields: log
func (_m *RBACTimelockInterface) ParseMinDelayChange(log types.Log) (*bindings.RBACTimelockMinDelayChange, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseMinDelayChange")
	}

	var r0 *bindings.RBACTimelockMinDelayChange
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.RBACTimelockMinDelayChange, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.RBACTimelockMinDelayChange); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockMinDelayChange)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_ParseMinDelayChange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseMinDelayChange'
type RBACTimelockInterface_ParseMinDelayChange_Call struct {
	*mock.Call
}

// ParseMinDelayChange is a helper method to define mock.On call
//   - log types.Log
func (_e *RBACTimelockInterface_Expecter) ParseMinDelayChange(log interface{}) *RBACTimelockInterface_ParseMinDelayChange_Call {
	return &RBACTimelockInterface_ParseMinDelayChange_Call{Call: _e.mock.On("ParseMinDelayChange", log)}
}

func (_c *RBACTimelockInterface_ParseMinDelayChange_Call) Run(run func(log types.Log)) *RBACTimelockInterface_ParseMinDelayChange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *RBACTimelockInterface_ParseMinDelayChange_Call) Return(_a0 *bindings.RBACTimelockMinDelayChange, _a1 error) *RBACTimelockInterface_ParseMinDelayChange_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_ParseMinDelayChange_Call) RunAndReturn(run func(types.Log) (*bindings.RBACTimelockMinDelayChange, error)) *RBACTimelockInterface_ParseMinDelayChange_Call {
	_c.Call.Return(run)
	return _c
}

// ParseRoleAdminChanged provides a mock function with given fields: log
func (_m *RBACTimelockInterface) ParseRoleAdminChanged(log types.Log) (*bindings.RBACTimelockRoleAdminChanged, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseRoleAdminChanged")
	}

	var r0 *bindings.RBACTimelockRoleAdminChanged
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.RBACTimelockRoleAdminChanged, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.RBACTimelockRoleAdminChanged); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockRoleAdminChanged)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_ParseRoleAdminChanged_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseRoleAdminChanged'
type RBACTimelockInterface_ParseRoleAdminChanged_Call struct {
	*mock.Call
}

// ParseRoleAdminChanged is a helper method to define mock.On call
//   - log types.Log
func (_e *RBACTimelockInterface_Expecter) ParseRoleAdminChanged(log interface{}) *RBACTimelockInterface_ParseRoleAdminChanged_Call {
	return &RBACTimelockInterface_ParseRoleAdminChanged_Call{Call: _e.mock.On("ParseRoleAdminChanged", log)}
}

func (_c *RBACTimelockInterface_ParseRoleAdminChanged_Call) Run(run func(log types.Log)) *RBACTimelockInterface_ParseRoleAdminChanged_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *RBACTimelockInterface_ParseRoleAdminChanged_Call) Return(_a0 *bindings.RBACTimelockRoleAdminChanged, _a1 error) *RBACTimelockInterface_ParseRoleAdminChanged_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_ParseRoleAdminChanged_Call) RunAndReturn(run func(types.Log) (*bindings.RBACTimelockRoleAdminChanged, error)) *RBACTimelockInterface_ParseRoleAdminChanged_Call {
	_c.Call.Return(run)
	return _c
}

// ParseRoleGranted provides a mock function with given fields: log
func (_m *RBACTimelockInterface) ParseRoleGranted(log types.Log) (*bindings.RBACTimelockRoleGranted, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseRoleGranted")
	}

	var r0 *bindings.RBACTimelockRoleGranted
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.RBACTimelockRoleGranted, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.RBACTimelockRoleGranted); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockRoleGranted)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_ParseRoleGranted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseRoleGranted'
type RBACTimelockInterface_ParseRoleGranted_Call struct {
	*mock.Call
}

// ParseRoleGranted is a helper method to define mock.On call
//   - log types.Log
func (_e *RBACTimelockInterface_Expecter) ParseRoleGranted(log interface{}) *RBACTimelockInterface_ParseRoleGranted_Call {
	return &RBACTimelockInterface_ParseRoleGranted_Call{Call: _e.mock.On("ParseRoleGranted", log)}
}

func (_c *RBACTimelockInterface_ParseRoleGranted_Call) Run(run func(log types.Log)) *RBACTimelockInterface_ParseRoleGranted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *RBACTimelockInterface_ParseRoleGranted_Call) Return(_a0 *bindings.RBACTimelockRoleGranted, _a1 error) *RBACTimelockInterface_ParseRoleGranted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_ParseRoleGranted_Call) RunAndReturn(run func(types.Log) (*bindings.RBACTimelockRoleGranted, error)) *RBACTimelockInterface_ParseRoleGranted_Call {
	_c.Call.Return(run)
	return _c
}

// ParseRoleRevoked provides a mock function with given fields: log
func (_m *RBACTimelockInterface) ParseRoleRevoked(log types.Log) (*bindings.RBACTimelockRoleRevoked, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseRoleRevoked")
	}

	var r0 *bindings.RBACTimelockRoleRevoked
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.RBACTimelockRoleRevoked, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.RBACTimelockRoleRevoked); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.RBACTimelockRoleRevoked)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_ParseRoleRevoked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseRoleRevoked'
type RBACTimelockInterface_ParseRoleRevoked_Call struct {
	*mock.Call
}

// ParseRoleRevoked is a helper method to define mock.On call
//   - log types.Log
func (_e *RBACTimelockInterface_Expecter) ParseRoleRevoked(log interface{}) *RBACTimelockInterface_ParseRoleRevoked_Call {
	return &RBACTimelockInterface_ParseRoleRevoked_Call{Call: _e.mock.On("ParseRoleRevoked", log)}
}

func (_c *RBACTimelockInterface_ParseRoleRevoked_Call) Run(run func(log types.Log)) *RBACTimelockInterface_ParseRoleRevoked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *RBACTimelockInterface_ParseRoleRevoked_Call) Return(_a0 *bindings.RBACTimelockRoleRevoked, _a1 error) *RBACTimelockInterface_ParseRoleRevoked_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_ParseRoleRevoked_Call) RunAndReturn(run func(types.Log) (*bindings.RBACTimelockRoleRevoked, error)) *RBACTimelockInterface_ParseRoleRevoked_Call {
	_c.Call.Return(run)
	return _c
}

// Receive provides a mock function with given fields: opts
func (_m *RBACTimelockInterface) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Receive")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_Receive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Receive'
type RBACTimelockInterface_Receive_Call struct {
	*mock.Call
}

// Receive is a helper method to define mock.On call
//   - opts *bind.TransactOpts
func (_e *RBACTimelockInterface_Expecter) Receive(opts interface{}) *RBACTimelockInterface_Receive_Call {
	return &RBACTimelockInterface_Receive_Call{Call: _e.mock.On("Receive", opts)}
}

func (_c *RBACTimelockInterface_Receive_Call) Run(run func(opts *bind.TransactOpts)) *RBACTimelockInterface_Receive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts))
	})
	return _c
}

func (_c *RBACTimelockInterface_Receive_Call) Return(_a0 *types.Transaction, _a1 error) *RBACTimelockInterface_Receive_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_Receive_Call) RunAndReturn(run func(*bind.TransactOpts) (*types.Transaction, error)) *RBACTimelockInterface_Receive_Call {
	_c.Call.Return(run)
	return _c
}

// RenounceRole provides a mock function with given fields: opts, role, account
func (_m *RBACTimelockInterface) RenounceRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, role, account)

	if len(ret) == 0 {
		panic("no return value specified for RenounceRole")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, common.Address) (*types.Transaction, error)); ok {
		return rf(opts, role, account)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, common.Address) *types.Transaction); ok {
		r0 = rf(opts, role, account)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [32]byte, common.Address) error); ok {
		r1 = rf(opts, role, account)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_RenounceRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RenounceRole'
type RBACTimelockInterface_RenounceRole_Call struct {
	*mock.Call
}

// RenounceRole is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - role [32]byte
//   - account common.Address
func (_e *RBACTimelockInterface_Expecter) RenounceRole(opts interface{}, role interface{}, account interface{}) *RBACTimelockInterface_RenounceRole_Call {
	return &RBACTimelockInterface_RenounceRole_Call{Call: _e.mock.On("RenounceRole", opts, role, account)}
}

func (_c *RBACTimelockInterface_RenounceRole_Call) Run(run func(opts *bind.TransactOpts, role [32]byte, account common.Address)) *RBACTimelockInterface_RenounceRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([32]byte), args[2].(common.Address))
	})
	return _c
}

func (_c *RBACTimelockInterface_RenounceRole_Call) Return(_a0 *types.Transaction, _a1 error) *RBACTimelockInterface_RenounceRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_RenounceRole_Call) RunAndReturn(run func(*bind.TransactOpts, [32]byte, common.Address) (*types.Transaction, error)) *RBACTimelockInterface_RenounceRole_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeRole provides a mock function with given fields: opts, role, account
func (_m *RBACTimelockInterface) RevokeRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, role, account)

	if len(ret) == 0 {
		panic("no return value specified for RevokeRole")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, common.Address) (*types.Transaction, error)); ok {
		return rf(opts, role, account)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, common.Address) *types.Transaction); ok {
		r0 = rf(opts, role, account)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [32]byte, common.Address) error); ok {
		r1 = rf(opts, role, account)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_RevokeRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeRole'
type RBACTimelockInterface_RevokeRole_Call struct {
	*mock.Call
}

// RevokeRole is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - role [32]byte
//   - account common.Address
func (_e *RBACTimelockInterface_Expecter) RevokeRole(opts interface{}, role interface{}, account interface{}) *RBACTimelockInterface_RevokeRole_Call {
	return &RBACTimelockInterface_RevokeRole_Call{Call: _e.mock.On("RevokeRole", opts, role, account)}
}

func (_c *RBACTimelockInterface_RevokeRole_Call) Run(run func(opts *bind.TransactOpts, role [32]byte, account common.Address)) *RBACTimelockInterface_RevokeRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([32]byte), args[2].(common.Address))
	})
	return _c
}

func (_c *RBACTimelockInterface_RevokeRole_Call) Return(_a0 *types.Transaction, _a1 error) *RBACTimelockInterface_RevokeRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_RevokeRole_Call) RunAndReturn(run func(*bind.TransactOpts, [32]byte, common.Address) (*types.Transaction, error)) *RBACTimelockInterface_RevokeRole_Call {
	_c.Call.Return(run)
	return _c
}

// ScheduleBatch provides a mock function with given fields: opts, calls, predecessor, salt, delay
func (_m *RBACTimelockInterface) ScheduleBatch(opts *bind.TransactOpts, calls []bindings.RBACTimelockCall, predecessor [32]byte, salt [32]byte, delay *big.Int) (*types.Transaction, error) {
	ret := _m.Called(opts, calls, predecessor, salt, delay)

	if len(ret) == 0 {
		panic("no return value specified for ScheduleBatch")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []bindings.RBACTimelockCall, [32]byte, [32]byte, *big.Int) (*types.Transaction, error)); ok {
		return rf(opts, calls, predecessor, salt, delay)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []bindings.RBACTimelockCall, [32]byte, [32]byte, *big.Int) *types.Transaction); ok {
		r0 = rf(opts, calls, predecessor, salt, delay)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []bindings.RBACTimelockCall, [32]byte, [32]byte, *big.Int) error); ok {
		r1 = rf(opts, calls, predecessor, salt, delay)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_ScheduleBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScheduleBatch'
type RBACTimelockInterface_ScheduleBatch_Call struct {
	*mock.Call
}

// ScheduleBatch is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - calls []bindings.RBACTimelockCall
//   - predecessor [32]byte
//   - salt [32]byte
//   - delay *big.Int
func (_e *RBACTimelockInterface_Expecter) ScheduleBatch(opts interface{}, calls interface{}, predecessor interface{}, salt interface{}, delay interface{}) *RBACTimelockInterface_ScheduleBatch_Call {
	return &RBACTimelockInterface_ScheduleBatch_Call{Call: _e.mock.On("ScheduleBatch", opts, calls, predecessor, salt, delay)}
}

func (_c *RBACTimelockInterface_ScheduleBatch_Call) Run(run func(opts *bind.TransactOpts, calls []bindings.RBACTimelockCall, predecessor [32]byte, salt [32]byte, delay *big.Int)) *RBACTimelockInterface_ScheduleBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([]bindings.RBACTimelockCall), args[2].([32]byte), args[3].([32]byte), args[4].(*big.Int))
	})
	return _c
}

func (_c *RBACTimelockInterface_ScheduleBatch_Call) Return(_a0 *types.Transaction, _a1 error) *RBACTimelockInterface_ScheduleBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_ScheduleBatch_Call) RunAndReturn(run func(*bind.TransactOpts, []bindings.RBACTimelockCall, [32]byte, [32]byte, *big.Int) (*types.Transaction, error)) *RBACTimelockInterface_ScheduleBatch_Call {
	_c.Call.Return(run)
	return _c
}

// SupportsInterface provides a mock function with given fields: opts, interfaceId
func (_m *RBACTimelockInterface) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	ret := _m.Called(opts, interfaceId)

	if len(ret) == 0 {
		panic("no return value specified for SupportsInterface")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [4]byte) (bool, error)); ok {
		return rf(opts, interfaceId)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [4]byte) bool); ok {
		r0 = rf(opts, interfaceId)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [4]byte) error); ok {
		r1 = rf(opts, interfaceId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_SupportsInterface_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SupportsInterface'
type RBACTimelockInterface_SupportsInterface_Call struct {
	*mock.Call
}

// SupportsInterface is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - interfaceId [4]byte
func (_e *RBACTimelockInterface_Expecter) SupportsInterface(opts interface{}, interfaceId interface{}) *RBACTimelockInterface_SupportsInterface_Call {
	return &RBACTimelockInterface_SupportsInterface_Call{Call: _e.mock.On("SupportsInterface", opts, interfaceId)}
}

func (_c *RBACTimelockInterface_SupportsInterface_Call) Run(run func(opts *bind.CallOpts, interfaceId [4]byte)) *RBACTimelockInterface_SupportsInterface_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([4]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_SupportsInterface_Call) Return(_a0 bool, _a1 error) *RBACTimelockInterface_SupportsInterface_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_SupportsInterface_Call) RunAndReturn(run func(*bind.CallOpts, [4]byte) (bool, error)) *RBACTimelockInterface_SupportsInterface_Call {
	_c.Call.Return(run)
	return _c
}

// UnblockFunctionSelector provides a mock function with given fields: opts, selector
func (_m *RBACTimelockInterface) UnblockFunctionSelector(opts *bind.TransactOpts, selector [4]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, selector)

	if len(ret) == 0 {
		panic("no return value specified for UnblockFunctionSelector")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [4]byte) (*types.Transaction, error)); ok {
		return rf(opts, selector)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [4]byte) *types.Transaction); ok {
		r0 = rf(opts, selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [4]byte) error); ok {
		r1 = rf(opts, selector)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_UnblockFunctionSelector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnblockFunctionSelector'
type RBACTimelockInterface_UnblockFunctionSelector_Call struct {
	*mock.Call
}

// UnblockFunctionSelector is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - selector [4]byte
func (_e *RBACTimelockInterface_Expecter) UnblockFunctionSelector(opts interface{}, selector interface{}) *RBACTimelockInterface_UnblockFunctionSelector_Call {
	return &RBACTimelockInterface_UnblockFunctionSelector_Call{Call: _e.mock.On("UnblockFunctionSelector", opts, selector)}
}

func (_c *RBACTimelockInterface_UnblockFunctionSelector_Call) Run(run func(opts *bind.TransactOpts, selector [4]byte)) *RBACTimelockInterface_UnblockFunctionSelector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([4]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_UnblockFunctionSelector_Call) Return(_a0 *types.Transaction, _a1 error) *RBACTimelockInterface_UnblockFunctionSelector_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_UnblockFunctionSelector_Call) RunAndReturn(run func(*bind.TransactOpts, [4]byte) (*types.Transaction, error)) *RBACTimelockInterface_UnblockFunctionSelector_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateDelay provides a mock function with given fields: opts, newDelay
func (_m *RBACTimelockInterface) UpdateDelay(opts *bind.TransactOpts, newDelay *big.Int) (*types.Transaction, error) {
	ret := _m.Called(opts, newDelay)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDelay")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int) (*types.Transaction, error)); ok {
		return rf(opts, newDelay)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int) *types.Transaction); ok {
		r0 = rf(opts, newDelay)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int) error); ok {
		r1 = rf(opts, newDelay)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_UpdateDelay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateDelay'
type RBACTimelockInterface_UpdateDelay_Call struct {
	*mock.Call
}

// UpdateDelay is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - newDelay *big.Int
func (_e *RBACTimelockInterface_Expecter) UpdateDelay(opts interface{}, newDelay interface{}) *RBACTimelockInterface_UpdateDelay_Call {
	return &RBACTimelockInterface_UpdateDelay_Call{Call: _e.mock.On("UpdateDelay", opts, newDelay)}
}

func (_c *RBACTimelockInterface_UpdateDelay_Call) Run(run func(opts *bind.TransactOpts, newDelay *big.Int)) *RBACTimelockInterface_UpdateDelay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].(*big.Int))
	})
	return _c
}

func (_c *RBACTimelockInterface_UpdateDelay_Call) Return(_a0 *types.Transaction, _a1 error) *RBACTimelockInterface_UpdateDelay_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_UpdateDelay_Call) RunAndReturn(run func(*bind.TransactOpts, *big.Int) (*types.Transaction, error)) *RBACTimelockInterface_UpdateDelay_Call {
	_c.Call.Return(run)
	return _c
}

// WatchBypasserCallExecuted provides a mock function with given fields: opts, sink, index
func (_m *RBACTimelockInterface) WatchBypasserCallExecuted(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockBypasserCallExecuted, index []*big.Int) (event.Subscription, error) {
	ret := _m.Called(opts, sink, index)

	if len(ret) == 0 {
		panic("no return value specified for WatchBypasserCallExecuted")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockBypasserCallExecuted, []*big.Int) (event.Subscription, error)); ok {
		return rf(opts, sink, index)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockBypasserCallExecuted, []*big.Int) event.Subscription); ok {
		r0 = rf(opts, sink, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockBypasserCallExecuted, []*big.Int) error); ok {
		r1 = rf(opts, sink, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_WatchBypasserCallExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchBypasserCallExecuted'
type RBACTimelockInterface_WatchBypasserCallExecuted_Call struct {
	*mock.Call
}

// WatchBypasserCallExecuted is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.RBACTimelockBypasserCallExecuted
//   - index []*big.Int
func (_e *RBACTimelockInterface_Expecter) WatchBypasserCallExecuted(opts interface{}, sink interface{}, index interface{}) *RBACTimelockInterface_WatchBypasserCallExecuted_Call {
	return &RBACTimelockInterface_WatchBypasserCallExecuted_Call{Call: _e.mock.On("WatchBypasserCallExecuted", opts, sink, index)}
}

func (_c *RBACTimelockInterface_WatchBypasserCallExecuted_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockBypasserCallExecuted, index []*big.Int)) *RBACTimelockInterface_WatchBypasserCallExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.RBACTimelockBypasserCallExecuted), args[2].([]*big.Int))
	})
	return _c
}

func (_c *RBACTimelockInterface_WatchBypasserCallExecuted_Call) Return(_a0 event.Subscription, _a1 error) *RBACTimelockInterface_WatchBypasserCallExecuted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_WatchBypasserCallExecuted_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.RBACTimelockBypasserCallExecuted, []*big.Int) (event.Subscription, error)) *RBACTimelockInterface_WatchBypasserCallExecuted_Call {
	_c.Call.Return(run)
	return _c
}

// WatchCallExecuted provides a mock function with given fields: opts, sink, id, index
func (_m *RBACTimelockInterface) WatchCallExecuted(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockCallExecuted, id [][32]byte, index []*big.Int) (event.Subscription, error) {
	ret := _m.Called(opts, sink, id, index)

	if len(ret) == 0 {
		panic("no return value specified for WatchCallExecuted")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockCallExecuted, [][32]byte, []*big.Int) (event.Subscription, error)); ok {
		return rf(opts, sink, id, index)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockCallExecuted, [][32]byte, []*big.Int) event.Subscription); ok {
		r0 = rf(opts, sink, id, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockCallExecuted, [][32]byte, []*big.Int) error); ok {
		r1 = rf(opts, sink, id, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_WatchCallExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchCallExecuted'
type RBACTimelockInterface_WatchCallExecuted_Call struct {
	*mock.Call
}

// WatchCallExecuted is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.RBACTimelockCallExecuted
//   - id [][32]byte
//   - index []*big.Int
func (_e *RBACTimelockInterface_Expecter) WatchCallExecuted(opts interface{}, sink interface{}, id interface{}, index interface{}) *RBACTimelockInterface_WatchCallExecuted_Call {
	return &RBACTimelockInterface_WatchCallExecuted_Call{Call: _e.mock.On("WatchCallExecuted", opts, sink, id, index)}
}

func (_c *RBACTimelockInterface_WatchCallExecuted_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockCallExecuted, id [][32]byte, index []*big.Int)) *RBACTimelockInterface_WatchCallExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.RBACTimelockCallExecuted), args[2].([][32]byte), args[3].([]*big.Int))
	})
	return _c
}

func (_c *RBACTimelockInterface_WatchCallExecuted_Call) Return(_a0 event.Subscription, _a1 error) *RBACTimelockInterface_WatchCallExecuted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_WatchCallExecuted_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.RBACTimelockCallExecuted, [][32]byte, []*big.Int) (event.Subscription, error)) *RBACTimelockInterface_WatchCallExecuted_Call {
	_c.Call.Return(run)
	return _c
}

// WatchCallScheduled provides a mock function with given fields: opts, sink, id, index
func (_m *RBACTimelockInterface) WatchCallScheduled(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockCallScheduled, id [][32]byte, index []*big.Int) (event.Subscription, error) {
	ret := _m.Called(opts, sink, id, index)

	if len(ret) == 0 {
		panic("no return value specified for WatchCallScheduled")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockCallScheduled, [][32]byte, []*big.Int) (event.Subscription, error)); ok {
		return rf(opts, sink, id, index)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockCallScheduled, [][32]byte, []*big.Int) event.Subscription); ok {
		r0 = rf(opts, sink, id, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockCallScheduled, [][32]byte, []*big.Int) error); ok {
		r1 = rf(opts, sink, id, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_WatchCallScheduled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchCallScheduled'
type RBACTimelockInterface_WatchCallScheduled_Call struct {
	*mock.Call
}

// WatchCallScheduled is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.RBACTimelockCallScheduled
//   - id [][32]byte
//   - index []*big.Int
func (_e *RBACTimelockInterface_Expecter) WatchCallScheduled(opts interface{}, sink interface{}, id interface{}, index interface{}) *RBACTimelockInterface_WatchCallScheduled_Call {
	return &RBACTimelockInterface_WatchCallScheduled_Call{Call: _e.mock.On("WatchCallScheduled", opts, sink, id, index)}
}

func (_c *RBACTimelockInterface_WatchCallScheduled_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockCallScheduled, id [][32]byte, index []*big.Int)) *RBACTimelockInterface_WatchCallScheduled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.RBACTimelockCallScheduled), args[2].([][32]byte), args[3].([]*big.Int))
	})
	return _c
}

func (_c *RBACTimelockInterface_WatchCallScheduled_Call) Return(_a0 event.Subscription, _a1 error) *RBACTimelockInterface_WatchCallScheduled_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_WatchCallScheduled_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.RBACTimelockCallScheduled, [][32]byte, []*big.Int) (event.Subscription, error)) *RBACTimelockInterface_WatchCallScheduled_Call {
	_c.Call.Return(run)
	return _c
}

// WatchCancelled provides a mock function with given fields: opts, sink, id
func (_m *RBACTimelockInterface) WatchCancelled(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockCancelled, id [][32]byte) (event.Subscription, error) {
	ret := _m.Called(opts, sink, id)

	if len(ret) == 0 {
		panic("no return value specified for WatchCancelled")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockCancelled, [][32]byte) (event.Subscription, error)); ok {
		return rf(opts, sink, id)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockCancelled, [][32]byte) event.Subscription); ok {
		r0 = rf(opts, sink, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockCancelled, [][32]byte) error); ok {
		r1 = rf(opts, sink, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_WatchCancelled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchCancelled'
type RBACTimelockInterface_WatchCancelled_Call struct {
	*mock.Call
}

// WatchCancelled is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.RBACTimelockCancelled
//   - id [][32]byte
func (_e *RBACTimelockInterface_Expecter) WatchCancelled(opts interface{}, sink interface{}, id interface{}) *RBACTimelockInterface_WatchCancelled_Call {
	return &RBACTimelockInterface_WatchCancelled_Call{Call: _e.mock.On("WatchCancelled", opts, sink, id)}
}

func (_c *RBACTimelockInterface_WatchCancelled_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockCancelled, id [][32]byte)) *RBACTimelockInterface_WatchCancelled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.RBACTimelockCancelled), args[2].([][32]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_WatchCancelled_Call) Return(_a0 event.Subscription, _a1 error) *RBACTimelockInterface_WatchCancelled_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_WatchCancelled_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.RBACTimelockCancelled, [][32]byte) (event.Subscription, error)) *RBACTimelockInterface_WatchCancelled_Call {
	_c.Call.Return(run)
	return _c
}

// WatchFunctionSelectorBlocked provides a mock function with given fields: opts, sink, selector
func (_m *RBACTimelockInterface) WatchFunctionSelectorBlocked(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockFunctionSelectorBlocked, selector [][4]byte) (event.Subscription, error) {
	ret := _m.Called(opts, sink, selector)

	if len(ret) == 0 {
		panic("no return value specified for WatchFunctionSelectorBlocked")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockFunctionSelectorBlocked, [][4]byte) (event.Subscription, error)); ok {
		return rf(opts, sink, selector)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockFunctionSelectorBlocked, [][4]byte) event.Subscription); ok {
		r0 = rf(opts, sink, selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockFunctionSelectorBlocked, [][4]byte) error); ok {
		r1 = rf(opts, sink, selector)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_WatchFunctionSelectorBlocked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchFunctionSelectorBlocked'
type RBACTimelockInterface_WatchFunctionSelectorBlocked_Call struct {
	*mock.Call
}

// WatchFunctionSelectorBlocked is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.RBACTimelockFunctionSelectorBlocked
//   - selector [][4]byte
func (_e *RBACTimelockInterface_Expecter) WatchFunctionSelectorBlocked(opts interface{}, sink interface{}, selector interface{}) *RBACTimelockInterface_WatchFunctionSelectorBlocked_Call {
	return &RBACTimelockInterface_WatchFunctionSelectorBlocked_Call{Call: _e.mock.On("WatchFunctionSelectorBlocked", opts, sink, selector)}
}

func (_c *RBACTimelockInterface_WatchFunctionSelectorBlocked_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockFunctionSelectorBlocked, selector [][4]byte)) *RBACTimelockInterface_WatchFunctionSelectorBlocked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.RBACTimelockFunctionSelectorBlocked), args[2].([][4]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_WatchFunctionSelectorBlocked_Call) Return(_a0 event.Subscription, _a1 error) *RBACTimelockInterface_WatchFunctionSelectorBlocked_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_WatchFunctionSelectorBlocked_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.RBACTimelockFunctionSelectorBlocked, [][4]byte) (event.Subscription, error)) *RBACTimelockInterface_WatchFunctionSelectorBlocked_Call {
	_c.Call.Return(run)
	return _c
}

// WatchFunctionSelectorUnblocked provides a mock function with given fields: opts, sink, selector
func (_m *RBACTimelockInterface) WatchFunctionSelectorUnblocked(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockFunctionSelectorUnblocked, selector [][4]byte) (event.Subscription, error) {
	ret := _m.Called(opts, sink, selector)

	if len(ret) == 0 {
		panic("no return value specified for WatchFunctionSelectorUnblocked")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockFunctionSelectorUnblocked, [][4]byte) (event.Subscription, error)); ok {
		return rf(opts, sink, selector)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockFunctionSelectorUnblocked, [][4]byte) event.Subscription); ok {
		r0 = rf(opts, sink, selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockFunctionSelectorUnblocked, [][4]byte) error); ok {
		r1 = rf(opts, sink, selector)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_WatchFunctionSelectorUnblocked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchFunctionSelectorUnblocked'
type RBACTimelockInterface_WatchFunctionSelectorUnblocked_Call struct {
	*mock.Call
}

// WatchFunctionSelectorUnblocked is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.RBACTimelockFunctionSelectorUnblocked
//   - selector [][4]byte
func (_e *RBACTimelockInterface_Expecter) WatchFunctionSelectorUnblocked(opts interface{}, sink interface{}, selector interface{}) *RBACTimelockInterface_WatchFunctionSelectorUnblocked_Call {
	return &RBACTimelockInterface_WatchFunctionSelectorUnblocked_Call{Call: _e.mock.On("WatchFunctionSelectorUnblocked", opts, sink, selector)}
}

func (_c *RBACTimelockInterface_WatchFunctionSelectorUnblocked_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockFunctionSelectorUnblocked, selector [][4]byte)) *RBACTimelockInterface_WatchFunctionSelectorUnblocked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.RBACTimelockFunctionSelectorUnblocked), args[2].([][4]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_WatchFunctionSelectorUnblocked_Call) Return(_a0 event.Subscription, _a1 error) *RBACTimelockInterface_WatchFunctionSelectorUnblocked_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_WatchFunctionSelectorUnblocked_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.RBACTimelockFunctionSelectorUnblocked, [][4]byte) (event.Subscription, error)) *RBACTimelockInterface_WatchFunctionSelectorUnblocked_Call {
	_c.Call.Return(run)
	return _c
}

// WatchMinDelayChange provides a mock function with given fields: opts, sink
func (_m *RBACTimelockInterface) WatchMinDelayChange(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockMinDelayChange) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchMinDelayChange")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockMinDelayChange) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockMinDelayChange) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockMinDelayChange) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_WatchMinDelayChange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchMinDelayChange'
type RBACTimelockInterface_WatchMinDelayChange_Call struct {
	*mock.Call
}

// WatchMinDelayChange is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.RBACTimelockMinDelayChange
func (_e *RBACTimelockInterface_Expecter) WatchMinDelayChange(opts interface{}, sink interface{}) *RBACTimelockInterface_WatchMinDelayChange_Call {
	return &RBACTimelockInterface_WatchMinDelayChange_Call{Call: _e.mock.On("WatchMinDelayChange", opts, sink)}
}

func (_c *RBACTimelockInterface_WatchMinDelayChange_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockMinDelayChange)) *RBACTimelockInterface_WatchMinDelayChange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.RBACTimelockMinDelayChange))
	})
	return _c
}

func (_c *RBACTimelockInterface_WatchMinDelayChange_Call) Return(_a0 event.Subscription, _a1 error) *RBACTimelockInterface_WatchMinDelayChange_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_WatchMinDelayChange_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.RBACTimelockMinDelayChange) (event.Subscription, error)) *RBACTimelockInterface_WatchMinDelayChange_Call {
	_c.Call.Return(run)
	return _c
}

// WatchRoleAdminChanged provides a mock function with given fields: opts, sink, role, previousAdminRole, newAdminRole
func (_m *RBACTimelockInterface) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (event.Subscription, error) {
	ret := _m.Called(opts, sink, role, previousAdminRole, newAdminRole)

	if len(ret) == 0 {
		panic("no return value specified for WatchRoleAdminChanged")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockRoleAdminChanged, [][32]byte, [][32]byte, [][32]byte) (event.Subscription, error)); ok {
		return rf(opts, sink, role, previousAdminRole, newAdminRole)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockRoleAdminChanged, [][32]byte, [][32]byte, [][32]byte) event.Subscription); ok {
		r0 = rf(opts, sink, role, previousAdminRole, newAdminRole)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockRoleAdminChanged, [][32]byte, [][32]byte, [][32]byte) error); ok {
		r1 = rf(opts, sink, role, previousAdminRole, newAdminRole)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_WatchRoleAdminChanged_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchRoleAdminChanged'
type RBACTimelockInterface_WatchRoleAdminChanged_Call struct {
	*mock.Call
}

// WatchRoleAdminChanged is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.RBACTimelockRoleAdminChanged
//   - role [][32]byte
//   - previousAdminRole [][32]byte
//   - newAdminRole [][32]byte
func (_e *RBACTimelockInterface_Expecter) WatchRoleAdminChanged(opts interface{}, sink interface{}, role interface{}, previousAdminRole interface{}, newAdminRole interface{}) *RBACTimelockInterface_WatchRoleAdminChanged_Call {
	return &RBACTimelockInterface_WatchRoleAdminChanged_Call{Call: _e.mock.On("WatchRoleAdminChanged", opts, sink, role, previousAdminRole, newAdminRole)}
}

func (_c *RBACTimelockInterface_WatchRoleAdminChanged_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte)) *RBACTimelockInterface_WatchRoleAdminChanged_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.RBACTimelockRoleAdminChanged), args[2].([][32]byte), args[3].([][32]byte), args[4].([][32]byte))
	})
	return _c
}

func (_c *RBACTimelockInterface_WatchRoleAdminChanged_Call) Return(_a0 event.Subscription, _a1 error) *RBACTimelockInterface_WatchRoleAdminChanged_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_WatchRoleAdminChanged_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.RBACTimelockRoleAdminChanged, [][32]byte, [][32]byte, [][32]byte) (event.Subscription, error)) *RBACTimelockInterface_WatchRoleAdminChanged_Call {
	_c.Call.Return(run)
	return _c
}

// WatchRoleGranted provides a mock function with given fields: opts, sink, role, account, sender
func (_m *RBACTimelockInterface) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, role, account, sender)

	if len(ret) == 0 {
		panic("no return value specified for WatchRoleGranted")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockRoleGranted, [][32]byte, []common.Address, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, role, account, sender)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockRoleGranted, [][32]byte, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, role, account, sender)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockRoleGranted, [][32]byte, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, role, account, sender)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_WatchRoleGranted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchRoleGranted'
type RBACTimelockInterface_WatchRoleGranted_Call struct {
	*mock.Call
}

// WatchRoleGranted is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.RBACTimelockRoleGranted
//   - role [][32]byte
//   - account []common.Address
//   - sender []common.Address
func (_e *RBACTimelockInterface_Expecter) WatchRoleGranted(opts interface{}, sink interface{}, role interface{}, account interface{}, sender interface{}) *RBACTimelockInterface_WatchRoleGranted_Call {
	return &RBACTimelockInterface_WatchRoleGranted_Call{Call: _e.mock.On("WatchRoleGranted", opts, sink, role, account, sender)}
}

func (_c *RBACTimelockInterface_WatchRoleGranted_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockRoleGranted, role [][32]byte, account []common.Address, sender []common.Address)) *RBACTimelockInterface_WatchRoleGranted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.RBACTimelockRoleGranted), args[2].([][32]byte), args[3].([]common.Address), args[4].([]common.Address))
	})
	return _c
}

func (_c *RBACTimelockInterface_WatchRoleGranted_Call) Return(_a0 event.Subscription, _a1 error) *RBACTimelockInterface_WatchRoleGranted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_WatchRoleGranted_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.RBACTimelockRoleGranted, [][32]byte, []common.Address, []common.Address) (event.Subscription, error)) *RBACTimelockInterface_WatchRoleGranted_Call {
	_c.Call.Return(run)
	return _c
}

// WatchRoleRevoked provides a mock function with given fields: opts, sink, role, account, sender
func (_m *RBACTimelockInterface) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, role, account, sender)

	if len(ret) == 0 {
		panic("no return value specified for WatchRoleRevoked")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockRoleRevoked, [][32]byte, []common.Address, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, role, account, sender)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockRoleRevoked, [][32]byte, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, role, account, sender)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.RBACTimelockRoleRevoked, [][32]byte, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, role, account, sender)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RBACTimelockInterface_WatchRoleRevoked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchRoleRevoked'
type RBACTimelockInterface_WatchRoleRevoked_Call struct {
	*mock.Call
}

// WatchRoleRevoked is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.RBACTimelockRoleRevoked
//   - role [][32]byte
//   - account []common.Address
//   - sender []common.Address
func (_e *RBACTimelockInterface_Expecter) WatchRoleRevoked(opts interface{}, sink interface{}, role interface{}, account interface{}, sender interface{}) *RBACTimelockInterface_WatchRoleRevoked_Call {
	return &RBACTimelockInterface_WatchRoleRevoked_Call{Call: _e.mock.On("WatchRoleRevoked", opts, sink, role, account, sender)}
}

func (_c *RBACTimelockInterface_WatchRoleRevoked_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.RBACTimelockRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address)) *RBACTimelockInterface_WatchRoleRevoked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.RBACTimelockRoleRevoked), args[2].([][32]byte), args[3].([]common.Address), args[4].([]common.Address))
	})
	return _c
}

func (_c *RBACTimelockInterface_WatchRoleRevoked_Call) Return(_a0 event.Subscription, _a1 error) *RBACTimelockInterface_WatchRoleRevoked_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RBACTimelockInterface_WatchRoleRevoked_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.RBACTimelockRoleRevoked, [][32]byte, []common.Address, []common.Address) (event.Subscription, error)) *RBACTimelockInterface_WatchRoleRevoked_Call {
	_c.Call.Return(run)
	return _c
}

// NewRBACTimelockInterface creates a new instance of RBACTimelockInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRBACTimelockInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *RBACTimelockInterface {
	mock := &RBACTimelockInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

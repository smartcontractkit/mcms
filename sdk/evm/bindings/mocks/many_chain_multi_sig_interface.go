// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	big "math/big"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"
	bindings "github.com/smartcontractkit/mcms/sdk/evm/bindings"

	common "github.com/ethereum/go-ethereum/common"

	event "github.com/ethereum/go-ethereum/event"

	mock "github.com/stretchr/testify/mock"

	types "github.com/ethereum/go-ethereum/core/types"
)

// ManyChainMultiSigInterface is an autogenerated mock type for the ManyChainMultiSigInterface type
type ManyChainMultiSigInterface struct {
	mock.Mock
}

type ManyChainMultiSigInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *ManyChainMultiSigInterface) EXPECT() *ManyChainMultiSigInterface_Expecter {
	return &ManyChainMultiSigInterface_Expecter{mock: &_m.Mock}
}

// AcceptOwnership provides a mock function with given fields: opts
func (_m *ManyChainMultiSigInterface) AcceptOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for AcceptOwnership")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_AcceptOwnership_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AcceptOwnership'
type ManyChainMultiSigInterface_AcceptOwnership_Call struct {
	*mock.Call
}

// AcceptOwnership is a helper method to define mock.On call
//   - opts *bind.TransactOpts
func (_e *ManyChainMultiSigInterface_Expecter) AcceptOwnership(opts interface{}) *ManyChainMultiSigInterface_AcceptOwnership_Call {
	return &ManyChainMultiSigInterface_AcceptOwnership_Call{Call: _e.mock.On("AcceptOwnership", opts)}
}

func (_c *ManyChainMultiSigInterface_AcceptOwnership_Call) Run(run func(opts *bind.TransactOpts)) *ManyChainMultiSigInterface_AcceptOwnership_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_AcceptOwnership_Call) Return(_a0 *types.Transaction, _a1 error) *ManyChainMultiSigInterface_AcceptOwnership_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_AcceptOwnership_Call) RunAndReturn(run func(*bind.TransactOpts) (*types.Transaction, error)) *ManyChainMultiSigInterface_AcceptOwnership_Call {
	_c.Call.Return(run)
	return _c
}

// Address provides a mock function with no fields
func (_m *ManyChainMultiSigInterface) Address() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Address")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// ManyChainMultiSigInterface_Address_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Address'
type ManyChainMultiSigInterface_Address_Call struct {
	*mock.Call
}

// Address is a helper method to define mock.On call
func (_e *ManyChainMultiSigInterface_Expecter) Address() *ManyChainMultiSigInterface_Address_Call {
	return &ManyChainMultiSigInterface_Address_Call{Call: _e.mock.On("Address")}
}

func (_c *ManyChainMultiSigInterface_Address_Call) Run(run func()) *ManyChainMultiSigInterface_Address_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_Address_Call) Return(_a0 common.Address) *ManyChainMultiSigInterface_Address_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ManyChainMultiSigInterface_Address_Call) RunAndReturn(run func() common.Address) *ManyChainMultiSigInterface_Address_Call {
	_c.Call.Return(run)
	return _c
}

// Execute provides a mock function with given fields: opts, op, proof
func (_m *ManyChainMultiSigInterface) Execute(opts *bind.TransactOpts, op bindings.ManyChainMultiSigOp, proof [][32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, op, proof)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, bindings.ManyChainMultiSigOp, [][32]byte) (*types.Transaction, error)); ok {
		return rf(opts, op, proof)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, bindings.ManyChainMultiSigOp, [][32]byte) *types.Transaction); ok {
		r0 = rf(opts, op, proof)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, bindings.ManyChainMultiSigOp, [][32]byte) error); ok {
		r1 = rf(opts, op, proof)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type ManyChainMultiSigInterface_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - op bindings.ManyChainMultiSigOp
//   - proof [][32]byte
func (_e *ManyChainMultiSigInterface_Expecter) Execute(opts interface{}, op interface{}, proof interface{}) *ManyChainMultiSigInterface_Execute_Call {
	return &ManyChainMultiSigInterface_Execute_Call{Call: _e.mock.On("Execute", opts, op, proof)}
}

func (_c *ManyChainMultiSigInterface_Execute_Call) Run(run func(opts *bind.TransactOpts, op bindings.ManyChainMultiSigOp, proof [][32]byte)) *ManyChainMultiSigInterface_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].(bindings.ManyChainMultiSigOp), args[2].([][32]byte))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_Execute_Call) Return(_a0 *types.Transaction, _a1 error) *ManyChainMultiSigInterface_Execute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_Execute_Call) RunAndReturn(run func(*bind.TransactOpts, bindings.ManyChainMultiSigOp, [][32]byte) (*types.Transaction, error)) *ManyChainMultiSigInterface_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// FilterConfigSet provides a mock function with given fields: opts
func (_m *ManyChainMultiSigInterface) FilterConfigSet(opts *bind.FilterOpts) (*bindings.ManyChainMultiSigConfigSetIterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterConfigSet")
	}

	var r0 *bindings.ManyChainMultiSigConfigSetIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*bindings.ManyChainMultiSigConfigSetIterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *bindings.ManyChainMultiSigConfigSetIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.ManyChainMultiSigConfigSetIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_FilterConfigSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterConfigSet'
type ManyChainMultiSigInterface_FilterConfigSet_Call struct {
	*mock.Call
}

// FilterConfigSet is a helper method to define mock.On call
//   - opts *bind.FilterOpts
func (_e *ManyChainMultiSigInterface_Expecter) FilterConfigSet(opts interface{}) *ManyChainMultiSigInterface_FilterConfigSet_Call {
	return &ManyChainMultiSigInterface_FilterConfigSet_Call{Call: _e.mock.On("FilterConfigSet", opts)}
}

func (_c *ManyChainMultiSigInterface_FilterConfigSet_Call) Run(run func(opts *bind.FilterOpts)) *ManyChainMultiSigInterface_FilterConfigSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_FilterConfigSet_Call) Return(_a0 *bindings.ManyChainMultiSigConfigSetIterator, _a1 error) *ManyChainMultiSigInterface_FilterConfigSet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_FilterConfigSet_Call) RunAndReturn(run func(*bind.FilterOpts) (*bindings.ManyChainMultiSigConfigSetIterator, error)) *ManyChainMultiSigInterface_FilterConfigSet_Call {
	_c.Call.Return(run)
	return _c
}

// FilterNewRoot provides a mock function with given fields: opts, root
func (_m *ManyChainMultiSigInterface) FilterNewRoot(opts *bind.FilterOpts, root [][32]byte) (*bindings.ManyChainMultiSigNewRootIterator, error) {
	ret := _m.Called(opts, root)

	if len(ret) == 0 {
		panic("no return value specified for FilterNewRoot")
	}

	var r0 *bindings.ManyChainMultiSigNewRootIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte) (*bindings.ManyChainMultiSigNewRootIterator, error)); ok {
		return rf(opts, root)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte) *bindings.ManyChainMultiSigNewRootIterator); ok {
		r0 = rf(opts, root)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.ManyChainMultiSigNewRootIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte) error); ok {
		r1 = rf(opts, root)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_FilterNewRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterNewRoot'
type ManyChainMultiSigInterface_FilterNewRoot_Call struct {
	*mock.Call
}

// FilterNewRoot is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - root [][32]byte
func (_e *ManyChainMultiSigInterface_Expecter) FilterNewRoot(opts interface{}, root interface{}) *ManyChainMultiSigInterface_FilterNewRoot_Call {
	return &ManyChainMultiSigInterface_FilterNewRoot_Call{Call: _e.mock.On("FilterNewRoot", opts, root)}
}

func (_c *ManyChainMultiSigInterface_FilterNewRoot_Call) Run(run func(opts *bind.FilterOpts, root [][32]byte)) *ManyChainMultiSigInterface_FilterNewRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_FilterNewRoot_Call) Return(_a0 *bindings.ManyChainMultiSigNewRootIterator, _a1 error) *ManyChainMultiSigInterface_FilterNewRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_FilterNewRoot_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte) (*bindings.ManyChainMultiSigNewRootIterator, error)) *ManyChainMultiSigInterface_FilterNewRoot_Call {
	_c.Call.Return(run)
	return _c
}

// FilterOpExecuted provides a mock function with given fields: opts, nonce
func (_m *ManyChainMultiSigInterface) FilterOpExecuted(opts *bind.FilterOpts, nonce []*big.Int) (*bindings.ManyChainMultiSigOpExecutedIterator, error) {
	ret := _m.Called(opts, nonce)

	if len(ret) == 0 {
		panic("no return value specified for FilterOpExecuted")
	}

	var r0 *bindings.ManyChainMultiSigOpExecutedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []*big.Int) (*bindings.ManyChainMultiSigOpExecutedIterator, error)); ok {
		return rf(opts, nonce)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []*big.Int) *bindings.ManyChainMultiSigOpExecutedIterator); ok {
		r0 = rf(opts, nonce)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.ManyChainMultiSigOpExecutedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []*big.Int) error); ok {
		r1 = rf(opts, nonce)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_FilterOpExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterOpExecuted'
type ManyChainMultiSigInterface_FilterOpExecuted_Call struct {
	*mock.Call
}

// FilterOpExecuted is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - nonce []*big.Int
func (_e *ManyChainMultiSigInterface_Expecter) FilterOpExecuted(opts interface{}, nonce interface{}) *ManyChainMultiSigInterface_FilterOpExecuted_Call {
	return &ManyChainMultiSigInterface_FilterOpExecuted_Call{Call: _e.mock.On("FilterOpExecuted", opts, nonce)}
}

func (_c *ManyChainMultiSigInterface_FilterOpExecuted_Call) Run(run func(opts *bind.FilterOpts, nonce []*big.Int)) *ManyChainMultiSigInterface_FilterOpExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]*big.Int))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_FilterOpExecuted_Call) Return(_a0 *bindings.ManyChainMultiSigOpExecutedIterator, _a1 error) *ManyChainMultiSigInterface_FilterOpExecuted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_FilterOpExecuted_Call) RunAndReturn(run func(*bind.FilterOpts, []*big.Int) (*bindings.ManyChainMultiSigOpExecutedIterator, error)) *ManyChainMultiSigInterface_FilterOpExecuted_Call {
	_c.Call.Return(run)
	return _c
}

// FilterOwnershipTransferStarted provides a mock function with given fields: opts, previousOwner, newOwner
func (_m *ManyChainMultiSigInterface) FilterOwnershipTransferStarted(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*bindings.ManyChainMultiSigOwnershipTransferStartedIterator, error) {
	ret := _m.Called(opts, previousOwner, newOwner)

	if len(ret) == 0 {
		panic("no return value specified for FilterOwnershipTransferStarted")
	}

	var r0 *bindings.ManyChainMultiSigOwnershipTransferStartedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) (*bindings.ManyChainMultiSigOwnershipTransferStartedIterator, error)); ok {
		return rf(opts, previousOwner, newOwner)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *bindings.ManyChainMultiSigOwnershipTransferStartedIterator); ok {
		r0 = rf(opts, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.ManyChainMultiSigOwnershipTransferStartedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_FilterOwnershipTransferStarted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterOwnershipTransferStarted'
type ManyChainMultiSigInterface_FilterOwnershipTransferStarted_Call struct {
	*mock.Call
}

// FilterOwnershipTransferStarted is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - previousOwner []common.Address
//   - newOwner []common.Address
func (_e *ManyChainMultiSigInterface_Expecter) FilterOwnershipTransferStarted(opts interface{}, previousOwner interface{}, newOwner interface{}) *ManyChainMultiSigInterface_FilterOwnershipTransferStarted_Call {
	return &ManyChainMultiSigInterface_FilterOwnershipTransferStarted_Call{Call: _e.mock.On("FilterOwnershipTransferStarted", opts, previousOwner, newOwner)}
}

func (_c *ManyChainMultiSigInterface_FilterOwnershipTransferStarted_Call) Run(run func(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address)) *ManyChainMultiSigInterface_FilterOwnershipTransferStarted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]common.Address), args[2].([]common.Address))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_FilterOwnershipTransferStarted_Call) Return(_a0 *bindings.ManyChainMultiSigOwnershipTransferStartedIterator, _a1 error) *ManyChainMultiSigInterface_FilterOwnershipTransferStarted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_FilterOwnershipTransferStarted_Call) RunAndReturn(run func(*bind.FilterOpts, []common.Address, []common.Address) (*bindings.ManyChainMultiSigOwnershipTransferStartedIterator, error)) *ManyChainMultiSigInterface_FilterOwnershipTransferStarted_Call {
	_c.Call.Return(run)
	return _c
}

// FilterOwnershipTransferred provides a mock function with given fields: opts, previousOwner, newOwner
func (_m *ManyChainMultiSigInterface) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*bindings.ManyChainMultiSigOwnershipTransferredIterator, error) {
	ret := _m.Called(opts, previousOwner, newOwner)

	if len(ret) == 0 {
		panic("no return value specified for FilterOwnershipTransferred")
	}

	var r0 *bindings.ManyChainMultiSigOwnershipTransferredIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) (*bindings.ManyChainMultiSigOwnershipTransferredIterator, error)); ok {
		return rf(opts, previousOwner, newOwner)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *bindings.ManyChainMultiSigOwnershipTransferredIterator); ok {
		r0 = rf(opts, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.ManyChainMultiSigOwnershipTransferredIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_FilterOwnershipTransferred_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterOwnershipTransferred'
type ManyChainMultiSigInterface_FilterOwnershipTransferred_Call struct {
	*mock.Call
}

// FilterOwnershipTransferred is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - previousOwner []common.Address
//   - newOwner []common.Address
func (_e *ManyChainMultiSigInterface_Expecter) FilterOwnershipTransferred(opts interface{}, previousOwner interface{}, newOwner interface{}) *ManyChainMultiSigInterface_FilterOwnershipTransferred_Call {
	return &ManyChainMultiSigInterface_FilterOwnershipTransferred_Call{Call: _e.mock.On("FilterOwnershipTransferred", opts, previousOwner, newOwner)}
}

func (_c *ManyChainMultiSigInterface_FilterOwnershipTransferred_Call) Run(run func(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address)) *ManyChainMultiSigInterface_FilterOwnershipTransferred_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]common.Address), args[2].([]common.Address))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_FilterOwnershipTransferred_Call) Return(_a0 *bindings.ManyChainMultiSigOwnershipTransferredIterator, _a1 error) *ManyChainMultiSigInterface_FilterOwnershipTransferred_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_FilterOwnershipTransferred_Call) RunAndReturn(run func(*bind.FilterOpts, []common.Address, []common.Address) (*bindings.ManyChainMultiSigOwnershipTransferredIterator, error)) *ManyChainMultiSigInterface_FilterOwnershipTransferred_Call {
	_c.Call.Return(run)
	return _c
}

// GetConfig provides a mock function with given fields: opts
func (_m *ManyChainMultiSigInterface) GetConfig(opts *bind.CallOpts) (bindings.ManyChainMultiSigConfig, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetConfig")
	}

	var r0 bindings.ManyChainMultiSigConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (bindings.ManyChainMultiSigConfig, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) bindings.ManyChainMultiSigConfig); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(bindings.ManyChainMultiSigConfig)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_GetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConfig'
type ManyChainMultiSigInterface_GetConfig_Call struct {
	*mock.Call
}

// GetConfig is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *ManyChainMultiSigInterface_Expecter) GetConfig(opts interface{}) *ManyChainMultiSigInterface_GetConfig_Call {
	return &ManyChainMultiSigInterface_GetConfig_Call{Call: _e.mock.On("GetConfig", opts)}
}

func (_c *ManyChainMultiSigInterface_GetConfig_Call) Run(run func(opts *bind.CallOpts)) *ManyChainMultiSigInterface_GetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_GetConfig_Call) Return(_a0 bindings.ManyChainMultiSigConfig, _a1 error) *ManyChainMultiSigInterface_GetConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_GetConfig_Call) RunAndReturn(run func(*bind.CallOpts) (bindings.ManyChainMultiSigConfig, error)) *ManyChainMultiSigInterface_GetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetOpCount provides a mock function with given fields: opts
func (_m *ManyChainMultiSigInterface) GetOpCount(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetOpCount")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_GetOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOpCount'
type ManyChainMultiSigInterface_GetOpCount_Call struct {
	*mock.Call
}

// GetOpCount is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *ManyChainMultiSigInterface_Expecter) GetOpCount(opts interface{}) *ManyChainMultiSigInterface_GetOpCount_Call {
	return &ManyChainMultiSigInterface_GetOpCount_Call{Call: _e.mock.On("GetOpCount", opts)}
}

func (_c *ManyChainMultiSigInterface_GetOpCount_Call) Run(run func(opts *bind.CallOpts)) *ManyChainMultiSigInterface_GetOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_GetOpCount_Call) Return(_a0 *big.Int, _a1 error) *ManyChainMultiSigInterface_GetOpCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_GetOpCount_Call) RunAndReturn(run func(*bind.CallOpts) (*big.Int, error)) *ManyChainMultiSigInterface_GetOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoot provides a mock function with given fields: opts
func (_m *ManyChainMultiSigInterface) GetRoot(opts *bind.CallOpts) (bindings.GetRoot, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetRoot")
	}

	var r0 bindings.GetRoot
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (bindings.GetRoot, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) bindings.GetRoot); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(bindings.GetRoot)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_GetRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoot'
type ManyChainMultiSigInterface_GetRoot_Call struct {
	*mock.Call
}

// GetRoot is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *ManyChainMultiSigInterface_Expecter) GetRoot(opts interface{}) *ManyChainMultiSigInterface_GetRoot_Call {
	return &ManyChainMultiSigInterface_GetRoot_Call{Call: _e.mock.On("GetRoot", opts)}
}

func (_c *ManyChainMultiSigInterface_GetRoot_Call) Run(run func(opts *bind.CallOpts)) *ManyChainMultiSigInterface_GetRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_GetRoot_Call) Return(_a0 bindings.GetRoot, _a1 error) *ManyChainMultiSigInterface_GetRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_GetRoot_Call) RunAndReturn(run func(*bind.CallOpts) (bindings.GetRoot, error)) *ManyChainMultiSigInterface_GetRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetRootMetadata provides a mock function with given fields: opts
func (_m *ManyChainMultiSigInterface) GetRootMetadata(opts *bind.CallOpts) (bindings.ManyChainMultiSigRootMetadata, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetRootMetadata")
	}

	var r0 bindings.ManyChainMultiSigRootMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (bindings.ManyChainMultiSigRootMetadata, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) bindings.ManyChainMultiSigRootMetadata); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(bindings.ManyChainMultiSigRootMetadata)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_GetRootMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRootMetadata'
type ManyChainMultiSigInterface_GetRootMetadata_Call struct {
	*mock.Call
}

// GetRootMetadata is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *ManyChainMultiSigInterface_Expecter) GetRootMetadata(opts interface{}) *ManyChainMultiSigInterface_GetRootMetadata_Call {
	return &ManyChainMultiSigInterface_GetRootMetadata_Call{Call: _e.mock.On("GetRootMetadata", opts)}
}

func (_c *ManyChainMultiSigInterface_GetRootMetadata_Call) Run(run func(opts *bind.CallOpts)) *ManyChainMultiSigInterface_GetRootMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_GetRootMetadata_Call) Return(_a0 bindings.ManyChainMultiSigRootMetadata, _a1 error) *ManyChainMultiSigInterface_GetRootMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_GetRootMetadata_Call) RunAndReturn(run func(*bind.CallOpts) (bindings.ManyChainMultiSigRootMetadata, error)) *ManyChainMultiSigInterface_GetRootMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// MAXNUMSIGNERS provides a mock function with given fields: opts
func (_m *ManyChainMultiSigInterface) MAXNUMSIGNERS(opts *bind.CallOpts) (uint8, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for MAXNUMSIGNERS")
	}

	var r0 uint8
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint8, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint8); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint8)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_MAXNUMSIGNERS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MAXNUMSIGNERS'
type ManyChainMultiSigInterface_MAXNUMSIGNERS_Call struct {
	*mock.Call
}

// MAXNUMSIGNERS is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *ManyChainMultiSigInterface_Expecter) MAXNUMSIGNERS(opts interface{}) *ManyChainMultiSigInterface_MAXNUMSIGNERS_Call {
	return &ManyChainMultiSigInterface_MAXNUMSIGNERS_Call{Call: _e.mock.On("MAXNUMSIGNERS", opts)}
}

func (_c *ManyChainMultiSigInterface_MAXNUMSIGNERS_Call) Run(run func(opts *bind.CallOpts)) *ManyChainMultiSigInterface_MAXNUMSIGNERS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_MAXNUMSIGNERS_Call) Return(_a0 uint8, _a1 error) *ManyChainMultiSigInterface_MAXNUMSIGNERS_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_MAXNUMSIGNERS_Call) RunAndReturn(run func(*bind.CallOpts) (uint8, error)) *ManyChainMultiSigInterface_MAXNUMSIGNERS_Call {
	_c.Call.Return(run)
	return _c
}

// NUMGROUPS provides a mock function with given fields: opts
func (_m *ManyChainMultiSigInterface) NUMGROUPS(opts *bind.CallOpts) (uint8, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for NUMGROUPS")
	}

	var r0 uint8
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint8, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint8); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint8)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_NUMGROUPS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NUMGROUPS'
type ManyChainMultiSigInterface_NUMGROUPS_Call struct {
	*mock.Call
}

// NUMGROUPS is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *ManyChainMultiSigInterface_Expecter) NUMGROUPS(opts interface{}) *ManyChainMultiSigInterface_NUMGROUPS_Call {
	return &ManyChainMultiSigInterface_NUMGROUPS_Call{Call: _e.mock.On("NUMGROUPS", opts)}
}

func (_c *ManyChainMultiSigInterface_NUMGROUPS_Call) Run(run func(opts *bind.CallOpts)) *ManyChainMultiSigInterface_NUMGROUPS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_NUMGROUPS_Call) Return(_a0 uint8, _a1 error) *ManyChainMultiSigInterface_NUMGROUPS_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_NUMGROUPS_Call) RunAndReturn(run func(*bind.CallOpts) (uint8, error)) *ManyChainMultiSigInterface_NUMGROUPS_Call {
	_c.Call.Return(run)
	return _c
}

// Owner provides a mock function with given fields: opts
func (_m *ManyChainMultiSigInterface) Owner(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Owner")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_Owner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Owner'
type ManyChainMultiSigInterface_Owner_Call struct {
	*mock.Call
}

// Owner is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *ManyChainMultiSigInterface_Expecter) Owner(opts interface{}) *ManyChainMultiSigInterface_Owner_Call {
	return &ManyChainMultiSigInterface_Owner_Call{Call: _e.mock.On("Owner", opts)}
}

func (_c *ManyChainMultiSigInterface_Owner_Call) Run(run func(opts *bind.CallOpts)) *ManyChainMultiSigInterface_Owner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_Owner_Call) Return(_a0 common.Address, _a1 error) *ManyChainMultiSigInterface_Owner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_Owner_Call) RunAndReturn(run func(*bind.CallOpts) (common.Address, error)) *ManyChainMultiSigInterface_Owner_Call {
	_c.Call.Return(run)
	return _c
}

// ParseConfigSet provides a mock function with given fields: log
func (_m *ManyChainMultiSigInterface) ParseConfigSet(log types.Log) (*bindings.ManyChainMultiSigConfigSet, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseConfigSet")
	}

	var r0 *bindings.ManyChainMultiSigConfigSet
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.ManyChainMultiSigConfigSet, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.ManyChainMultiSigConfigSet); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.ManyChainMultiSigConfigSet)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_ParseConfigSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseConfigSet'
type ManyChainMultiSigInterface_ParseConfigSet_Call struct {
	*mock.Call
}

// ParseConfigSet is a helper method to define mock.On call
//   - log types.Log
func (_e *ManyChainMultiSigInterface_Expecter) ParseConfigSet(log interface{}) *ManyChainMultiSigInterface_ParseConfigSet_Call {
	return &ManyChainMultiSigInterface_ParseConfigSet_Call{Call: _e.mock.On("ParseConfigSet", log)}
}

func (_c *ManyChainMultiSigInterface_ParseConfigSet_Call) Run(run func(log types.Log)) *ManyChainMultiSigInterface_ParseConfigSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_ParseConfigSet_Call) Return(_a0 *bindings.ManyChainMultiSigConfigSet, _a1 error) *ManyChainMultiSigInterface_ParseConfigSet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_ParseConfigSet_Call) RunAndReturn(run func(types.Log) (*bindings.ManyChainMultiSigConfigSet, error)) *ManyChainMultiSigInterface_ParseConfigSet_Call {
	_c.Call.Return(run)
	return _c
}

// ParseLog provides a mock function with given fields: log
func (_m *ManyChainMultiSigInterface) ParseLog(log types.Log) (bindings.AbigenLog, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseLog")
	}

	var r0 bindings.AbigenLog
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (bindings.AbigenLog, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) bindings.AbigenLog); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(bindings.AbigenLog)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_ParseLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseLog'
type ManyChainMultiSigInterface_ParseLog_Call struct {
	*mock.Call
}

// ParseLog is a helper method to define mock.On call
//   - log types.Log
func (_e *ManyChainMultiSigInterface_Expecter) ParseLog(log interface{}) *ManyChainMultiSigInterface_ParseLog_Call {
	return &ManyChainMultiSigInterface_ParseLog_Call{Call: _e.mock.On("ParseLog", log)}
}

func (_c *ManyChainMultiSigInterface_ParseLog_Call) Run(run func(log types.Log)) *ManyChainMultiSigInterface_ParseLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_ParseLog_Call) Return(_a0 bindings.AbigenLog, _a1 error) *ManyChainMultiSigInterface_ParseLog_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_ParseLog_Call) RunAndReturn(run func(types.Log) (bindings.AbigenLog, error)) *ManyChainMultiSigInterface_ParseLog_Call {
	_c.Call.Return(run)
	return _c
}

// ParseNewRoot provides a mock function with given fields: log
func (_m *ManyChainMultiSigInterface) ParseNewRoot(log types.Log) (*bindings.ManyChainMultiSigNewRoot, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseNewRoot")
	}

	var r0 *bindings.ManyChainMultiSigNewRoot
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.ManyChainMultiSigNewRoot, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.ManyChainMultiSigNewRoot); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.ManyChainMultiSigNewRoot)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_ParseNewRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseNewRoot'
type ManyChainMultiSigInterface_ParseNewRoot_Call struct {
	*mock.Call
}

// ParseNewRoot is a helper method to define mock.On call
//   - log types.Log
func (_e *ManyChainMultiSigInterface_Expecter) ParseNewRoot(log interface{}) *ManyChainMultiSigInterface_ParseNewRoot_Call {
	return &ManyChainMultiSigInterface_ParseNewRoot_Call{Call: _e.mock.On("ParseNewRoot", log)}
}

func (_c *ManyChainMultiSigInterface_ParseNewRoot_Call) Run(run func(log types.Log)) *ManyChainMultiSigInterface_ParseNewRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_ParseNewRoot_Call) Return(_a0 *bindings.ManyChainMultiSigNewRoot, _a1 error) *ManyChainMultiSigInterface_ParseNewRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_ParseNewRoot_Call) RunAndReturn(run func(types.Log) (*bindings.ManyChainMultiSigNewRoot, error)) *ManyChainMultiSigInterface_ParseNewRoot_Call {
	_c.Call.Return(run)
	return _c
}

// ParseOpExecuted provides a mock function with given fields: log
func (_m *ManyChainMultiSigInterface) ParseOpExecuted(log types.Log) (*bindings.ManyChainMultiSigOpExecuted, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseOpExecuted")
	}

	var r0 *bindings.ManyChainMultiSigOpExecuted
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.ManyChainMultiSigOpExecuted, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.ManyChainMultiSigOpExecuted); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.ManyChainMultiSigOpExecuted)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_ParseOpExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseOpExecuted'
type ManyChainMultiSigInterface_ParseOpExecuted_Call struct {
	*mock.Call
}

// ParseOpExecuted is a helper method to define mock.On call
//   - log types.Log
func (_e *ManyChainMultiSigInterface_Expecter) ParseOpExecuted(log interface{}) *ManyChainMultiSigInterface_ParseOpExecuted_Call {
	return &ManyChainMultiSigInterface_ParseOpExecuted_Call{Call: _e.mock.On("ParseOpExecuted", log)}
}

func (_c *ManyChainMultiSigInterface_ParseOpExecuted_Call) Run(run func(log types.Log)) *ManyChainMultiSigInterface_ParseOpExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_ParseOpExecuted_Call) Return(_a0 *bindings.ManyChainMultiSigOpExecuted, _a1 error) *ManyChainMultiSigInterface_ParseOpExecuted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_ParseOpExecuted_Call) RunAndReturn(run func(types.Log) (*bindings.ManyChainMultiSigOpExecuted, error)) *ManyChainMultiSigInterface_ParseOpExecuted_Call {
	_c.Call.Return(run)
	return _c
}

// ParseOwnershipTransferStarted provides a mock function with given fields: log
func (_m *ManyChainMultiSigInterface) ParseOwnershipTransferStarted(log types.Log) (*bindings.ManyChainMultiSigOwnershipTransferStarted, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseOwnershipTransferStarted")
	}

	var r0 *bindings.ManyChainMultiSigOwnershipTransferStarted
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.ManyChainMultiSigOwnershipTransferStarted, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.ManyChainMultiSigOwnershipTransferStarted); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.ManyChainMultiSigOwnershipTransferStarted)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_ParseOwnershipTransferStarted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseOwnershipTransferStarted'
type ManyChainMultiSigInterface_ParseOwnershipTransferStarted_Call struct {
	*mock.Call
}

// ParseOwnershipTransferStarted is a helper method to define mock.On call
//   - log types.Log
func (_e *ManyChainMultiSigInterface_Expecter) ParseOwnershipTransferStarted(log interface{}) *ManyChainMultiSigInterface_ParseOwnershipTransferStarted_Call {
	return &ManyChainMultiSigInterface_ParseOwnershipTransferStarted_Call{Call: _e.mock.On("ParseOwnershipTransferStarted", log)}
}

func (_c *ManyChainMultiSigInterface_ParseOwnershipTransferStarted_Call) Run(run func(log types.Log)) *ManyChainMultiSigInterface_ParseOwnershipTransferStarted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_ParseOwnershipTransferStarted_Call) Return(_a0 *bindings.ManyChainMultiSigOwnershipTransferStarted, _a1 error) *ManyChainMultiSigInterface_ParseOwnershipTransferStarted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_ParseOwnershipTransferStarted_Call) RunAndReturn(run func(types.Log) (*bindings.ManyChainMultiSigOwnershipTransferStarted, error)) *ManyChainMultiSigInterface_ParseOwnershipTransferStarted_Call {
	_c.Call.Return(run)
	return _c
}

// ParseOwnershipTransferred provides a mock function with given fields: log
func (_m *ManyChainMultiSigInterface) ParseOwnershipTransferred(log types.Log) (*bindings.ManyChainMultiSigOwnershipTransferred, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseOwnershipTransferred")
	}

	var r0 *bindings.ManyChainMultiSigOwnershipTransferred
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*bindings.ManyChainMultiSigOwnershipTransferred, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *bindings.ManyChainMultiSigOwnershipTransferred); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bindings.ManyChainMultiSigOwnershipTransferred)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_ParseOwnershipTransferred_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseOwnershipTransferred'
type ManyChainMultiSigInterface_ParseOwnershipTransferred_Call struct {
	*mock.Call
}

// ParseOwnershipTransferred is a helper method to define mock.On call
//   - log types.Log
func (_e *ManyChainMultiSigInterface_Expecter) ParseOwnershipTransferred(log interface{}) *ManyChainMultiSigInterface_ParseOwnershipTransferred_Call {
	return &ManyChainMultiSigInterface_ParseOwnershipTransferred_Call{Call: _e.mock.On("ParseOwnershipTransferred", log)}
}

func (_c *ManyChainMultiSigInterface_ParseOwnershipTransferred_Call) Run(run func(log types.Log)) *ManyChainMultiSigInterface_ParseOwnershipTransferred_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_ParseOwnershipTransferred_Call) Return(_a0 *bindings.ManyChainMultiSigOwnershipTransferred, _a1 error) *ManyChainMultiSigInterface_ParseOwnershipTransferred_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_ParseOwnershipTransferred_Call) RunAndReturn(run func(types.Log) (*bindings.ManyChainMultiSigOwnershipTransferred, error)) *ManyChainMultiSigInterface_ParseOwnershipTransferred_Call {
	_c.Call.Return(run)
	return _c
}

// PendingOwner provides a mock function with given fields: opts
func (_m *ManyChainMultiSigInterface) PendingOwner(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for PendingOwner")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_PendingOwner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PendingOwner'
type ManyChainMultiSigInterface_PendingOwner_Call struct {
	*mock.Call
}

// PendingOwner is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *ManyChainMultiSigInterface_Expecter) PendingOwner(opts interface{}) *ManyChainMultiSigInterface_PendingOwner_Call {
	return &ManyChainMultiSigInterface_PendingOwner_Call{Call: _e.mock.On("PendingOwner", opts)}
}

func (_c *ManyChainMultiSigInterface_PendingOwner_Call) Run(run func(opts *bind.CallOpts)) *ManyChainMultiSigInterface_PendingOwner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_PendingOwner_Call) Return(_a0 common.Address, _a1 error) *ManyChainMultiSigInterface_PendingOwner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_PendingOwner_Call) RunAndReturn(run func(*bind.CallOpts) (common.Address, error)) *ManyChainMultiSigInterface_PendingOwner_Call {
	_c.Call.Return(run)
	return _c
}

// Receive provides a mock function with given fields: opts
func (_m *ManyChainMultiSigInterface) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Receive")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_Receive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Receive'
type ManyChainMultiSigInterface_Receive_Call struct {
	*mock.Call
}

// Receive is a helper method to define mock.On call
//   - opts *bind.TransactOpts
func (_e *ManyChainMultiSigInterface_Expecter) Receive(opts interface{}) *ManyChainMultiSigInterface_Receive_Call {
	return &ManyChainMultiSigInterface_Receive_Call{Call: _e.mock.On("Receive", opts)}
}

func (_c *ManyChainMultiSigInterface_Receive_Call) Run(run func(opts *bind.TransactOpts)) *ManyChainMultiSigInterface_Receive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_Receive_Call) Return(_a0 *types.Transaction, _a1 error) *ManyChainMultiSigInterface_Receive_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_Receive_Call) RunAndReturn(run func(*bind.TransactOpts) (*types.Transaction, error)) *ManyChainMultiSigInterface_Receive_Call {
	_c.Call.Return(run)
	return _c
}

// RenounceOwnership provides a mock function with given fields: opts
func (_m *ManyChainMultiSigInterface) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for RenounceOwnership")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_RenounceOwnership_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RenounceOwnership'
type ManyChainMultiSigInterface_RenounceOwnership_Call struct {
	*mock.Call
}

// RenounceOwnership is a helper method to define mock.On call
//   - opts *bind.TransactOpts
func (_e *ManyChainMultiSigInterface_Expecter) RenounceOwnership(opts interface{}) *ManyChainMultiSigInterface_RenounceOwnership_Call {
	return &ManyChainMultiSigInterface_RenounceOwnership_Call{Call: _e.mock.On("RenounceOwnership", opts)}
}

func (_c *ManyChainMultiSigInterface_RenounceOwnership_Call) Run(run func(opts *bind.TransactOpts)) *ManyChainMultiSigInterface_RenounceOwnership_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_RenounceOwnership_Call) Return(_a0 *types.Transaction, _a1 error) *ManyChainMultiSigInterface_RenounceOwnership_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_RenounceOwnership_Call) RunAndReturn(run func(*bind.TransactOpts) (*types.Transaction, error)) *ManyChainMultiSigInterface_RenounceOwnership_Call {
	_c.Call.Return(run)
	return _c
}

// SetConfig provides a mock function with given fields: opts, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot
func (_m *ManyChainMultiSigInterface) SetConfig(opts *bind.TransactOpts, signerAddresses []common.Address, signerGroups []uint8, groupQuorums [32]uint8, groupParents [32]uint8, clearRoot bool) (*types.Transaction, error) {
	ret := _m.Called(opts, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)

	if len(ret) == 0 {
		panic("no return value specified for SetConfig")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []common.Address, []uint8, [32]uint8, [32]uint8, bool) (*types.Transaction, error)); ok {
		return rf(opts, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []common.Address, []uint8, [32]uint8, [32]uint8, bool) *types.Transaction); ok {
		r0 = rf(opts, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []common.Address, []uint8, [32]uint8, [32]uint8, bool) error); ok {
		r1 = rf(opts, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_SetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetConfig'
type ManyChainMultiSigInterface_SetConfig_Call struct {
	*mock.Call
}

// SetConfig is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - signerAddresses []common.Address
//   - signerGroups []uint8
//   - groupQuorums [32]uint8
//   - groupParents [32]uint8
//   - clearRoot bool
func (_e *ManyChainMultiSigInterface_Expecter) SetConfig(opts interface{}, signerAddresses interface{}, signerGroups interface{}, groupQuorums interface{}, groupParents interface{}, clearRoot interface{}) *ManyChainMultiSigInterface_SetConfig_Call {
	return &ManyChainMultiSigInterface_SetConfig_Call{Call: _e.mock.On("SetConfig", opts, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)}
}

func (_c *ManyChainMultiSigInterface_SetConfig_Call) Run(run func(opts *bind.TransactOpts, signerAddresses []common.Address, signerGroups []uint8, groupQuorums [32]uint8, groupParents [32]uint8, clearRoot bool)) *ManyChainMultiSigInterface_SetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([]common.Address), args[2].([]uint8), args[3].([32]uint8), args[4].([32]uint8), args[5].(bool))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_SetConfig_Call) Return(_a0 *types.Transaction, _a1 error) *ManyChainMultiSigInterface_SetConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_SetConfig_Call) RunAndReturn(run func(*bind.TransactOpts, []common.Address, []uint8, [32]uint8, [32]uint8, bool) (*types.Transaction, error)) *ManyChainMultiSigInterface_SetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// SetRoot provides a mock function with given fields: opts, root, validUntil, metadata, metadataProof, signatures
func (_m *ManyChainMultiSigInterface) SetRoot(opts *bind.TransactOpts, root [32]byte, validUntil uint32, metadata bindings.ManyChainMultiSigRootMetadata, metadataProof [][32]byte, signatures []bindings.ManyChainMultiSigSignature) (*types.Transaction, error) {
	ret := _m.Called(opts, root, validUntil, metadata, metadataProof, signatures)

	if len(ret) == 0 {
		panic("no return value specified for SetRoot")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, uint32, bindings.ManyChainMultiSigRootMetadata, [][32]byte, []bindings.ManyChainMultiSigSignature) (*types.Transaction, error)); ok {
		return rf(opts, root, validUntil, metadata, metadataProof, signatures)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, uint32, bindings.ManyChainMultiSigRootMetadata, [][32]byte, []bindings.ManyChainMultiSigSignature) *types.Transaction); ok {
		r0 = rf(opts, root, validUntil, metadata, metadataProof, signatures)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [32]byte, uint32, bindings.ManyChainMultiSigRootMetadata, [][32]byte, []bindings.ManyChainMultiSigSignature) error); ok {
		r1 = rf(opts, root, validUntil, metadata, metadataProof, signatures)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_SetRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRoot'
type ManyChainMultiSigInterface_SetRoot_Call struct {
	*mock.Call
}

// SetRoot is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - root [32]byte
//   - validUntil uint32
//   - metadata bindings.ManyChainMultiSigRootMetadata
//   - metadataProof [][32]byte
//   - signatures []bindings.ManyChainMultiSigSignature
func (_e *ManyChainMultiSigInterface_Expecter) SetRoot(opts interface{}, root interface{}, validUntil interface{}, metadata interface{}, metadataProof interface{}, signatures interface{}) *ManyChainMultiSigInterface_SetRoot_Call {
	return &ManyChainMultiSigInterface_SetRoot_Call{Call: _e.mock.On("SetRoot", opts, root, validUntil, metadata, metadataProof, signatures)}
}

func (_c *ManyChainMultiSigInterface_SetRoot_Call) Run(run func(opts *bind.TransactOpts, root [32]byte, validUntil uint32, metadata bindings.ManyChainMultiSigRootMetadata, metadataProof [][32]byte, signatures []bindings.ManyChainMultiSigSignature)) *ManyChainMultiSigInterface_SetRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([32]byte), args[2].(uint32), args[3].(bindings.ManyChainMultiSigRootMetadata), args[4].([][32]byte), args[5].([]bindings.ManyChainMultiSigSignature))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_SetRoot_Call) Return(_a0 *types.Transaction, _a1 error) *ManyChainMultiSigInterface_SetRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_SetRoot_Call) RunAndReturn(run func(*bind.TransactOpts, [32]byte, uint32, bindings.ManyChainMultiSigRootMetadata, [][32]byte, []bindings.ManyChainMultiSigSignature) (*types.Transaction, error)) *ManyChainMultiSigInterface_SetRoot_Call {
	_c.Call.Return(run)
	return _c
}

// TransferOwnership provides a mock function with given fields: opts, newOwner
func (_m *ManyChainMultiSigInterface) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, newOwner)

	if len(ret) == 0 {
		panic("no return value specified for TransferOwnership")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) (*types.Transaction, error)); ok {
		return rf(opts, newOwner)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_TransferOwnership_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransferOwnership'
type ManyChainMultiSigInterface_TransferOwnership_Call struct {
	*mock.Call
}

// TransferOwnership is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - newOwner common.Address
func (_e *ManyChainMultiSigInterface_Expecter) TransferOwnership(opts interface{}, newOwner interface{}) *ManyChainMultiSigInterface_TransferOwnership_Call {
	return &ManyChainMultiSigInterface_TransferOwnership_Call{Call: _e.mock.On("TransferOwnership", opts, newOwner)}
}

func (_c *ManyChainMultiSigInterface_TransferOwnership_Call) Run(run func(opts *bind.TransactOpts, newOwner common.Address)) *ManyChainMultiSigInterface_TransferOwnership_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].(common.Address))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_TransferOwnership_Call) Return(_a0 *types.Transaction, _a1 error) *ManyChainMultiSigInterface_TransferOwnership_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_TransferOwnership_Call) RunAndReturn(run func(*bind.TransactOpts, common.Address) (*types.Transaction, error)) *ManyChainMultiSigInterface_TransferOwnership_Call {
	_c.Call.Return(run)
	return _c
}

// WatchConfigSet provides a mock function with given fields: opts, sink
func (_m *ManyChainMultiSigInterface) WatchConfigSet(opts *bind.WatchOpts, sink chan<- *bindings.ManyChainMultiSigConfigSet) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchConfigSet")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigConfigSet) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigConfigSet) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigConfigSet) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_WatchConfigSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchConfigSet'
type ManyChainMultiSigInterface_WatchConfigSet_Call struct {
	*mock.Call
}

// WatchConfigSet is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.ManyChainMultiSigConfigSet
func (_e *ManyChainMultiSigInterface_Expecter) WatchConfigSet(opts interface{}, sink interface{}) *ManyChainMultiSigInterface_WatchConfigSet_Call {
	return &ManyChainMultiSigInterface_WatchConfigSet_Call{Call: _e.mock.On("WatchConfigSet", opts, sink)}
}

func (_c *ManyChainMultiSigInterface_WatchConfigSet_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.ManyChainMultiSigConfigSet)) *ManyChainMultiSigInterface_WatchConfigSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.ManyChainMultiSigConfigSet))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_WatchConfigSet_Call) Return(_a0 event.Subscription, _a1 error) *ManyChainMultiSigInterface_WatchConfigSet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_WatchConfigSet_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigConfigSet) (event.Subscription, error)) *ManyChainMultiSigInterface_WatchConfigSet_Call {
	_c.Call.Return(run)
	return _c
}

// WatchNewRoot provides a mock function with given fields: opts, sink, root
func (_m *ManyChainMultiSigInterface) WatchNewRoot(opts *bind.WatchOpts, sink chan<- *bindings.ManyChainMultiSigNewRoot, root [][32]byte) (event.Subscription, error) {
	ret := _m.Called(opts, sink, root)

	if len(ret) == 0 {
		panic("no return value specified for WatchNewRoot")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigNewRoot, [][32]byte) (event.Subscription, error)); ok {
		return rf(opts, sink, root)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigNewRoot, [][32]byte) event.Subscription); ok {
		r0 = rf(opts, sink, root)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigNewRoot, [][32]byte) error); ok {
		r1 = rf(opts, sink, root)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_WatchNewRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchNewRoot'
type ManyChainMultiSigInterface_WatchNewRoot_Call struct {
	*mock.Call
}

// WatchNewRoot is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.ManyChainMultiSigNewRoot
//   - root [][32]byte
func (_e *ManyChainMultiSigInterface_Expecter) WatchNewRoot(opts interface{}, sink interface{}, root interface{}) *ManyChainMultiSigInterface_WatchNewRoot_Call {
	return &ManyChainMultiSigInterface_WatchNewRoot_Call{Call: _e.mock.On("WatchNewRoot", opts, sink, root)}
}

func (_c *ManyChainMultiSigInterface_WatchNewRoot_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.ManyChainMultiSigNewRoot, root [][32]byte)) *ManyChainMultiSigInterface_WatchNewRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.ManyChainMultiSigNewRoot), args[2].([][32]byte))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_WatchNewRoot_Call) Return(_a0 event.Subscription, _a1 error) *ManyChainMultiSigInterface_WatchNewRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_WatchNewRoot_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigNewRoot, [][32]byte) (event.Subscription, error)) *ManyChainMultiSigInterface_WatchNewRoot_Call {
	_c.Call.Return(run)
	return _c
}

// WatchOpExecuted provides a mock function with given fields: opts, sink, nonce
func (_m *ManyChainMultiSigInterface) WatchOpExecuted(opts *bind.WatchOpts, sink chan<- *bindings.ManyChainMultiSigOpExecuted, nonce []*big.Int) (event.Subscription, error) {
	ret := _m.Called(opts, sink, nonce)

	if len(ret) == 0 {
		panic("no return value specified for WatchOpExecuted")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigOpExecuted, []*big.Int) (event.Subscription, error)); ok {
		return rf(opts, sink, nonce)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigOpExecuted, []*big.Int) event.Subscription); ok {
		r0 = rf(opts, sink, nonce)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigOpExecuted, []*big.Int) error); ok {
		r1 = rf(opts, sink, nonce)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_WatchOpExecuted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchOpExecuted'
type ManyChainMultiSigInterface_WatchOpExecuted_Call struct {
	*mock.Call
}

// WatchOpExecuted is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.ManyChainMultiSigOpExecuted
//   - nonce []*big.Int
func (_e *ManyChainMultiSigInterface_Expecter) WatchOpExecuted(opts interface{}, sink interface{}, nonce interface{}) *ManyChainMultiSigInterface_WatchOpExecuted_Call {
	return &ManyChainMultiSigInterface_WatchOpExecuted_Call{Call: _e.mock.On("WatchOpExecuted", opts, sink, nonce)}
}

func (_c *ManyChainMultiSigInterface_WatchOpExecuted_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.ManyChainMultiSigOpExecuted, nonce []*big.Int)) *ManyChainMultiSigInterface_WatchOpExecuted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.ManyChainMultiSigOpExecuted), args[2].([]*big.Int))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_WatchOpExecuted_Call) Return(_a0 event.Subscription, _a1 error) *ManyChainMultiSigInterface_WatchOpExecuted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_WatchOpExecuted_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigOpExecuted, []*big.Int) (event.Subscription, error)) *ManyChainMultiSigInterface_WatchOpExecuted_Call {
	_c.Call.Return(run)
	return _c
}

// WatchOwnershipTransferStarted provides a mock function with given fields: opts, sink, previousOwner, newOwner
func (_m *ManyChainMultiSigInterface) WatchOwnershipTransferStarted(opts *bind.WatchOpts, sink chan<- *bindings.ManyChainMultiSigOwnershipTransferStarted, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, previousOwner, newOwner)

	if len(ret) == 0 {
		panic("no return value specified for WatchOwnershipTransferStarted")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigOwnershipTransferStarted, []common.Address, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, previousOwner, newOwner)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigOwnershipTransferStarted, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigOwnershipTransferStarted, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_WatchOwnershipTransferStarted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchOwnershipTransferStarted'
type ManyChainMultiSigInterface_WatchOwnershipTransferStarted_Call struct {
	*mock.Call
}

// WatchOwnershipTransferStarted is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.ManyChainMultiSigOwnershipTransferStarted
//   - previousOwner []common.Address
//   - newOwner []common.Address
func (_e *ManyChainMultiSigInterface_Expecter) WatchOwnershipTransferStarted(opts interface{}, sink interface{}, previousOwner interface{}, newOwner interface{}) *ManyChainMultiSigInterface_WatchOwnershipTransferStarted_Call {
	return &ManyChainMultiSigInterface_WatchOwnershipTransferStarted_Call{Call: _e.mock.On("WatchOwnershipTransferStarted", opts, sink, previousOwner, newOwner)}
}

func (_c *ManyChainMultiSigInterface_WatchOwnershipTransferStarted_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.ManyChainMultiSigOwnershipTransferStarted, previousOwner []common.Address, newOwner []common.Address)) *ManyChainMultiSigInterface_WatchOwnershipTransferStarted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.ManyChainMultiSigOwnershipTransferStarted), args[2].([]common.Address), args[3].([]common.Address))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_WatchOwnershipTransferStarted_Call) Return(_a0 event.Subscription, _a1 error) *ManyChainMultiSigInterface_WatchOwnershipTransferStarted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_WatchOwnershipTransferStarted_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigOwnershipTransferStarted, []common.Address, []common.Address) (event.Subscription, error)) *ManyChainMultiSigInterface_WatchOwnershipTransferStarted_Call {
	_c.Call.Return(run)
	return _c
}

// WatchOwnershipTransferred provides a mock function with given fields: opts, sink, previousOwner, newOwner
func (_m *ManyChainMultiSigInterface) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *bindings.ManyChainMultiSigOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, previousOwner, newOwner)

	if len(ret) == 0 {
		panic("no return value specified for WatchOwnershipTransferred")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigOwnershipTransferred, []common.Address, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, previousOwner, newOwner)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigOwnershipTransferred, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigOwnershipTransferred, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ManyChainMultiSigInterface_WatchOwnershipTransferred_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchOwnershipTransferred'
type ManyChainMultiSigInterface_WatchOwnershipTransferred_Call struct {
	*mock.Call
}

// WatchOwnershipTransferred is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *bindings.ManyChainMultiSigOwnershipTransferred
//   - previousOwner []common.Address
//   - newOwner []common.Address
func (_e *ManyChainMultiSigInterface_Expecter) WatchOwnershipTransferred(opts interface{}, sink interface{}, previousOwner interface{}, newOwner interface{}) *ManyChainMultiSigInterface_WatchOwnershipTransferred_Call {
	return &ManyChainMultiSigInterface_WatchOwnershipTransferred_Call{Call: _e.mock.On("WatchOwnershipTransferred", opts, sink, previousOwner, newOwner)}
}

func (_c *ManyChainMultiSigInterface_WatchOwnershipTransferred_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *bindings.ManyChainMultiSigOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address)) *ManyChainMultiSigInterface_WatchOwnershipTransferred_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *bindings.ManyChainMultiSigOwnershipTransferred), args[2].([]common.Address), args[3].([]common.Address))
	})
	return _c
}

func (_c *ManyChainMultiSigInterface_WatchOwnershipTransferred_Call) Return(_a0 event.Subscription, _a1 error) *ManyChainMultiSigInterface_WatchOwnershipTransferred_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ManyChainMultiSigInterface_WatchOwnershipTransferred_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *bindings.ManyChainMultiSigOwnershipTransferred, []common.Address, []common.Address) (event.Subscription, error)) *ManyChainMultiSigInterface_WatchOwnershipTransferred_Call {
	_c.Call.Return(run)
	return _c
}

// NewManyChainMultiSigInterface creates a new instance of ManyChainMultiSigInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewManyChainMultiSigInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *ManyChainMultiSigInterface {
	mock := &ManyChainMultiSigInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

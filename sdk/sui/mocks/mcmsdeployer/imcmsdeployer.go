// Code generated by mockery v2.53.4. DO NOT EDIT.

package mock_module_mcmsdeployer

import (
	context "context"

	bind "github.com/smartcontractkit/chainlink-sui/bindings/bind"

	mock "github.com/stretchr/testify/mock"

	models "github.com/block-vision/sui-go-sdk/models"

	module_mcms_deployer "github.com/smartcontractkit/chainlink-sui/bindings/generated/mcms/mcms_deployer"
)

// IMcmsDeployer is an autogenerated mock type for the IMcmsDeployer type
type IMcmsDeployer struct {
	mock.Mock
}

type IMcmsDeployer_Expecter struct {
	mock *mock.Mock
}

func (_m *IMcmsDeployer) EXPECT() *IMcmsDeployer_Expecter {
	return &IMcmsDeployer_Expecter{mock: &_m.Mock}
}

// AuthorizeUpgrade provides a mock function with given fields: ctx, opts, param, state, policy, digest, packageAddress
func (_m *IMcmsDeployer) AuthorizeUpgrade(ctx context.Context, opts *bind.CallOpts, param bind.Object, state bind.Object, policy byte, digest []byte, packageAddress string) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, param, state, policy, digest, packageAddress)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeUpgrade")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, []byte, string) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, param, state, policy, digest, packageAddress)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, []byte, string) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, param, state, policy, digest, packageAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, []byte, string) error); ok {
		r1 = rf(ctx, opts, param, state, policy, digest, packageAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDeployer_AuthorizeUpgrade_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthorizeUpgrade'
type IMcmsDeployer_AuthorizeUpgrade_Call struct {
	*mock.Call
}

// AuthorizeUpgrade is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - param bind.Object
//   - state bind.Object
//   - policy byte
//   - digest []byte
//   - packageAddress string
func (_e *IMcmsDeployer_Expecter) AuthorizeUpgrade(ctx interface{}, opts interface{}, param interface{}, state interface{}, policy interface{}, digest interface{}, packageAddress interface{}) *IMcmsDeployer_AuthorizeUpgrade_Call {
	return &IMcmsDeployer_AuthorizeUpgrade_Call{Call: _e.mock.On("AuthorizeUpgrade", ctx, opts, param, state, policy, digest, packageAddress)}
}

func (_c *IMcmsDeployer_AuthorizeUpgrade_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, param bind.Object, state bind.Object, policy byte, digest []byte, packageAddress string)) *IMcmsDeployer_AuthorizeUpgrade_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(byte), args[5].([]byte), args[6].(string))
	})
	return _c
}

func (_c *IMcmsDeployer_AuthorizeUpgrade_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcmsDeployer_AuthorizeUpgrade_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDeployer_AuthorizeUpgrade_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, []byte, string) (*models.SuiTransactionBlockResponse, error)) *IMcmsDeployer_AuthorizeUpgrade_Call {
	_c.Call.Return(run)
	return _c
}

// Bound provides a mock function with no fields
func (_m *IMcmsDeployer) Bound() bind.IBoundContract {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Bound")
	}

	var r0 bind.IBoundContract
	if rf, ok := ret.Get(0).(func() bind.IBoundContract); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(bind.IBoundContract)
		}
	}

	return r0
}

// IMcmsDeployer_Bound_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Bound'
type IMcmsDeployer_Bound_Call struct {
	*mock.Call
}

// Bound is a helper method to define mock.On call
func (_e *IMcmsDeployer_Expecter) Bound() *IMcmsDeployer_Bound_Call {
	return &IMcmsDeployer_Bound_Call{Call: _e.mock.On("Bound")}
}

func (_c *IMcmsDeployer_Bound_Call) Run(run func()) *IMcmsDeployer_Bound_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IMcmsDeployer_Bound_Call) Return(_a0 bind.IBoundContract) *IMcmsDeployer_Bound_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IMcmsDeployer_Bound_Call) RunAndReturn(run func() bind.IBoundContract) *IMcmsDeployer_Bound_Call {
	_c.Call.Return(run)
	return _c
}

// CommitUpgrade provides a mock function with given fields: ctx, opts, state, receipt
func (_m *IMcmsDeployer) CommitUpgrade(ctx context.Context, opts *bind.CallOpts, state bind.Object, receipt bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, state, receipt)

	if len(ret) == 0 {
		panic("no return value specified for CommitUpgrade")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, state, receipt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, state, receipt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, state, receipt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDeployer_CommitUpgrade_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitUpgrade'
type IMcmsDeployer_CommitUpgrade_Call struct {
	*mock.Call
}

// CommitUpgrade is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - receipt bind.Object
func (_e *IMcmsDeployer_Expecter) CommitUpgrade(ctx interface{}, opts interface{}, state interface{}, receipt interface{}) *IMcmsDeployer_CommitUpgrade_Call {
	return &IMcmsDeployer_CommitUpgrade_Call{Call: _e.mock.On("CommitUpgrade", ctx, opts, state, receipt)}
}

func (_c *IMcmsDeployer_CommitUpgrade_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, receipt bind.Object)) *IMcmsDeployer_CommitUpgrade_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object))
	})
	return _c
}

func (_c *IMcmsDeployer_CommitUpgrade_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcmsDeployer_CommitUpgrade_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDeployer_CommitUpgrade_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcmsDeployer_CommitUpgrade_Call {
	_c.Call.Return(run)
	return _c
}

// DevInspect provides a mock function with no fields
func (_m *IMcmsDeployer) DevInspect() module_mcms_deployer.IMcmsDeployerDevInspect {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DevInspect")
	}

	var r0 module_mcms_deployer.IMcmsDeployerDevInspect
	if rf, ok := ret.Get(0).(func() module_mcms_deployer.IMcmsDeployerDevInspect); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(module_mcms_deployer.IMcmsDeployerDevInspect)
		}
	}

	return r0
}

// IMcmsDeployer_DevInspect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DevInspect'
type IMcmsDeployer_DevInspect_Call struct {
	*mock.Call
}

// DevInspect is a helper method to define mock.On call
func (_e *IMcmsDeployer_Expecter) DevInspect() *IMcmsDeployer_DevInspect_Call {
	return &IMcmsDeployer_DevInspect_Call{Call: _e.mock.On("DevInspect")}
}

func (_c *IMcmsDeployer_DevInspect_Call) Run(run func()) *IMcmsDeployer_DevInspect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IMcmsDeployer_DevInspect_Call) Return(_a0 module_mcms_deployer.IMcmsDeployerDevInspect) *IMcmsDeployer_DevInspect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IMcmsDeployer_DevInspect_Call) RunAndReturn(run func() module_mcms_deployer.IMcmsDeployerDevInspect) *IMcmsDeployer_DevInspect_Call {
	_c.Call.Return(run)
	return _c
}

// Encoder provides a mock function with no fields
func (_m *IMcmsDeployer) Encoder() module_mcms_deployer.McmsDeployerEncoder {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Encoder")
	}

	var r0 module_mcms_deployer.McmsDeployerEncoder
	if rf, ok := ret.Get(0).(func() module_mcms_deployer.McmsDeployerEncoder); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(module_mcms_deployer.McmsDeployerEncoder)
		}
	}

	return r0
}

// IMcmsDeployer_Encoder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Encoder'
type IMcmsDeployer_Encoder_Call struct {
	*mock.Call
}

// Encoder is a helper method to define mock.On call
func (_e *IMcmsDeployer_Expecter) Encoder() *IMcmsDeployer_Encoder_Call {
	return &IMcmsDeployer_Encoder_Call{Call: _e.mock.On("Encoder")}
}

func (_c *IMcmsDeployer_Encoder_Call) Run(run func()) *IMcmsDeployer_Encoder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IMcmsDeployer_Encoder_Call) Return(_a0 module_mcms_deployer.McmsDeployerEncoder) *IMcmsDeployer_Encoder_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IMcmsDeployer_Encoder_Call) RunAndReturn(run func() module_mcms_deployer.McmsDeployerEncoder) *IMcmsDeployer_Encoder_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterUpgradeCap provides a mock function with given fields: ctx, opts, state, registry, upgradeCap
func (_m *IMcmsDeployer) RegisterUpgradeCap(ctx context.Context, opts *bind.CallOpts, state bind.Object, registry bind.Object, upgradeCap bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, state, registry, upgradeCap)

	if len(ret) == 0 {
		panic("no return value specified for RegisterUpgradeCap")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, state, registry, upgradeCap)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, state, registry, upgradeCap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, state, registry, upgradeCap)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDeployer_RegisterUpgradeCap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterUpgradeCap'
type IMcmsDeployer_RegisterUpgradeCap_Call struct {
	*mock.Call
}

// RegisterUpgradeCap is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - registry bind.Object
//   - upgradeCap bind.Object
func (_e *IMcmsDeployer_Expecter) RegisterUpgradeCap(ctx interface{}, opts interface{}, state interface{}, registry interface{}, upgradeCap interface{}) *IMcmsDeployer_RegisterUpgradeCap_Call {
	return &IMcmsDeployer_RegisterUpgradeCap_Call{Call: _e.mock.On("RegisterUpgradeCap", ctx, opts, state, registry, upgradeCap)}
}

func (_c *IMcmsDeployer_RegisterUpgradeCap_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, registry bind.Object, upgradeCap bind.Object)) *IMcmsDeployer_RegisterUpgradeCap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(bind.Object))
	})
	return _c
}

func (_c *IMcmsDeployer_RegisterUpgradeCap_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcmsDeployer_RegisterUpgradeCap_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDeployer_RegisterUpgradeCap_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcmsDeployer_RegisterUpgradeCap_Call {
	_c.Call.Return(run)
	return _c
}

// NewIMcmsDeployer creates a new instance of IMcmsDeployer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIMcmsDeployer(t interface {
	mock.TestingT
	Cleanup(func())
}) *IMcmsDeployer {
	mock := &IMcmsDeployer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

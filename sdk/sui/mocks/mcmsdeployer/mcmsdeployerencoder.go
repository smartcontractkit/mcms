// Code generated by mockery v2.53.5. DO NOT EDIT.

package mock_module_mcmsdeployer

import (
	bind "github.com/smartcontractkit/chainlink-sui/bindings/bind"
	mock "github.com/stretchr/testify/mock"
)

// McmsDeployerEncoder is an autogenerated mock type for the McmsDeployerEncoder type
type McmsDeployerEncoder struct {
	mock.Mock
}

type McmsDeployerEncoder_Expecter struct {
	mock *mock.Mock
}

func (_m *McmsDeployerEncoder) EXPECT() *McmsDeployerEncoder_Expecter {
	return &McmsDeployerEncoder_Expecter{mock: &_m.Mock}
}

// AuthorizeUpgrade provides a mock function with given fields: param, state, policy, digest, packageAddress
func (_m *McmsDeployerEncoder) AuthorizeUpgrade(param bind.Object, state bind.Object, policy byte, digest []byte, packageAddress string) (*bind.EncodedCall, error) {
	ret := _m.Called(param, state, policy, digest, packageAddress)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeUpgrade")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, byte, []byte, string) (*bind.EncodedCall, error)); ok {
		return rf(param, state, policy, digest, packageAddress)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, byte, []byte, string) *bind.EncodedCall); ok {
		r0 = rf(param, state, policy, digest, packageAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, byte, []byte, string) error); ok {
		r1 = rf(param, state, policy, digest, packageAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsDeployerEncoder_AuthorizeUpgrade_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthorizeUpgrade'
type McmsDeployerEncoder_AuthorizeUpgrade_Call struct {
	*mock.Call
}

// AuthorizeUpgrade is a helper method to define mock.On call
//   - param bind.Object
//   - state bind.Object
//   - policy byte
//   - digest []byte
//   - packageAddress string
func (_e *McmsDeployerEncoder_Expecter) AuthorizeUpgrade(param interface{}, state interface{}, policy interface{}, digest interface{}, packageAddress interface{}) *McmsDeployerEncoder_AuthorizeUpgrade_Call {
	return &McmsDeployerEncoder_AuthorizeUpgrade_Call{Call: _e.mock.On("AuthorizeUpgrade", param, state, policy, digest, packageAddress)}
}

func (_c *McmsDeployerEncoder_AuthorizeUpgrade_Call) Run(run func(param bind.Object, state bind.Object, policy byte, digest []byte, packageAddress string)) *McmsDeployerEncoder_AuthorizeUpgrade_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(byte), args[3].([]byte), args[4].(string))
	})
	return _c
}

func (_c *McmsDeployerEncoder_AuthorizeUpgrade_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsDeployerEncoder_AuthorizeUpgrade_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsDeployerEncoder_AuthorizeUpgrade_Call) RunAndReturn(run func(bind.Object, bind.Object, byte, []byte, string) (*bind.EncodedCall, error)) *McmsDeployerEncoder_AuthorizeUpgrade_Call {
	_c.Call.Return(run)
	return _c
}

// AuthorizeUpgradeWithArgs provides a mock function with given fields: args
func (_m *McmsDeployerEncoder) AuthorizeUpgradeWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeUpgradeWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsDeployerEncoder_AuthorizeUpgradeWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthorizeUpgradeWithArgs'
type McmsDeployerEncoder_AuthorizeUpgradeWithArgs_Call struct {
	*mock.Call
}

// AuthorizeUpgradeWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsDeployerEncoder_Expecter) AuthorizeUpgradeWithArgs(args ...interface{}) *McmsDeployerEncoder_AuthorizeUpgradeWithArgs_Call {
	return &McmsDeployerEncoder_AuthorizeUpgradeWithArgs_Call{Call: _e.mock.On("AuthorizeUpgradeWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsDeployerEncoder_AuthorizeUpgradeWithArgs_Call) Run(run func(args ...interface{})) *McmsDeployerEncoder_AuthorizeUpgradeWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsDeployerEncoder_AuthorizeUpgradeWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsDeployerEncoder_AuthorizeUpgradeWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsDeployerEncoder_AuthorizeUpgradeWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsDeployerEncoder_AuthorizeUpgradeWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// CommitUpgrade provides a mock function with given fields: state, receipt
func (_m *McmsDeployerEncoder) CommitUpgrade(state bind.Object, receipt bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(state, receipt)

	if len(ret) == 0 {
		panic("no return value specified for CommitUpgrade")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(state, receipt)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object) *bind.EncodedCall); ok {
		r0 = rf(state, receipt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object) error); ok {
		r1 = rf(state, receipt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsDeployerEncoder_CommitUpgrade_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitUpgrade'
type McmsDeployerEncoder_CommitUpgrade_Call struct {
	*mock.Call
}

// CommitUpgrade is a helper method to define mock.On call
//   - state bind.Object
//   - receipt bind.Object
func (_e *McmsDeployerEncoder_Expecter) CommitUpgrade(state interface{}, receipt interface{}) *McmsDeployerEncoder_CommitUpgrade_Call {
	return &McmsDeployerEncoder_CommitUpgrade_Call{Call: _e.mock.On("CommitUpgrade", state, receipt)}
}

func (_c *McmsDeployerEncoder_CommitUpgrade_Call) Run(run func(state bind.Object, receipt bind.Object)) *McmsDeployerEncoder_CommitUpgrade_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object))
	})
	return _c
}

func (_c *McmsDeployerEncoder_CommitUpgrade_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsDeployerEncoder_CommitUpgrade_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsDeployerEncoder_CommitUpgrade_Call) RunAndReturn(run func(bind.Object, bind.Object) (*bind.EncodedCall, error)) *McmsDeployerEncoder_CommitUpgrade_Call {
	_c.Call.Return(run)
	return _c
}

// CommitUpgradeWithArgs provides a mock function with given fields: args
func (_m *McmsDeployerEncoder) CommitUpgradeWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CommitUpgradeWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsDeployerEncoder_CommitUpgradeWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitUpgradeWithArgs'
type McmsDeployerEncoder_CommitUpgradeWithArgs_Call struct {
	*mock.Call
}

// CommitUpgradeWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsDeployerEncoder_Expecter) CommitUpgradeWithArgs(args ...interface{}) *McmsDeployerEncoder_CommitUpgradeWithArgs_Call {
	return &McmsDeployerEncoder_CommitUpgradeWithArgs_Call{Call: _e.mock.On("CommitUpgradeWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsDeployerEncoder_CommitUpgradeWithArgs_Call) Run(run func(args ...interface{})) *McmsDeployerEncoder_CommitUpgradeWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsDeployerEncoder_CommitUpgradeWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsDeployerEncoder_CommitUpgradeWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsDeployerEncoder_CommitUpgradeWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsDeployerEncoder_CommitUpgradeWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// HasUpgradeCap provides a mock function with given fields: state, packageAddress
func (_m *McmsDeployerEncoder) HasUpgradeCap(state bind.Object, packageAddress string) (*bind.EncodedCall, error) {
	ret := _m.Called(state, packageAddress)

	if len(ret) == 0 {
		panic("no return value specified for HasUpgradeCap")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, string) (*bind.EncodedCall, error)); ok {
		return rf(state, packageAddress)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, string) *bind.EncodedCall); ok {
		r0 = rf(state, packageAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, string) error); ok {
		r1 = rf(state, packageAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsDeployerEncoder_HasUpgradeCap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasUpgradeCap'
type McmsDeployerEncoder_HasUpgradeCap_Call struct {
	*mock.Call
}

// HasUpgradeCap is a helper method to define mock.On call
//   - state bind.Object
//   - packageAddress string
func (_e *McmsDeployerEncoder_Expecter) HasUpgradeCap(state interface{}, packageAddress interface{}) *McmsDeployerEncoder_HasUpgradeCap_Call {
	return &McmsDeployerEncoder_HasUpgradeCap_Call{Call: _e.mock.On("HasUpgradeCap", state, packageAddress)}
}

func (_c *McmsDeployerEncoder_HasUpgradeCap_Call) Run(run func(state bind.Object, packageAddress string)) *McmsDeployerEncoder_HasUpgradeCap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(string))
	})
	return _c
}

func (_c *McmsDeployerEncoder_HasUpgradeCap_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsDeployerEncoder_HasUpgradeCap_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsDeployerEncoder_HasUpgradeCap_Call) RunAndReturn(run func(bind.Object, string) (*bind.EncodedCall, error)) *McmsDeployerEncoder_HasUpgradeCap_Call {
	_c.Call.Return(run)
	return _c
}

// HasUpgradeCapWithArgs provides a mock function with given fields: args
func (_m *McmsDeployerEncoder) HasUpgradeCapWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HasUpgradeCapWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsDeployerEncoder_HasUpgradeCapWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasUpgradeCapWithArgs'
type McmsDeployerEncoder_HasUpgradeCapWithArgs_Call struct {
	*mock.Call
}

// HasUpgradeCapWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsDeployerEncoder_Expecter) HasUpgradeCapWithArgs(args ...interface{}) *McmsDeployerEncoder_HasUpgradeCapWithArgs_Call {
	return &McmsDeployerEncoder_HasUpgradeCapWithArgs_Call{Call: _e.mock.On("HasUpgradeCapWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsDeployerEncoder_HasUpgradeCapWithArgs_Call) Run(run func(args ...interface{})) *McmsDeployerEncoder_HasUpgradeCapWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsDeployerEncoder_HasUpgradeCapWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsDeployerEncoder_HasUpgradeCapWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsDeployerEncoder_HasUpgradeCapWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsDeployerEncoder_HasUpgradeCapWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterUpgradeCap provides a mock function with given fields: state, registry, upgradeCap
func (_m *McmsDeployerEncoder) RegisterUpgradeCap(state bind.Object, registry bind.Object, upgradeCap bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(state, registry, upgradeCap)

	if len(ret) == 0 {
		panic("no return value specified for RegisterUpgradeCap")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(state, registry, upgradeCap)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) *bind.EncodedCall); ok {
		r0 = rf(state, registry, upgradeCap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(state, registry, upgradeCap)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsDeployerEncoder_RegisterUpgradeCap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterUpgradeCap'
type McmsDeployerEncoder_RegisterUpgradeCap_Call struct {
	*mock.Call
}

// RegisterUpgradeCap is a helper method to define mock.On call
//   - state bind.Object
//   - registry bind.Object
//   - upgradeCap bind.Object
func (_e *McmsDeployerEncoder_Expecter) RegisterUpgradeCap(state interface{}, registry interface{}, upgradeCap interface{}) *McmsDeployerEncoder_RegisterUpgradeCap_Call {
	return &McmsDeployerEncoder_RegisterUpgradeCap_Call{Call: _e.mock.On("RegisterUpgradeCap", state, registry, upgradeCap)}
}

func (_c *McmsDeployerEncoder_RegisterUpgradeCap_Call) Run(run func(state bind.Object, registry bind.Object, upgradeCap bind.Object)) *McmsDeployerEncoder_RegisterUpgradeCap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(bind.Object))
	})
	return _c
}

func (_c *McmsDeployerEncoder_RegisterUpgradeCap_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsDeployerEncoder_RegisterUpgradeCap_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsDeployerEncoder_RegisterUpgradeCap_Call) RunAndReturn(run func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)) *McmsDeployerEncoder_RegisterUpgradeCap_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterUpgradeCapWithArgs provides a mock function with given fields: args
func (_m *McmsDeployerEncoder) RegisterUpgradeCapWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterUpgradeCapWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsDeployerEncoder_RegisterUpgradeCapWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterUpgradeCapWithArgs'
type McmsDeployerEncoder_RegisterUpgradeCapWithArgs_Call struct {
	*mock.Call
}

// RegisterUpgradeCapWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsDeployerEncoder_Expecter) RegisterUpgradeCapWithArgs(args ...interface{}) *McmsDeployerEncoder_RegisterUpgradeCapWithArgs_Call {
	return &McmsDeployerEncoder_RegisterUpgradeCapWithArgs_Call{Call: _e.mock.On("RegisterUpgradeCapWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsDeployerEncoder_RegisterUpgradeCapWithArgs_Call) Run(run func(args ...interface{})) *McmsDeployerEncoder_RegisterUpgradeCapWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsDeployerEncoder_RegisterUpgradeCapWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsDeployerEncoder_RegisterUpgradeCapWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsDeployerEncoder_RegisterUpgradeCapWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsDeployerEncoder_RegisterUpgradeCapWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ReleaseUpgradeCap provides a mock function with given fields: typeArgs, state, registry, proof
func (_m *McmsDeployerEncoder) ReleaseUpgradeCap(typeArgs []string, state bind.Object, registry bind.Object, proof bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(typeArgs, state, registry, proof)

	if len(ret) == 0 {
		panic("no return value specified for ReleaseUpgradeCap")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func([]string, bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(typeArgs, state, registry, proof)
	}
	if rf, ok := ret.Get(0).(func([]string, bind.Object, bind.Object, bind.Object) *bind.EncodedCall); ok {
		r0 = rf(typeArgs, state, registry, proof)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func([]string, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(typeArgs, state, registry, proof)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsDeployerEncoder_ReleaseUpgradeCap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReleaseUpgradeCap'
type McmsDeployerEncoder_ReleaseUpgradeCap_Call struct {
	*mock.Call
}

// ReleaseUpgradeCap is a helper method to define mock.On call
//   - typeArgs []string
//   - state bind.Object
//   - registry bind.Object
//   - proof bind.Object
func (_e *McmsDeployerEncoder_Expecter) ReleaseUpgradeCap(typeArgs interface{}, state interface{}, registry interface{}, proof interface{}) *McmsDeployerEncoder_ReleaseUpgradeCap_Call {
	return &McmsDeployerEncoder_ReleaseUpgradeCap_Call{Call: _e.mock.On("ReleaseUpgradeCap", typeArgs, state, registry, proof)}
}

func (_c *McmsDeployerEncoder_ReleaseUpgradeCap_Call) Run(run func(typeArgs []string, state bind.Object, registry bind.Object, proof bind.Object)) *McmsDeployerEncoder_ReleaseUpgradeCap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]string), args[1].(bind.Object), args[2].(bind.Object), args[3].(bind.Object))
	})
	return _c
}

func (_c *McmsDeployerEncoder_ReleaseUpgradeCap_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsDeployerEncoder_ReleaseUpgradeCap_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsDeployerEncoder_ReleaseUpgradeCap_Call) RunAndReturn(run func([]string, bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)) *McmsDeployerEncoder_ReleaseUpgradeCap_Call {
	_c.Call.Return(run)
	return _c
}

// ReleaseUpgradeCapWithArgs provides a mock function with given fields: typeArgs, args
func (_m *McmsDeployerEncoder) ReleaseUpgradeCapWithArgs(typeArgs []string, args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, typeArgs)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReleaseUpgradeCapWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func([]string, ...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(typeArgs, args...)
	}
	if rf, ok := ret.Get(0).(func([]string, ...interface{}) *bind.EncodedCall); ok {
		r0 = rf(typeArgs, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func([]string, ...interface{}) error); ok {
		r1 = rf(typeArgs, args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsDeployerEncoder_ReleaseUpgradeCapWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReleaseUpgradeCapWithArgs'
type McmsDeployerEncoder_ReleaseUpgradeCapWithArgs_Call struct {
	*mock.Call
}

// ReleaseUpgradeCapWithArgs is a helper method to define mock.On call
//   - typeArgs []string
//   - args ...interface{}
func (_e *McmsDeployerEncoder_Expecter) ReleaseUpgradeCapWithArgs(typeArgs interface{}, args ...interface{}) *McmsDeployerEncoder_ReleaseUpgradeCapWithArgs_Call {
	return &McmsDeployerEncoder_ReleaseUpgradeCapWithArgs_Call{Call: _e.mock.On("ReleaseUpgradeCapWithArgs",
		append([]interface{}{typeArgs}, args...)...)}
}

func (_c *McmsDeployerEncoder_ReleaseUpgradeCapWithArgs_Call) Run(run func(typeArgs []string, args ...interface{})) *McmsDeployerEncoder_ReleaseUpgradeCapWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].([]string), variadicArgs...)
	})
	return _c
}

func (_c *McmsDeployerEncoder_ReleaseUpgradeCapWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsDeployerEncoder_ReleaseUpgradeCapWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsDeployerEncoder_ReleaseUpgradeCapWithArgs_Call) RunAndReturn(run func([]string, ...interface{}) (*bind.EncodedCall, error)) *McmsDeployerEncoder_ReleaseUpgradeCapWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// NewMcmsDeployerEncoder creates a new instance of McmsDeployerEncoder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMcmsDeployerEncoder(t interface {
	mock.TestingT
	Cleanup(func())
}) *McmsDeployerEncoder {
	mock := &McmsDeployerEncoder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Code generated by mockery v2.53.4. DO NOT EDIT.

package mock_module_mcms

import (
	context "context"
	big "math/big"

	bind "github.com/smartcontractkit/chainlink-sui/bindings/bind"

	mock "github.com/stretchr/testify/mock"

	models "github.com/block-vision/sui-go-sdk/models"

	module_mcms "github.com/smartcontractkit/chainlink-sui/bindings/generated/mcms/mcms"
)

// IMcms is an autogenerated mock type for the IMcms type
type IMcms struct {
	mock.Mock
}

type IMcms_Expecter struct {
	mock *mock.Mock
}

func (_m *IMcms) EXPECT() *IMcms_Expecter {
	return &IMcms_Expecter{mock: &_m.Mock}
}

// Bound provides a mock function with no fields
func (_m *IMcms) Bound() bind.IBoundContract {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Bound")
	}

	var r0 bind.IBoundContract
	if rf, ok := ret.Get(0).(func() bind.IBoundContract); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(bind.IBoundContract)
		}
	}

	return r0
}

// IMcms_Bound_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Bound'
type IMcms_Bound_Call struct {
	*mock.Call
}

// Bound is a helper method to define mock.On call
func (_e *IMcms_Expecter) Bound() *IMcms_Bound_Call {
	return &IMcms_Bound_Call{Call: _e.mock.On("Bound")}
}

func (_c *IMcms_Bound_Call) Run(run func()) *IMcms_Bound_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IMcms_Bound_Call) Return(_a0 bind.IBoundContract) *IMcms_Bound_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IMcms_Bound_Call) RunAndReturn(run func() bind.IBoundContract) *IMcms_Bound_Call {
	_c.Call.Return(run)
	return _c
}

// BypasserRole provides a mock function with given fields: ctx, opts
func (_m *IMcms) BypasserRole(ctx context.Context, opts *bind.CallOpts) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for BypasserRole")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_BypasserRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BypasserRole'
type IMcms_BypasserRole_Call struct {
	*mock.Call
}

// BypasserRole is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
func (_e *IMcms_Expecter) BypasserRole(ctx interface{}, opts interface{}) *IMcms_BypasserRole_Call {
	return &IMcms_BypasserRole_Call{Call: _e.mock.On("BypasserRole", ctx, opts)}
}

func (_c *IMcms_BypasserRole_Call) Run(run func(ctx context.Context, opts *bind.CallOpts)) *IMcms_BypasserRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts))
	})
	return _c
}

func (_c *IMcms_BypasserRole_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_BypasserRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_BypasserRole_Call) RunAndReturn(run func(context.Context, *bind.CallOpts) (*models.SuiTransactionBlockResponse, error)) *IMcms_BypasserRole_Call {
	_c.Call.Return(run)
	return _c
}

// CancellerRole provides a mock function with given fields: ctx, opts
func (_m *IMcms) CancellerRole(ctx context.Context, opts *bind.CallOpts) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for CancellerRole")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_CancellerRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancellerRole'
type IMcms_CancellerRole_Call struct {
	*mock.Call
}

// CancellerRole is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
func (_e *IMcms_Expecter) CancellerRole(ctx interface{}, opts interface{}) *IMcms_CancellerRole_Call {
	return &IMcms_CancellerRole_Call{Call: _e.mock.On("CancellerRole", ctx, opts)}
}

func (_c *IMcms_CancellerRole_Call) Run(run func(ctx context.Context, opts *bind.CallOpts)) *IMcms_CancellerRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts))
	})
	return _c
}

func (_c *IMcms_CancellerRole_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_CancellerRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_CancellerRole_Call) RunAndReturn(run func(context.Context, *bind.CallOpts) (*models.SuiTransactionBlockResponse, error)) *IMcms_CancellerRole_Call {
	_c.Call.Return(run)
	return _c
}

// ChainId provides a mock function with given fields: ctx, opts, rootMetadata
func (_m *IMcms) ChainId(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for ChainId")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, rootMetadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) error); ok {
		r1 = rf(ctx, opts, rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_ChainId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainId'
type IMcms_ChainId_Call struct {
	*mock.Call
}

// ChainId is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - rootMetadata module_mcms.RootMetadata
func (_e *IMcms_Expecter) ChainId(ctx interface{}, opts interface{}, rootMetadata interface{}) *IMcms_ChainId_Call {
	return &IMcms_ChainId_Call{Call: _e.mock.On("ChainId", ctx, opts, rootMetadata)}
}

func (_c *IMcms_ChainId_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata)) *IMcms_ChainId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *IMcms_ChainId_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_ChainId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_ChainId_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error)) *IMcms_ChainId_Call {
	_c.Call.Return(run)
	return _c
}

// ComputeEthMessageHash provides a mock function with given fields: ctx, opts, root, validUntil
func (_m *IMcms) ComputeEthMessageHash(ctx context.Context, opts *bind.CallOpts, root []byte, validUntil uint64) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, root, validUntil)

	if len(ret) == 0 {
		panic("no return value specified for ComputeEthMessageHash")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []byte, uint64) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, root, validUntil)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []byte, uint64) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, root, validUntil)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, []byte, uint64) error); ok {
		r1 = rf(ctx, opts, root, validUntil)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_ComputeEthMessageHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputeEthMessageHash'
type IMcms_ComputeEthMessageHash_Call struct {
	*mock.Call
}

// ComputeEthMessageHash is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - root []byte
//   - validUntil uint64
func (_e *IMcms_Expecter) ComputeEthMessageHash(ctx interface{}, opts interface{}, root interface{}, validUntil interface{}) *IMcms_ComputeEthMessageHash_Call {
	return &IMcms_ComputeEthMessageHash_Call{Call: _e.mock.On("ComputeEthMessageHash", ctx, opts, root, validUntil)}
}

func (_c *IMcms_ComputeEthMessageHash_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, root []byte, validUntil uint64)) *IMcms_ComputeEthMessageHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].([]byte), args[3].(uint64))
	})
	return _c
}

func (_c *IMcms_ComputeEthMessageHash_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_ComputeEthMessageHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_ComputeEthMessageHash_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, []byte, uint64) (*models.SuiTransactionBlockResponse, error)) *IMcms_ComputeEthMessageHash_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigGroupParents provides a mock function with given fields: ctx, opts, config
func (_m *IMcms) ConfigGroupParents(ctx context.Context, opts *bind.CallOpts, config module_mcms.Config) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, config)

	if len(ret) == 0 {
		panic("no return value specified for ConfigGroupParents")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Config) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, config)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Config) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Config) error); ok {
		r1 = rf(ctx, opts, config)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_ConfigGroupParents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigGroupParents'
type IMcms_ConfigGroupParents_Call struct {
	*mock.Call
}

// ConfigGroupParents is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - config module_mcms.Config
func (_e *IMcms_Expecter) ConfigGroupParents(ctx interface{}, opts interface{}, config interface{}) *IMcms_ConfigGroupParents_Call {
	return &IMcms_ConfigGroupParents_Call{Call: _e.mock.On("ConfigGroupParents", ctx, opts, config)}
}

func (_c *IMcms_ConfigGroupParents_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, config module_mcms.Config)) *IMcms_ConfigGroupParents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Config))
	})
	return _c
}

func (_c *IMcms_ConfigGroupParents_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_ConfigGroupParents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_ConfigGroupParents_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Config) (*models.SuiTransactionBlockResponse, error)) *IMcms_ConfigGroupParents_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigGroupQuorums provides a mock function with given fields: ctx, opts, config
func (_m *IMcms) ConfigGroupQuorums(ctx context.Context, opts *bind.CallOpts, config module_mcms.Config) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, config)

	if len(ret) == 0 {
		panic("no return value specified for ConfigGroupQuorums")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Config) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, config)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Config) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Config) error); ok {
		r1 = rf(ctx, opts, config)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_ConfigGroupQuorums_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigGroupQuorums'
type IMcms_ConfigGroupQuorums_Call struct {
	*mock.Call
}

// ConfigGroupQuorums is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - config module_mcms.Config
func (_e *IMcms_Expecter) ConfigGroupQuorums(ctx interface{}, opts interface{}, config interface{}) *IMcms_ConfigGroupQuorums_Call {
	return &IMcms_ConfigGroupQuorums_Call{Call: _e.mock.On("ConfigGroupQuorums", ctx, opts, config)}
}

func (_c *IMcms_ConfigGroupQuorums_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, config module_mcms.Config)) *IMcms_ConfigGroupQuorums_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Config))
	})
	return _c
}

func (_c *IMcms_ConfigGroupQuorums_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_ConfigGroupQuorums_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_ConfigGroupQuorums_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Config) (*models.SuiTransactionBlockResponse, error)) *IMcms_ConfigGroupQuorums_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigSigners provides a mock function with given fields: ctx, opts, config
func (_m *IMcms) ConfigSigners(ctx context.Context, opts *bind.CallOpts, config module_mcms.Config) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, config)

	if len(ret) == 0 {
		panic("no return value specified for ConfigSigners")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Config) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, config)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Config) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Config) error); ok {
		r1 = rf(ctx, opts, config)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_ConfigSigners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigSigners'
type IMcms_ConfigSigners_Call struct {
	*mock.Call
}

// ConfigSigners is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - config module_mcms.Config
func (_e *IMcms_Expecter) ConfigSigners(ctx interface{}, opts interface{}, config interface{}) *IMcms_ConfigSigners_Call {
	return &IMcms_ConfigSigners_Call{Call: _e.mock.On("ConfigSigners", ctx, opts, config)}
}

func (_c *IMcms_ConfigSigners_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, config module_mcms.Config)) *IMcms_ConfigSigners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Config))
	})
	return _c
}

func (_c *IMcms_ConfigSigners_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_ConfigSigners_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_ConfigSigners_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Config) (*models.SuiTransactionBlockResponse, error)) *IMcms_ConfigSigners_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCalls provides a mock function with given fields: ctx, opts, targets, moduleNames, functionNames, datas
func (_m *IMcms) CreateCalls(ctx context.Context, opts *bind.CallOpts, targets []string, moduleNames []string, functionNames []string, datas [][]byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, targets, moduleNames, functionNames, datas)

	if len(ret) == 0 {
		panic("no return value specified for CreateCalls")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []string, []string, []string, [][]byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, targets, moduleNames, functionNames, datas)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []string, []string, []string, [][]byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, targets, moduleNames, functionNames, datas)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, []string, []string, []string, [][]byte) error); ok {
		r1 = rf(ctx, opts, targets, moduleNames, functionNames, datas)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_CreateCalls_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCalls'
type IMcms_CreateCalls_Call struct {
	*mock.Call
}

// CreateCalls is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - targets []string
//   - moduleNames []string
//   - functionNames []string
//   - datas [][]byte
func (_e *IMcms_Expecter) CreateCalls(ctx interface{}, opts interface{}, targets interface{}, moduleNames interface{}, functionNames interface{}, datas interface{}) *IMcms_CreateCalls_Call {
	return &IMcms_CreateCalls_Call{Call: _e.mock.On("CreateCalls", ctx, opts, targets, moduleNames, functionNames, datas)}
}

func (_c *IMcms_CreateCalls_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, targets []string, moduleNames []string, functionNames []string, datas [][]byte)) *IMcms_CreateCalls_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].([]string), args[3].([]string), args[4].([]string), args[5].([][]byte))
	})
	return _c
}

func (_c *IMcms_CreateCalls_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_CreateCalls_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_CreateCalls_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, []string, []string, []string, [][]byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_CreateCalls_Call {
	_c.Call.Return(run)
	return _c
}

// Data provides a mock function with given fields: ctx, opts, call
func (_m *IMcms) Data(ctx context.Context, opts *bind.CallOpts, call module_mcms.Call) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, call)

	if len(ret) == 0 {
		panic("no return value specified for Data")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Call) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, call)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Call) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, call)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Call) error); ok {
		r1 = rf(ctx, opts, call)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_Data_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Data'
type IMcms_Data_Call struct {
	*mock.Call
}

// Data is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - call module_mcms.Call
func (_e *IMcms_Expecter) Data(ctx interface{}, opts interface{}, call interface{}) *IMcms_Data_Call {
	return &IMcms_Data_Call{Call: _e.mock.On("Data", ctx, opts, call)}
}

func (_c *IMcms_Data_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, call module_mcms.Call)) *IMcms_Data_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Call))
	})
	return _c
}

func (_c *IMcms_Data_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_Data_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_Data_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Call) (*models.SuiTransactionBlockResponse, error)) *IMcms_Data_Call {
	_c.Call.Return(run)
	return _c
}

// DevInspect provides a mock function with no fields
func (_m *IMcms) DevInspect() module_mcms.IMcmsDevInspect {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DevInspect")
	}

	var r0 module_mcms.IMcmsDevInspect
	if rf, ok := ret.Get(0).(func() module_mcms.IMcmsDevInspect); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(module_mcms.IMcmsDevInspect)
		}
	}

	return r0
}

// IMcms_DevInspect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DevInspect'
type IMcms_DevInspect_Call struct {
	*mock.Call
}

// DevInspect is a helper method to define mock.On call
func (_e *IMcms_Expecter) DevInspect() *IMcms_DevInspect_Call {
	return &IMcms_DevInspect_Call{Call: _e.mock.On("DevInspect")}
}

func (_c *IMcms_DevInspect_Call) Run(run func()) *IMcms_DevInspect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IMcms_DevInspect_Call) Return(_a0 module_mcms.IMcmsDevInspect) *IMcms_DevInspect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IMcms_DevInspect_Call) RunAndReturn(run func() module_mcms.IMcmsDevInspect) *IMcms_DevInspect_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockBlockFunction provides a mock function with given fields: ctx, opts, timelock, timelockCallbackParams
func (_m *IMcms) DispatchTimelockBlockFunction(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockBlockFunction")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(ctx, opts, timelock, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_DispatchTimelockBlockFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockBlockFunction'
type IMcms_DispatchTimelockBlockFunction_Call struct {
	*mock.Call
}

// DispatchTimelockBlockFunction is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *IMcms_Expecter) DispatchTimelockBlockFunction(ctx interface{}, opts interface{}, timelock interface{}, timelockCallbackParams interface{}) *IMcms_DispatchTimelockBlockFunction_Call {
	return &IMcms_DispatchTimelockBlockFunction_Call{Call: _e.mock.On("DispatchTimelockBlockFunction", ctx, opts, timelock, timelockCallbackParams)}
}

func (_c *IMcms_DispatchTimelockBlockFunction_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams)) *IMcms_DispatchTimelockBlockFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *IMcms_DispatchTimelockBlockFunction_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_DispatchTimelockBlockFunction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_DispatchTimelockBlockFunction_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error)) *IMcms_DispatchTimelockBlockFunction_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockBypasserExecuteBatch provides a mock function with given fields: ctx, opts, timelockCallbackParams
func (_m *IMcms) DispatchTimelockBypasserExecuteBatch(ctx context.Context, opts *bind.CallOpts, timelockCallbackParams module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockBypasserExecuteBatch")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.TimelockCallbackParams) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(ctx, opts, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_DispatchTimelockBypasserExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockBypasserExecuteBatch'
type IMcms_DispatchTimelockBypasserExecuteBatch_Call struct {
	*mock.Call
}

// DispatchTimelockBypasserExecuteBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *IMcms_Expecter) DispatchTimelockBypasserExecuteBatch(ctx interface{}, opts interface{}, timelockCallbackParams interface{}) *IMcms_DispatchTimelockBypasserExecuteBatch_Call {
	return &IMcms_DispatchTimelockBypasserExecuteBatch_Call{Call: _e.mock.On("DispatchTimelockBypasserExecuteBatch", ctx, opts, timelockCallbackParams)}
}

func (_c *IMcms_DispatchTimelockBypasserExecuteBatch_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelockCallbackParams module_mcms.TimelockCallbackParams)) *IMcms_DispatchTimelockBypasserExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *IMcms_DispatchTimelockBypasserExecuteBatch_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_DispatchTimelockBypasserExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_DispatchTimelockBypasserExecuteBatch_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error)) *IMcms_DispatchTimelockBypasserExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockCancel provides a mock function with given fields: ctx, opts, timelock, timelockCallbackParams
func (_m *IMcms) DispatchTimelockCancel(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockCancel")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(ctx, opts, timelock, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_DispatchTimelockCancel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockCancel'
type IMcms_DispatchTimelockCancel_Call struct {
	*mock.Call
}

// DispatchTimelockCancel is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *IMcms_Expecter) DispatchTimelockCancel(ctx interface{}, opts interface{}, timelock interface{}, timelockCallbackParams interface{}) *IMcms_DispatchTimelockCancel_Call {
	return &IMcms_DispatchTimelockCancel_Call{Call: _e.mock.On("DispatchTimelockCancel", ctx, opts, timelock, timelockCallbackParams)}
}

func (_c *IMcms_DispatchTimelockCancel_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams)) *IMcms_DispatchTimelockCancel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *IMcms_DispatchTimelockCancel_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_DispatchTimelockCancel_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_DispatchTimelockCancel_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error)) *IMcms_DispatchTimelockCancel_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockExecuteBatch provides a mock function with given fields: ctx, opts, timelock, clock, registry, timelockCallbackParams
func (_m *IMcms) DispatchTimelockExecuteBatch(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, registry bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, clock, registry, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockExecuteBatch")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, clock, registry, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, clock, registry, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(ctx, opts, timelock, clock, registry, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_DispatchTimelockExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockExecuteBatch'
type IMcms_DispatchTimelockExecuteBatch_Call struct {
	*mock.Call
}

// DispatchTimelockExecuteBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - clock bind.Object
//   - registry bind.Object
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *IMcms_Expecter) DispatchTimelockExecuteBatch(ctx interface{}, opts interface{}, timelock interface{}, clock interface{}, registry interface{}, timelockCallbackParams interface{}) *IMcms_DispatchTimelockExecuteBatch_Call {
	return &IMcms_DispatchTimelockExecuteBatch_Call{Call: _e.mock.On("DispatchTimelockExecuteBatch", ctx, opts, timelock, clock, registry, timelockCallbackParams)}
}

func (_c *IMcms_DispatchTimelockExecuteBatch_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, registry bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams)) *IMcms_DispatchTimelockExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(bind.Object), args[5].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *IMcms_DispatchTimelockExecuteBatch_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_DispatchTimelockExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_DispatchTimelockExecuteBatch_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error)) *IMcms_DispatchTimelockExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockScheduleBatch provides a mock function with given fields: ctx, opts, timelock, clock, timelockCallbackParams
func (_m *IMcms) DispatchTimelockScheduleBatch(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, clock, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockScheduleBatch")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, clock, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, clock, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(ctx, opts, timelock, clock, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_DispatchTimelockScheduleBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockScheduleBatch'
type IMcms_DispatchTimelockScheduleBatch_Call struct {
	*mock.Call
}

// DispatchTimelockScheduleBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - clock bind.Object
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *IMcms_Expecter) DispatchTimelockScheduleBatch(ctx interface{}, opts interface{}, timelock interface{}, clock interface{}, timelockCallbackParams interface{}) *IMcms_DispatchTimelockScheduleBatch_Call {
	return &IMcms_DispatchTimelockScheduleBatch_Call{Call: _e.mock.On("DispatchTimelockScheduleBatch", ctx, opts, timelock, clock, timelockCallbackParams)}
}

func (_c *IMcms_DispatchTimelockScheduleBatch_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams)) *IMcms_DispatchTimelockScheduleBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *IMcms_DispatchTimelockScheduleBatch_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_DispatchTimelockScheduleBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_DispatchTimelockScheduleBatch_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error)) *IMcms_DispatchTimelockScheduleBatch_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockUnblockFunction provides a mock function with given fields: ctx, opts, timelock, timelockCallbackParams
func (_m *IMcms) DispatchTimelockUnblockFunction(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockUnblockFunction")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(ctx, opts, timelock, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_DispatchTimelockUnblockFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockUnblockFunction'
type IMcms_DispatchTimelockUnblockFunction_Call struct {
	*mock.Call
}

// DispatchTimelockUnblockFunction is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *IMcms_Expecter) DispatchTimelockUnblockFunction(ctx interface{}, opts interface{}, timelock interface{}, timelockCallbackParams interface{}) *IMcms_DispatchTimelockUnblockFunction_Call {
	return &IMcms_DispatchTimelockUnblockFunction_Call{Call: _e.mock.On("DispatchTimelockUnblockFunction", ctx, opts, timelock, timelockCallbackParams)}
}

func (_c *IMcms_DispatchTimelockUnblockFunction_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams)) *IMcms_DispatchTimelockUnblockFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *IMcms_DispatchTimelockUnblockFunction_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_DispatchTimelockUnblockFunction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_DispatchTimelockUnblockFunction_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error)) *IMcms_DispatchTimelockUnblockFunction_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockUpdateMinDelay provides a mock function with given fields: ctx, opts, timelock, timelockCallbackParams
func (_m *IMcms) DispatchTimelockUpdateMinDelay(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockUpdateMinDelay")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(ctx, opts, timelock, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_DispatchTimelockUpdateMinDelay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockUpdateMinDelay'
type IMcms_DispatchTimelockUpdateMinDelay_Call struct {
	*mock.Call
}

// DispatchTimelockUpdateMinDelay is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *IMcms_Expecter) DispatchTimelockUpdateMinDelay(ctx interface{}, opts interface{}, timelock interface{}, timelockCallbackParams interface{}) *IMcms_DispatchTimelockUpdateMinDelay_Call {
	return &IMcms_DispatchTimelockUpdateMinDelay_Call{Call: _e.mock.On("DispatchTimelockUpdateMinDelay", ctx, opts, timelock, timelockCallbackParams)}
}

func (_c *IMcms_DispatchTimelockUpdateMinDelay_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams)) *IMcms_DispatchTimelockUpdateMinDelay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *IMcms_DispatchTimelockUpdateMinDelay_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_DispatchTimelockUpdateMinDelay_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_DispatchTimelockUpdateMinDelay_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, module_mcms.TimelockCallbackParams) (*models.SuiTransactionBlockResponse, error)) *IMcms_DispatchTimelockUpdateMinDelay_Call {
	_c.Call.Return(run)
	return _c
}

// Encoder provides a mock function with no fields
func (_m *IMcms) Encoder() module_mcms.McmsEncoder {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Encoder")
	}

	var r0 module_mcms.McmsEncoder
	if rf, ok := ret.Get(0).(func() module_mcms.McmsEncoder); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(module_mcms.McmsEncoder)
		}
	}

	return r0
}

// IMcms_Encoder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Encoder'
type IMcms_Encoder_Call struct {
	*mock.Call
}

// Encoder is a helper method to define mock.On call
func (_e *IMcms_Expecter) Encoder() *IMcms_Encoder_Call {
	return &IMcms_Encoder_Call{Call: _e.mock.On("Encoder")}
}

func (_c *IMcms_Encoder_Call) Run(run func()) *IMcms_Encoder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IMcms_Encoder_Call) Return(_a0 module_mcms.McmsEncoder) *IMcms_Encoder_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IMcms_Encoder_Call) RunAndReturn(run func() module_mcms.McmsEncoder) *IMcms_Encoder_Call {
	_c.Call.Return(run)
	return _c
}

// Execute provides a mock function with given fields: ctx, opts, state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof
func (_m *IMcms) Execute(ctx context.Context, opts *bind.CallOpts, state bind.Object, clock bind.Object, role byte, chainId *big.Int, multisigAddr string, nonce uint64, to string, moduleName string, functionName string, data []byte, proof [][]byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, *big.Int, string, uint64, string, string, string, []byte, [][]byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, *big.Int, string, uint64, string, string, string, []byte, [][]byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, *big.Int, string, uint64, string, string, string, []byte, [][]byte) error); ok {
		r1 = rf(ctx, opts, state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type IMcms_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - clock bind.Object
//   - role byte
//   - chainId *big.Int
//   - multisigAddr string
//   - nonce uint64
//   - to string
//   - moduleName string
//   - functionName string
//   - data []byte
//   - proof [][]byte
func (_e *IMcms_Expecter) Execute(ctx interface{}, opts interface{}, state interface{}, clock interface{}, role interface{}, chainId interface{}, multisigAddr interface{}, nonce interface{}, to interface{}, moduleName interface{}, functionName interface{}, data interface{}, proof interface{}) *IMcms_Execute_Call {
	return &IMcms_Execute_Call{Call: _e.mock.On("Execute", ctx, opts, state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)}
}

func (_c *IMcms_Execute_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, clock bind.Object, role byte, chainId *big.Int, multisigAddr string, nonce uint64, to string, moduleName string, functionName string, data []byte, proof [][]byte)) *IMcms_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(byte), args[5].(*big.Int), args[6].(string), args[7].(uint64), args[8].(string), args[9].(string), args[10].(string), args[11].([]byte), args[12].([][]byte))
	})
	return _c
}

func (_c *IMcms_Execute_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_Execute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_Execute_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, *big.Int, string, uint64, string, string, string, []byte, [][]byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// ExpiringRootAndOpCount provides a mock function with given fields: ctx, opts, state, role
func (_m *IMcms) ExpiringRootAndOpCount(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, state, role)

	if len(ret) == 0 {
		panic("no return value specified for ExpiringRootAndOpCount")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, state, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, byte) error); ok {
		r1 = rf(ctx, opts, state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_ExpiringRootAndOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpiringRootAndOpCount'
type IMcms_ExpiringRootAndOpCount_Call struct {
	*mock.Call
}

// ExpiringRootAndOpCount is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - role byte
func (_e *IMcms_Expecter) ExpiringRootAndOpCount(ctx interface{}, opts interface{}, state interface{}, role interface{}) *IMcms_ExpiringRootAndOpCount_Call {
	return &IMcms_ExpiringRootAndOpCount_Call{Call: _e.mock.On("ExpiringRootAndOpCount", ctx, opts, state, role)}
}

func (_c *IMcms_ExpiringRootAndOpCount_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte)) *IMcms_ExpiringRootAndOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(byte))
	})
	return _c
}

func (_c *IMcms_ExpiringRootAndOpCount_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_ExpiringRootAndOpCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_ExpiringRootAndOpCount_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_ExpiringRootAndOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionName provides a mock function with given fields: ctx, opts, function
func (_m *IMcms) FunctionName(ctx context.Context, opts *bind.CallOpts, function module_mcms.Function) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, function)

	if len(ret) == 0 {
		panic("no return value specified for FunctionName")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Function) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, function)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Function) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, function)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Function) error); ok {
		r1 = rf(ctx, opts, function)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_FunctionName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionName'
type IMcms_FunctionName_Call struct {
	*mock.Call
}

// FunctionName is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - function module_mcms.Function
func (_e *IMcms_Expecter) FunctionName(ctx interface{}, opts interface{}, function interface{}) *IMcms_FunctionName_Call {
	return &IMcms_FunctionName_Call{Call: _e.mock.On("FunctionName", ctx, opts, function)}
}

func (_c *IMcms_FunctionName_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, function module_mcms.Function)) *IMcms_FunctionName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Function))
	})
	return _c
}

func (_c *IMcms_FunctionName_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_FunctionName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_FunctionName_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Function) (*models.SuiTransactionBlockResponse, error)) *IMcms_FunctionName_Call {
	_c.Call.Return(run)
	return _c
}

// GetConfig provides a mock function with given fields: ctx, opts, state, role
func (_m *IMcms) GetConfig(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, state, role)

	if len(ret) == 0 {
		panic("no return value specified for GetConfig")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, state, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, byte) error); ok {
		r1 = rf(ctx, opts, state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_GetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConfig'
type IMcms_GetConfig_Call struct {
	*mock.Call
}

// GetConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - role byte
func (_e *IMcms_Expecter) GetConfig(ctx interface{}, opts interface{}, state interface{}, role interface{}) *IMcms_GetConfig_Call {
	return &IMcms_GetConfig_Call{Call: _e.mock.On("GetConfig", ctx, opts, state, role)}
}

func (_c *IMcms_GetConfig_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte)) *IMcms_GetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(byte))
	})
	return _c
}

func (_c *IMcms_GetConfig_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_GetConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_GetConfig_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_GetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetOpCount provides a mock function with given fields: ctx, opts, state, role
func (_m *IMcms) GetOpCount(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, state, role)

	if len(ret) == 0 {
		panic("no return value specified for GetOpCount")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, state, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, byte) error); ok {
		r1 = rf(ctx, opts, state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_GetOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOpCount'
type IMcms_GetOpCount_Call struct {
	*mock.Call
}

// GetOpCount is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - role byte
func (_e *IMcms_Expecter) GetOpCount(ctx interface{}, opts interface{}, state interface{}, role interface{}) *IMcms_GetOpCount_Call {
	return &IMcms_GetOpCount_Call{Call: _e.mock.On("GetOpCount", ctx, opts, state, role)}
}

func (_c *IMcms_GetOpCount_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte)) *IMcms_GetOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(byte))
	})
	return _c
}

func (_c *IMcms_GetOpCount_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_GetOpCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_GetOpCount_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_GetOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoot provides a mock function with given fields: ctx, opts, state, role
func (_m *IMcms) GetRoot(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, state, role)

	if len(ret) == 0 {
		panic("no return value specified for GetRoot")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, state, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, byte) error); ok {
		r1 = rf(ctx, opts, state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_GetRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoot'
type IMcms_GetRoot_Call struct {
	*mock.Call
}

// GetRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - role byte
func (_e *IMcms_Expecter) GetRoot(ctx interface{}, opts interface{}, state interface{}, role interface{}) *IMcms_GetRoot_Call {
	return &IMcms_GetRoot_Call{Call: _e.mock.On("GetRoot", ctx, opts, state, role)}
}

func (_c *IMcms_GetRoot_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte)) *IMcms_GetRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(byte))
	})
	return _c
}

func (_c *IMcms_GetRoot_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_GetRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_GetRoot_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_GetRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetRootMetadata provides a mock function with given fields: ctx, opts, state, role
func (_m *IMcms) GetRootMetadata(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, state, role)

	if len(ret) == 0 {
		panic("no return value specified for GetRootMetadata")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, state, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, byte) error); ok {
		r1 = rf(ctx, opts, state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_GetRootMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRootMetadata'
type IMcms_GetRootMetadata_Call struct {
	*mock.Call
}

// GetRootMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - role byte
func (_e *IMcms_Expecter) GetRootMetadata(ctx interface{}, opts interface{}, state interface{}, role interface{}) *IMcms_GetRootMetadata_Call {
	return &IMcms_GetRootMetadata_Call{Call: _e.mock.On("GetRootMetadata", ctx, opts, state, role)}
}

func (_c *IMcms_GetRootMetadata_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte)) *IMcms_GetRootMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(byte))
	})
	return _c
}

func (_c *IMcms_GetRootMetadata_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_GetRootMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_GetRootMetadata_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_GetRootMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// HashOpLeaf provides a mock function with given fields: ctx, opts, domainSeparator, op
func (_m *IMcms) HashOpLeaf(ctx context.Context, opts *bind.CallOpts, domainSeparator []byte, op module_mcms.Op) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, domainSeparator, op)

	if len(ret) == 0 {
		panic("no return value specified for HashOpLeaf")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []byte, module_mcms.Op) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, domainSeparator, op)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []byte, module_mcms.Op) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, domainSeparator, op)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, []byte, module_mcms.Op) error); ok {
		r1 = rf(ctx, opts, domainSeparator, op)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_HashOpLeaf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashOpLeaf'
type IMcms_HashOpLeaf_Call struct {
	*mock.Call
}

// HashOpLeaf is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - domainSeparator []byte
//   - op module_mcms.Op
func (_e *IMcms_Expecter) HashOpLeaf(ctx interface{}, opts interface{}, domainSeparator interface{}, op interface{}) *IMcms_HashOpLeaf_Call {
	return &IMcms_HashOpLeaf_Call{Call: _e.mock.On("HashOpLeaf", ctx, opts, domainSeparator, op)}
}

func (_c *IMcms_HashOpLeaf_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, domainSeparator []byte, op module_mcms.Op)) *IMcms_HashOpLeaf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].([]byte), args[3].(module_mcms.Op))
	})
	return _c
}

func (_c *IMcms_HashOpLeaf_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_HashOpLeaf_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_HashOpLeaf_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, []byte, module_mcms.Op) (*models.SuiTransactionBlockResponse, error)) *IMcms_HashOpLeaf_Call {
	_c.Call.Return(run)
	return _c
}

// HashOperationBatch provides a mock function with given fields: ctx, opts, calls, predecessor, salt
func (_m *IMcms) HashOperationBatch(ctx context.Context, opts *bind.CallOpts, calls []module_mcms.Call, predecessor []byte, salt []byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, calls, predecessor, salt)

	if len(ret) == 0 {
		panic("no return value specified for HashOperationBatch")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []module_mcms.Call, []byte, []byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, calls, predecessor, salt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []module_mcms.Call, []byte, []byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, calls, predecessor, salt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, []module_mcms.Call, []byte, []byte) error); ok {
		r1 = rf(ctx, opts, calls, predecessor, salt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_HashOperationBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashOperationBatch'
type IMcms_HashOperationBatch_Call struct {
	*mock.Call
}

// HashOperationBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - calls []module_mcms.Call
//   - predecessor []byte
//   - salt []byte
func (_e *IMcms_Expecter) HashOperationBatch(ctx interface{}, opts interface{}, calls interface{}, predecessor interface{}, salt interface{}) *IMcms_HashOperationBatch_Call {
	return &IMcms_HashOperationBatch_Call{Call: _e.mock.On("HashOperationBatch", ctx, opts, calls, predecessor, salt)}
}

func (_c *IMcms_HashOperationBatch_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, calls []module_mcms.Call, predecessor []byte, salt []byte)) *IMcms_HashOperationBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].([]module_mcms.Call), args[3].([]byte), args[4].([]byte))
	})
	return _c
}

func (_c *IMcms_HashOperationBatch_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_HashOperationBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_HashOperationBatch_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, []module_mcms.Call, []byte, []byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_HashOperationBatch_Call {
	_c.Call.Return(run)
	return _c
}

// IsValidRole provides a mock function with given fields: ctx, opts, role
func (_m *IMcms) IsValidRole(ctx context.Context, opts *bind.CallOpts, role byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, role)

	if len(ret) == 0 {
		panic("no return value specified for IsValidRole")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, byte) error); ok {
		r1 = rf(ctx, opts, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_IsValidRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsValidRole'
type IMcms_IsValidRole_Call struct {
	*mock.Call
}

// IsValidRole is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - role byte
func (_e *IMcms_Expecter) IsValidRole(ctx interface{}, opts interface{}, role interface{}) *IMcms_IsValidRole_Call {
	return &IMcms_IsValidRole_Call{Call: _e.mock.On("IsValidRole", ctx, opts, role)}
}

func (_c *IMcms_IsValidRole_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, role byte)) *IMcms_IsValidRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(byte))
	})
	return _c
}

func (_c *IMcms_IsValidRole_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_IsValidRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_IsValidRole_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_IsValidRole_Call {
	_c.Call.Return(run)
	return _c
}

// MaxNumSigners provides a mock function with given fields: ctx, opts
func (_m *IMcms) MaxNumSigners(ctx context.Context, opts *bind.CallOpts) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for MaxNumSigners")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_MaxNumSigners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxNumSigners'
type IMcms_MaxNumSigners_Call struct {
	*mock.Call
}

// MaxNumSigners is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
func (_e *IMcms_Expecter) MaxNumSigners(ctx interface{}, opts interface{}) *IMcms_MaxNumSigners_Call {
	return &IMcms_MaxNumSigners_Call{Call: _e.mock.On("MaxNumSigners", ctx, opts)}
}

func (_c *IMcms_MaxNumSigners_Call) Run(run func(ctx context.Context, opts *bind.CallOpts)) *IMcms_MaxNumSigners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts))
	})
	return _c
}

func (_c *IMcms_MaxNumSigners_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_MaxNumSigners_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_MaxNumSigners_Call) RunAndReturn(run func(context.Context, *bind.CallOpts) (*models.SuiTransactionBlockResponse, error)) *IMcms_MaxNumSigners_Call {
	_c.Call.Return(run)
	return _c
}

// McmsDispatchToAccount provides a mock function with given fields: ctx, opts, registry, accountState, executingCallbackParams
func (_m *IMcms) McmsDispatchToAccount(ctx context.Context, opts *bind.CallOpts, registry bind.Object, accountState bind.Object, executingCallbackParams bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, registry, accountState, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsDispatchToAccount")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, registry, accountState, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, registry, accountState, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, registry, accountState, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_McmsDispatchToAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsDispatchToAccount'
type IMcms_McmsDispatchToAccount_Call struct {
	*mock.Call
}

// McmsDispatchToAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - registry bind.Object
//   - accountState bind.Object
//   - executingCallbackParams bind.Object
func (_e *IMcms_Expecter) McmsDispatchToAccount(ctx interface{}, opts interface{}, registry interface{}, accountState interface{}, executingCallbackParams interface{}) *IMcms_McmsDispatchToAccount_Call {
	return &IMcms_McmsDispatchToAccount_Call{Call: _e.mock.On("McmsDispatchToAccount", ctx, opts, registry, accountState, executingCallbackParams)}
}

func (_c *IMcms_McmsDispatchToAccount_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, registry bind.Object, accountState bind.Object, executingCallbackParams bind.Object)) *IMcms_McmsDispatchToAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(bind.Object))
	})
	return _c
}

func (_c *IMcms_McmsDispatchToAccount_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_McmsDispatchToAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_McmsDispatchToAccount_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcms_McmsDispatchToAccount_Call {
	_c.Call.Return(run)
	return _c
}

// McmsDispatchToDeployer provides a mock function with given fields: ctx, opts, registry, deployerState, executingCallbackParams
func (_m *IMcms) McmsDispatchToDeployer(ctx context.Context, opts *bind.CallOpts, registry bind.Object, deployerState bind.Object, executingCallbackParams bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, registry, deployerState, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsDispatchToDeployer")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, registry, deployerState, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, registry, deployerState, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, registry, deployerState, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_McmsDispatchToDeployer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsDispatchToDeployer'
type IMcms_McmsDispatchToDeployer_Call struct {
	*mock.Call
}

// McmsDispatchToDeployer is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - registry bind.Object
//   - deployerState bind.Object
//   - executingCallbackParams bind.Object
func (_e *IMcms_Expecter) McmsDispatchToDeployer(ctx interface{}, opts interface{}, registry interface{}, deployerState interface{}, executingCallbackParams interface{}) *IMcms_McmsDispatchToDeployer_Call {
	return &IMcms_McmsDispatchToDeployer_Call{Call: _e.mock.On("McmsDispatchToDeployer", ctx, opts, registry, deployerState, executingCallbackParams)}
}

func (_c *IMcms_McmsDispatchToDeployer_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, registry bind.Object, deployerState bind.Object, executingCallbackParams bind.Object)) *IMcms_McmsDispatchToDeployer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(bind.Object))
	})
	return _c
}

func (_c *IMcms_McmsDispatchToDeployer_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_McmsDispatchToDeployer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_McmsDispatchToDeployer_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcms_McmsDispatchToDeployer_Call {
	_c.Call.Return(run)
	return _c
}

// McmsDispatchToRegistry provides a mock function with given fields: ctx, opts, registry, executingCallbackParams
func (_m *IMcms) McmsDispatchToRegistry(ctx context.Context, opts *bind.CallOpts, registry bind.Object, executingCallbackParams bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsDispatchToRegistry")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_McmsDispatchToRegistry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsDispatchToRegistry'
type IMcms_McmsDispatchToRegistry_Call struct {
	*mock.Call
}

// McmsDispatchToRegistry is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *IMcms_Expecter) McmsDispatchToRegistry(ctx interface{}, opts interface{}, registry interface{}, executingCallbackParams interface{}) *IMcms_McmsDispatchToRegistry_Call {
	return &IMcms_McmsDispatchToRegistry_Call{Call: _e.mock.On("McmsDispatchToRegistry", ctx, opts, registry, executingCallbackParams)}
}

func (_c *IMcms_McmsDispatchToRegistry_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, registry bind.Object, executingCallbackParams bind.Object)) *IMcms_McmsDispatchToRegistry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object))
	})
	return _c
}

func (_c *IMcms_McmsDispatchToRegistry_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_McmsDispatchToRegistry_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_McmsDispatchToRegistry_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcms_McmsDispatchToRegistry_Call {
	_c.Call.Return(run)
	return _c
}

// McmsSetConfig provides a mock function with given fields: ctx, opts, registry, state, executingCallbackParams
func (_m *IMcms) McmsSetConfig(ctx context.Context, opts *bind.CallOpts, registry bind.Object, state bind.Object, executingCallbackParams bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, registry, state, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsSetConfig")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, registry, state, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, registry, state, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, registry, state, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_McmsSetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsSetConfig'
type IMcms_McmsSetConfig_Call struct {
	*mock.Call
}

// McmsSetConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - registry bind.Object
//   - state bind.Object
//   - executingCallbackParams bind.Object
func (_e *IMcms_Expecter) McmsSetConfig(ctx interface{}, opts interface{}, registry interface{}, state interface{}, executingCallbackParams interface{}) *IMcms_McmsSetConfig_Call {
	return &IMcms_McmsSetConfig_Call{Call: _e.mock.On("McmsSetConfig", ctx, opts, registry, state, executingCallbackParams)}
}

func (_c *IMcms_McmsSetConfig_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, registry bind.Object, state bind.Object, executingCallbackParams bind.Object)) *IMcms_McmsSetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(bind.Object))
	})
	return _c
}

func (_c *IMcms_McmsSetConfig_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_McmsSetConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_McmsSetConfig_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcms_McmsSetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockBlockFunction provides a mock function with given fields: ctx, opts, timelock, registry, executingCallbackParams
func (_m *IMcms) McmsTimelockBlockFunction(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockBlockFunction")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, timelock, registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_McmsTimelockBlockFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockBlockFunction'
type IMcms_McmsTimelockBlockFunction_Call struct {
	*mock.Call
}

// McmsTimelockBlockFunction is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *IMcms_Expecter) McmsTimelockBlockFunction(ctx interface{}, opts interface{}, timelock interface{}, registry interface{}, executingCallbackParams interface{}) *IMcms_McmsTimelockBlockFunction_Call {
	return &IMcms_McmsTimelockBlockFunction_Call{Call: _e.mock.On("McmsTimelockBlockFunction", ctx, opts, timelock, registry, executingCallbackParams)}
}

func (_c *IMcms_McmsTimelockBlockFunction_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object)) *IMcms_McmsTimelockBlockFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(bind.Object))
	})
	return _c
}

func (_c *IMcms_McmsTimelockBlockFunction_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_McmsTimelockBlockFunction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_McmsTimelockBlockFunction_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcms_McmsTimelockBlockFunction_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockBypasserExecuteBatch provides a mock function with given fields: ctx, opts, registry, executingCallbackParams
func (_m *IMcms) McmsTimelockBypasserExecuteBatch(ctx context.Context, opts *bind.CallOpts, registry bind.Object, executingCallbackParams bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockBypasserExecuteBatch")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_McmsTimelockBypasserExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockBypasserExecuteBatch'
type IMcms_McmsTimelockBypasserExecuteBatch_Call struct {
	*mock.Call
}

// McmsTimelockBypasserExecuteBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *IMcms_Expecter) McmsTimelockBypasserExecuteBatch(ctx interface{}, opts interface{}, registry interface{}, executingCallbackParams interface{}) *IMcms_McmsTimelockBypasserExecuteBatch_Call {
	return &IMcms_McmsTimelockBypasserExecuteBatch_Call{Call: _e.mock.On("McmsTimelockBypasserExecuteBatch", ctx, opts, registry, executingCallbackParams)}
}

func (_c *IMcms_McmsTimelockBypasserExecuteBatch_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, registry bind.Object, executingCallbackParams bind.Object)) *IMcms_McmsTimelockBypasserExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object))
	})
	return _c
}

func (_c *IMcms_McmsTimelockBypasserExecuteBatch_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_McmsTimelockBypasserExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_McmsTimelockBypasserExecuteBatch_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcms_McmsTimelockBypasserExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockCancel provides a mock function with given fields: ctx, opts, timelock, registry, executingCallbackParams
func (_m *IMcms) McmsTimelockCancel(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockCancel")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, timelock, registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_McmsTimelockCancel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockCancel'
type IMcms_McmsTimelockCancel_Call struct {
	*mock.Call
}

// McmsTimelockCancel is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *IMcms_Expecter) McmsTimelockCancel(ctx interface{}, opts interface{}, timelock interface{}, registry interface{}, executingCallbackParams interface{}) *IMcms_McmsTimelockCancel_Call {
	return &IMcms_McmsTimelockCancel_Call{Call: _e.mock.On("McmsTimelockCancel", ctx, opts, timelock, registry, executingCallbackParams)}
}

func (_c *IMcms_McmsTimelockCancel_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object)) *IMcms_McmsTimelockCancel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(bind.Object))
	})
	return _c
}

func (_c *IMcms_McmsTimelockCancel_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_McmsTimelockCancel_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_McmsTimelockCancel_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcms_McmsTimelockCancel_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockExecuteBatch provides a mock function with given fields: ctx, opts, timelock, clock, registry, executingCallbackParams
func (_m *IMcms) McmsTimelockExecuteBatch(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, registry bind.Object, executingCallbackParams bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, clock, registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockExecuteBatch")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, clock, registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, clock, registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, timelock, clock, registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_McmsTimelockExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockExecuteBatch'
type IMcms_McmsTimelockExecuteBatch_Call struct {
	*mock.Call
}

// McmsTimelockExecuteBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - clock bind.Object
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *IMcms_Expecter) McmsTimelockExecuteBatch(ctx interface{}, opts interface{}, timelock interface{}, clock interface{}, registry interface{}, executingCallbackParams interface{}) *IMcms_McmsTimelockExecuteBatch_Call {
	return &IMcms_McmsTimelockExecuteBatch_Call{Call: _e.mock.On("McmsTimelockExecuteBatch", ctx, opts, timelock, clock, registry, executingCallbackParams)}
}

func (_c *IMcms_McmsTimelockExecuteBatch_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, registry bind.Object, executingCallbackParams bind.Object)) *IMcms_McmsTimelockExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(bind.Object), args[5].(bind.Object))
	})
	return _c
}

func (_c *IMcms_McmsTimelockExecuteBatch_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_McmsTimelockExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_McmsTimelockExecuteBatch_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcms_McmsTimelockExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockScheduleBatch provides a mock function with given fields: ctx, opts, timelock, clock, registry, executingCallbackParams
func (_m *IMcms) McmsTimelockScheduleBatch(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, registry bind.Object, executingCallbackParams bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, clock, registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockScheduleBatch")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, clock, registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, clock, registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, timelock, clock, registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_McmsTimelockScheduleBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockScheduleBatch'
type IMcms_McmsTimelockScheduleBatch_Call struct {
	*mock.Call
}

// McmsTimelockScheduleBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - clock bind.Object
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *IMcms_Expecter) McmsTimelockScheduleBatch(ctx interface{}, opts interface{}, timelock interface{}, clock interface{}, registry interface{}, executingCallbackParams interface{}) *IMcms_McmsTimelockScheduleBatch_Call {
	return &IMcms_McmsTimelockScheduleBatch_Call{Call: _e.mock.On("McmsTimelockScheduleBatch", ctx, opts, timelock, clock, registry, executingCallbackParams)}
}

func (_c *IMcms_McmsTimelockScheduleBatch_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, registry bind.Object, executingCallbackParams bind.Object)) *IMcms_McmsTimelockScheduleBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(bind.Object), args[5].(bind.Object))
	})
	return _c
}

func (_c *IMcms_McmsTimelockScheduleBatch_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_McmsTimelockScheduleBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_McmsTimelockScheduleBatch_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcms_McmsTimelockScheduleBatch_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockUnblockFunction provides a mock function with given fields: ctx, opts, timelock, registry, executingCallbackParams
func (_m *IMcms) McmsTimelockUnblockFunction(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockUnblockFunction")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, timelock, registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_McmsTimelockUnblockFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockUnblockFunction'
type IMcms_McmsTimelockUnblockFunction_Call struct {
	*mock.Call
}

// McmsTimelockUnblockFunction is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *IMcms_Expecter) McmsTimelockUnblockFunction(ctx interface{}, opts interface{}, timelock interface{}, registry interface{}, executingCallbackParams interface{}) *IMcms_McmsTimelockUnblockFunction_Call {
	return &IMcms_McmsTimelockUnblockFunction_Call{Call: _e.mock.On("McmsTimelockUnblockFunction", ctx, opts, timelock, registry, executingCallbackParams)}
}

func (_c *IMcms_McmsTimelockUnblockFunction_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object)) *IMcms_McmsTimelockUnblockFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(bind.Object))
	})
	return _c
}

func (_c *IMcms_McmsTimelockUnblockFunction_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_McmsTimelockUnblockFunction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_McmsTimelockUnblockFunction_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcms_McmsTimelockUnblockFunction_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockUpdateMinDelay provides a mock function with given fields: ctx, opts, timelock, registry, executingCallbackParams
func (_m *IMcms) McmsTimelockUpdateMinDelay(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockUpdateMinDelay")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, timelock, registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_McmsTimelockUpdateMinDelay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockUpdateMinDelay'
type IMcms_McmsTimelockUpdateMinDelay_Call struct {
	*mock.Call
}

// McmsTimelockUpdateMinDelay is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *IMcms_Expecter) McmsTimelockUpdateMinDelay(ctx interface{}, opts interface{}, timelock interface{}, registry interface{}, executingCallbackParams interface{}) *IMcms_McmsTimelockUpdateMinDelay_Call {
	return &IMcms_McmsTimelockUpdateMinDelay_Call{Call: _e.mock.On("McmsTimelockUpdateMinDelay", ctx, opts, timelock, registry, executingCallbackParams)}
}

func (_c *IMcms_McmsTimelockUpdateMinDelay_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object)) *IMcms_McmsTimelockUpdateMinDelay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(bind.Object))
	})
	return _c
}

func (_c *IMcms_McmsTimelockUpdateMinDelay_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_McmsTimelockUpdateMinDelay_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_McmsTimelockUpdateMinDelay_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcms_McmsTimelockUpdateMinDelay_Call {
	_c.Call.Return(run)
	return _c
}

// ModuleName provides a mock function with given fields: ctx, opts, function
func (_m *IMcms) ModuleName(ctx context.Context, opts *bind.CallOpts, function module_mcms.Function) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, function)

	if len(ret) == 0 {
		panic("no return value specified for ModuleName")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Function) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, function)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Function) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, function)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Function) error); ok {
		r1 = rf(ctx, opts, function)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_ModuleName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModuleName'
type IMcms_ModuleName_Call struct {
	*mock.Call
}

// ModuleName is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - function module_mcms.Function
func (_e *IMcms_Expecter) ModuleName(ctx interface{}, opts interface{}, function interface{}) *IMcms_ModuleName_Call {
	return &IMcms_ModuleName_Call{Call: _e.mock.On("ModuleName", ctx, opts, function)}
}

func (_c *IMcms_ModuleName_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, function module_mcms.Function)) *IMcms_ModuleName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Function))
	})
	return _c
}

func (_c *IMcms_ModuleName_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_ModuleName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_ModuleName_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Function) (*models.SuiTransactionBlockResponse, error)) *IMcms_ModuleName_Call {
	_c.Call.Return(run)
	return _c
}

// NumGroups provides a mock function with given fields: ctx, opts
func (_m *IMcms) NumGroups(ctx context.Context, opts *bind.CallOpts) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for NumGroups")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_NumGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NumGroups'
type IMcms_NumGroups_Call struct {
	*mock.Call
}

// NumGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
func (_e *IMcms_Expecter) NumGroups(ctx interface{}, opts interface{}) *IMcms_NumGroups_Call {
	return &IMcms_NumGroups_Call{Call: _e.mock.On("NumGroups", ctx, opts)}
}

func (_c *IMcms_NumGroups_Call) Run(run func(ctx context.Context, opts *bind.CallOpts)) *IMcms_NumGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts))
	})
	return _c
}

func (_c *IMcms_NumGroups_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_NumGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_NumGroups_Call) RunAndReturn(run func(context.Context, *bind.CallOpts) (*models.SuiTransactionBlockResponse, error)) *IMcms_NumGroups_Call {
	_c.Call.Return(run)
	return _c
}

// OverridePreviousRoot provides a mock function with given fields: ctx, opts, rootMetadata
func (_m *IMcms) OverridePreviousRoot(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for OverridePreviousRoot")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, rootMetadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) error); ok {
		r1 = rf(ctx, opts, rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_OverridePreviousRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OverridePreviousRoot'
type IMcms_OverridePreviousRoot_Call struct {
	*mock.Call
}

// OverridePreviousRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - rootMetadata module_mcms.RootMetadata
func (_e *IMcms_Expecter) OverridePreviousRoot(ctx interface{}, opts interface{}, rootMetadata interface{}) *IMcms_OverridePreviousRoot_Call {
	return &IMcms_OverridePreviousRoot_Call{Call: _e.mock.On("OverridePreviousRoot", ctx, opts, rootMetadata)}
}

func (_c *IMcms_OverridePreviousRoot_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata)) *IMcms_OverridePreviousRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *IMcms_OverridePreviousRoot_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_OverridePreviousRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_OverridePreviousRoot_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error)) *IMcms_OverridePreviousRoot_Call {
	_c.Call.Return(run)
	return _c
}

// PostOpCount provides a mock function with given fields: ctx, opts, rootMetadata
func (_m *IMcms) PostOpCount(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for PostOpCount")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, rootMetadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) error); ok {
		r1 = rf(ctx, opts, rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_PostOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PostOpCount'
type IMcms_PostOpCount_Call struct {
	*mock.Call
}

// PostOpCount is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - rootMetadata module_mcms.RootMetadata
func (_e *IMcms_Expecter) PostOpCount(ctx interface{}, opts interface{}, rootMetadata interface{}) *IMcms_PostOpCount_Call {
	return &IMcms_PostOpCount_Call{Call: _e.mock.On("PostOpCount", ctx, opts, rootMetadata)}
}

func (_c *IMcms_PostOpCount_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata)) *IMcms_PostOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *IMcms_PostOpCount_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_PostOpCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_PostOpCount_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error)) *IMcms_PostOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// PreOpCount provides a mock function with given fields: ctx, opts, rootMetadata
func (_m *IMcms) PreOpCount(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for PreOpCount")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, rootMetadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) error); ok {
		r1 = rf(ctx, opts, rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_PreOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PreOpCount'
type IMcms_PreOpCount_Call struct {
	*mock.Call
}

// PreOpCount is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - rootMetadata module_mcms.RootMetadata
func (_e *IMcms_Expecter) PreOpCount(ctx interface{}, opts interface{}, rootMetadata interface{}) *IMcms_PreOpCount_Call {
	return &IMcms_PreOpCount_Call{Call: _e.mock.On("PreOpCount", ctx, opts, rootMetadata)}
}

func (_c *IMcms_PreOpCount_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata)) *IMcms_PreOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *IMcms_PreOpCount_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_PreOpCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_PreOpCount_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error)) *IMcms_PreOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// ProposerRole provides a mock function with given fields: ctx, opts
func (_m *IMcms) ProposerRole(ctx context.Context, opts *bind.CallOpts) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ProposerRole")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_ProposerRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProposerRole'
type IMcms_ProposerRole_Call struct {
	*mock.Call
}

// ProposerRole is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
func (_e *IMcms_Expecter) ProposerRole(ctx interface{}, opts interface{}) *IMcms_ProposerRole_Call {
	return &IMcms_ProposerRole_Call{Call: _e.mock.On("ProposerRole", ctx, opts)}
}

func (_c *IMcms_ProposerRole_Call) Run(run func(ctx context.Context, opts *bind.CallOpts)) *IMcms_ProposerRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts))
	})
	return _c
}

func (_c *IMcms_ProposerRole_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_ProposerRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_ProposerRole_Call) RunAndReturn(run func(context.Context, *bind.CallOpts) (*models.SuiTransactionBlockResponse, error)) *IMcms_ProposerRole_Call {
	_c.Call.Return(run)
	return _c
}

// Role provides a mock function with given fields: ctx, opts, rootMetadata
func (_m *IMcms) Role(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for Role")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, rootMetadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) error); ok {
		r1 = rf(ctx, opts, rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_Role_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Role'
type IMcms_Role_Call struct {
	*mock.Call
}

// Role is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - rootMetadata module_mcms.RootMetadata
func (_e *IMcms_Expecter) Role(ctx interface{}, opts interface{}, rootMetadata interface{}) *IMcms_Role_Call {
	return &IMcms_Role_Call{Call: _e.mock.On("Role", ctx, opts, rootMetadata)}
}

func (_c *IMcms_Role_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata)) *IMcms_Role_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *IMcms_Role_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_Role_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_Role_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error)) *IMcms_Role_Call {
	_c.Call.Return(run)
	return _c
}

// RootMetadata provides a mock function with given fields: ctx, opts, multisig
func (_m *IMcms) RootMetadata(ctx context.Context, opts *bind.CallOpts, multisig module_mcms.Multisig) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, multisig)

	if len(ret) == 0 {
		panic("no return value specified for RootMetadata")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Multisig) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, multisig)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Multisig) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, multisig)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Multisig) error); ok {
		r1 = rf(ctx, opts, multisig)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_RootMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RootMetadata'
type IMcms_RootMetadata_Call struct {
	*mock.Call
}

// RootMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - multisig module_mcms.Multisig
func (_e *IMcms_Expecter) RootMetadata(ctx interface{}, opts interface{}, multisig interface{}) *IMcms_RootMetadata_Call {
	return &IMcms_RootMetadata_Call{Call: _e.mock.On("RootMetadata", ctx, opts, multisig)}
}

func (_c *IMcms_RootMetadata_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, multisig module_mcms.Multisig)) *IMcms_RootMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Multisig))
	})
	return _c
}

func (_c *IMcms_RootMetadata_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_RootMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_RootMetadata_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Multisig) (*models.SuiTransactionBlockResponse, error)) *IMcms_RootMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// RootMetadataMultisig provides a mock function with given fields: ctx, opts, rootMetadata
func (_m *IMcms) RootMetadataMultisig(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for RootMetadataMultisig")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, rootMetadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) error); ok {
		r1 = rf(ctx, opts, rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_RootMetadataMultisig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RootMetadataMultisig'
type IMcms_RootMetadataMultisig_Call struct {
	*mock.Call
}

// RootMetadataMultisig is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - rootMetadata module_mcms.RootMetadata
func (_e *IMcms_Expecter) RootMetadataMultisig(ctx interface{}, opts interface{}, rootMetadata interface{}) *IMcms_RootMetadataMultisig_Call {
	return &IMcms_RootMetadataMultisig_Call{Call: _e.mock.On("RootMetadataMultisig", ctx, opts, rootMetadata)}
}

func (_c *IMcms_RootMetadataMultisig_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata)) *IMcms_RootMetadataMultisig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *IMcms_RootMetadataMultisig_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_RootMetadataMultisig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_RootMetadataMultisig_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (*models.SuiTransactionBlockResponse, error)) *IMcms_RootMetadataMultisig_Call {
	_c.Call.Return(run)
	return _c
}

// SeenSignedHashes provides a mock function with given fields: ctx, opts, state, role
func (_m *IMcms) SeenSignedHashes(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, state, role)

	if len(ret) == 0 {
		panic("no return value specified for SeenSignedHashes")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, state, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, byte) error); ok {
		r1 = rf(ctx, opts, state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_SeenSignedHashes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SeenSignedHashes'
type IMcms_SeenSignedHashes_Call struct {
	*mock.Call
}

// SeenSignedHashes is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - role byte
func (_e *IMcms_Expecter) SeenSignedHashes(ctx interface{}, opts interface{}, state interface{}, role interface{}) *IMcms_SeenSignedHashes_Call {
	return &IMcms_SeenSignedHashes_Call{Call: _e.mock.On("SeenSignedHashes", ctx, opts, state, role)}
}

func (_c *IMcms_SeenSignedHashes_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte)) *IMcms_SeenSignedHashes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(byte))
	})
	return _c
}

func (_c *IMcms_SeenSignedHashes_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_SeenSignedHashes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_SeenSignedHashes_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_SeenSignedHashes_Call {
	_c.Call.Return(run)
	return _c
}

// SetConfig provides a mock function with given fields: ctx, opts, param, state, role, chainId, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot
func (_m *IMcms) SetConfig(ctx context.Context, opts *bind.CallOpts, param bind.Object, state bind.Object, role byte, chainId *big.Int, signerAddresses [][]byte, signerGroups []byte, groupQuorums []byte, groupParents []byte, clearRoot bool) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, param, state, role, chainId, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)

	if len(ret) == 0 {
		panic("no return value specified for SetConfig")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, *big.Int, [][]byte, []byte, []byte, []byte, bool) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, param, state, role, chainId, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, *big.Int, [][]byte, []byte, []byte, []byte, bool) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, param, state, role, chainId, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, *big.Int, [][]byte, []byte, []byte, []byte, bool) error); ok {
		r1 = rf(ctx, opts, param, state, role, chainId, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_SetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetConfig'
type IMcms_SetConfig_Call struct {
	*mock.Call
}

// SetConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - param bind.Object
//   - state bind.Object
//   - role byte
//   - chainId *big.Int
//   - signerAddresses [][]byte
//   - signerGroups []byte
//   - groupQuorums []byte
//   - groupParents []byte
//   - clearRoot bool
func (_e *IMcms_Expecter) SetConfig(ctx interface{}, opts interface{}, param interface{}, state interface{}, role interface{}, chainId interface{}, signerAddresses interface{}, signerGroups interface{}, groupQuorums interface{}, groupParents interface{}, clearRoot interface{}) *IMcms_SetConfig_Call {
	return &IMcms_SetConfig_Call{Call: _e.mock.On("SetConfig", ctx, opts, param, state, role, chainId, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)}
}

func (_c *IMcms_SetConfig_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, param bind.Object, state bind.Object, role byte, chainId *big.Int, signerAddresses [][]byte, signerGroups []byte, groupQuorums []byte, groupParents []byte, clearRoot bool)) *IMcms_SetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(byte), args[5].(*big.Int), args[6].([][]byte), args[7].([]byte), args[8].([]byte), args[9].([]byte), args[10].(bool))
	})
	return _c
}

func (_c *IMcms_SetConfig_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_SetConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_SetConfig_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, *big.Int, [][]byte, []byte, []byte, []byte, bool) (*models.SuiTransactionBlockResponse, error)) *IMcms_SetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// SetRoot provides a mock function with given fields: ctx, opts, state, clock, role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures
func (_m *IMcms) SetRoot(ctx context.Context, opts *bind.CallOpts, state bind.Object, clock bind.Object, role byte, root []byte, validUntil uint64, chainId *big.Int, multisigAddr string, preOpCount uint64, postOpCount uint64, overridePreviousRoot bool, metadataProof [][]byte, signatures [][]byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, state, clock, role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)

	if len(ret) == 0 {
		panic("no return value specified for SetRoot")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, []byte, uint64, *big.Int, string, uint64, uint64, bool, [][]byte, [][]byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, state, clock, role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, []byte, uint64, *big.Int, string, uint64, uint64, bool, [][]byte, [][]byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, state, clock, role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, []byte, uint64, *big.Int, string, uint64, uint64, bool, [][]byte, [][]byte) error); ok {
		r1 = rf(ctx, opts, state, clock, role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_SetRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRoot'
type IMcms_SetRoot_Call struct {
	*mock.Call
}

// SetRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - clock bind.Object
//   - role byte
//   - root []byte
//   - validUntil uint64
//   - chainId *big.Int
//   - multisigAddr string
//   - preOpCount uint64
//   - postOpCount uint64
//   - overridePreviousRoot bool
//   - metadataProof [][]byte
//   - signatures [][]byte
func (_e *IMcms_Expecter) SetRoot(ctx interface{}, opts interface{}, state interface{}, clock interface{}, role interface{}, root interface{}, validUntil interface{}, chainId interface{}, multisigAddr interface{}, preOpCount interface{}, postOpCount interface{}, overridePreviousRoot interface{}, metadataProof interface{}, signatures interface{}) *IMcms_SetRoot_Call {
	return &IMcms_SetRoot_Call{Call: _e.mock.On("SetRoot", ctx, opts, state, clock, role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)}
}

func (_c *IMcms_SetRoot_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, clock bind.Object, role byte, root []byte, validUntil uint64, chainId *big.Int, multisigAddr string, preOpCount uint64, postOpCount uint64, overridePreviousRoot bool, metadataProof [][]byte, signatures [][]byte)) *IMcms_SetRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(byte), args[5].([]byte), args[6].(uint64), args[7].(*big.Int), args[8].(string), args[9].(uint64), args[10].(uint64), args[11].(bool), args[12].([][]byte), args[13].([][]byte))
	})
	return _c
}

func (_c *IMcms_SetRoot_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_SetRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_SetRoot_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, []byte, uint64, *big.Int, string, uint64, uint64, bool, [][]byte, [][]byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_SetRoot_Call {
	_c.Call.Return(run)
	return _c
}

// SignerView provides a mock function with given fields: ctx, opts, signer
func (_m *IMcms) SignerView(ctx context.Context, opts *bind.CallOpts, signer module_mcms.Signer) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, signer)

	if len(ret) == 0 {
		panic("no return value specified for SignerView")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Signer) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, signer)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Signer) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, signer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Signer) error); ok {
		r1 = rf(ctx, opts, signer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_SignerView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignerView'
type IMcms_SignerView_Call struct {
	*mock.Call
}

// SignerView is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - signer module_mcms.Signer
func (_e *IMcms_Expecter) SignerView(ctx interface{}, opts interface{}, signer interface{}) *IMcms_SignerView_Call {
	return &IMcms_SignerView_Call{Call: _e.mock.On("SignerView", ctx, opts, signer)}
}

func (_c *IMcms_SignerView_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, signer module_mcms.Signer)) *IMcms_SignerView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Signer))
	})
	return _c
}

func (_c *IMcms_SignerView_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_SignerView_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_SignerView_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Signer) (*models.SuiTransactionBlockResponse, error)) *IMcms_SignerView_Call {
	_c.Call.Return(run)
	return _c
}

// Signers provides a mock function with given fields: ctx, opts, state, role
func (_m *IMcms) Signers(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, state, role)

	if len(ret) == 0 {
		panic("no return value specified for Signers")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, state, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, byte) error); ok {
		r1 = rf(ctx, opts, state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_Signers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Signers'
type IMcms_Signers_Call struct {
	*mock.Call
}

// Signers is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - role byte
func (_e *IMcms_Expecter) Signers(ctx interface{}, opts interface{}, state interface{}, role interface{}) *IMcms_Signers_Call {
	return &IMcms_Signers_Call{Call: _e.mock.On("Signers", ctx, opts, state, role)}
}

func (_c *IMcms_Signers_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte)) *IMcms_Signers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(byte))
	})
	return _c
}

func (_c *IMcms_Signers_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_Signers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_Signers_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_Signers_Call {
	_c.Call.Return(run)
	return _c
}

// Target provides a mock function with given fields: ctx, opts, function
func (_m *IMcms) Target(ctx context.Context, opts *bind.CallOpts, function module_mcms.Function) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, function)

	if len(ret) == 0 {
		panic("no return value specified for Target")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Function) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, function)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Function) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, function)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Function) error); ok {
		r1 = rf(ctx, opts, function)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_Target_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Target'
type IMcms_Target_Call struct {
	*mock.Call
}

// Target is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - function module_mcms.Function
func (_e *IMcms_Expecter) Target(ctx interface{}, opts interface{}, function interface{}) *IMcms_Target_Call {
	return &IMcms_Target_Call{Call: _e.mock.On("Target", ctx, opts, function)}
}

func (_c *IMcms_Target_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, function module_mcms.Function)) *IMcms_Target_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Function))
	})
	return _c
}

func (_c *IMcms_Target_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_Target_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_Target_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Function) (*models.SuiTransactionBlockResponse, error)) *IMcms_Target_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockExecuteBatch provides a mock function with given fields: ctx, opts, timelock, clock, registry, targets, moduleNames, functionNames, datas, predecessor, salt
func (_m *IMcms) TimelockExecuteBatch(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, registry bind.Object, targets []string, moduleNames []string, functionNames []string, datas [][]byte, predecessor []byte, salt []byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, clock, registry, targets, moduleNames, functionNames, datas, predecessor, salt)

	if len(ret) == 0 {
		panic("no return value specified for TimelockExecuteBatch")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, []string, []string, []string, [][]byte, []byte, []byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, clock, registry, targets, moduleNames, functionNames, datas, predecessor, salt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, []string, []string, []string, [][]byte, []byte, []byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, clock, registry, targets, moduleNames, functionNames, datas, predecessor, salt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, []string, []string, []string, [][]byte, []byte, []byte) error); ok {
		r1 = rf(ctx, opts, timelock, clock, registry, targets, moduleNames, functionNames, datas, predecessor, salt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_TimelockExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockExecuteBatch'
type IMcms_TimelockExecuteBatch_Call struct {
	*mock.Call
}

// TimelockExecuteBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - clock bind.Object
//   - registry bind.Object
//   - targets []string
//   - moduleNames []string
//   - functionNames []string
//   - datas [][]byte
//   - predecessor []byte
//   - salt []byte
func (_e *IMcms_Expecter) TimelockExecuteBatch(ctx interface{}, opts interface{}, timelock interface{}, clock interface{}, registry interface{}, targets interface{}, moduleNames interface{}, functionNames interface{}, datas interface{}, predecessor interface{}, salt interface{}) *IMcms_TimelockExecuteBatch_Call {
	return &IMcms_TimelockExecuteBatch_Call{Call: _e.mock.On("TimelockExecuteBatch", ctx, opts, timelock, clock, registry, targets, moduleNames, functionNames, datas, predecessor, salt)}
}

func (_c *IMcms_TimelockExecuteBatch_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, registry bind.Object, targets []string, moduleNames []string, functionNames []string, datas [][]byte, predecessor []byte, salt []byte)) *IMcms_TimelockExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(bind.Object), args[5].([]string), args[6].([]string), args[7].([]string), args[8].([][]byte), args[9].([]byte), args[10].([]byte))
	})
	return _c
}

func (_c *IMcms_TimelockExecuteBatch_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_TimelockExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_TimelockExecuteBatch_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object, []string, []string, []string, [][]byte, []byte, []byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_TimelockExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunction provides a mock function with given fields: ctx, opts, timelock, index
func (_m *IMcms) TimelockGetBlockedFunction(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, index uint64) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, index)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunction")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, uint64) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, index)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, uint64) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, uint64) error); ok {
		r1 = rf(ctx, opts, timelock, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_TimelockGetBlockedFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunction'
type IMcms_TimelockGetBlockedFunction_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunction is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - index uint64
func (_e *IMcms_Expecter) TimelockGetBlockedFunction(ctx interface{}, opts interface{}, timelock interface{}, index interface{}) *IMcms_TimelockGetBlockedFunction_Call {
	return &IMcms_TimelockGetBlockedFunction_Call{Call: _e.mock.On("TimelockGetBlockedFunction", ctx, opts, timelock, index)}
}

func (_c *IMcms_TimelockGetBlockedFunction_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, index uint64)) *IMcms_TimelockGetBlockedFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(uint64))
	})
	return _c
}

func (_c *IMcms_TimelockGetBlockedFunction_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_TimelockGetBlockedFunction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_TimelockGetBlockedFunction_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, uint64) (*models.SuiTransactionBlockResponse, error)) *IMcms_TimelockGetBlockedFunction_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunctions provides a mock function with given fields: ctx, opts, timelock
func (_m *IMcms) TimelockGetBlockedFunctions(ctx context.Context, opts *bind.CallOpts, timelock bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunctions")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object) error); ok {
		r1 = rf(ctx, opts, timelock)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_TimelockGetBlockedFunctions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunctions'
type IMcms_TimelockGetBlockedFunctions_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunctions is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
func (_e *IMcms_Expecter) TimelockGetBlockedFunctions(ctx interface{}, opts interface{}, timelock interface{}) *IMcms_TimelockGetBlockedFunctions_Call {
	return &IMcms_TimelockGetBlockedFunctions_Call{Call: _e.mock.On("TimelockGetBlockedFunctions", ctx, opts, timelock)}
}

func (_c *IMcms_TimelockGetBlockedFunctions_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object)) *IMcms_TimelockGetBlockedFunctions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object))
	})
	return _c
}

func (_c *IMcms_TimelockGetBlockedFunctions_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_TimelockGetBlockedFunctions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_TimelockGetBlockedFunctions_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcms_TimelockGetBlockedFunctions_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunctionsCount provides a mock function with given fields: ctx, opts, timelock
func (_m *IMcms) TimelockGetBlockedFunctionsCount(ctx context.Context, opts *bind.CallOpts, timelock bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunctionsCount")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object) error); ok {
		r1 = rf(ctx, opts, timelock)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_TimelockGetBlockedFunctionsCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunctionsCount'
type IMcms_TimelockGetBlockedFunctionsCount_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunctionsCount is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
func (_e *IMcms_Expecter) TimelockGetBlockedFunctionsCount(ctx interface{}, opts interface{}, timelock interface{}) *IMcms_TimelockGetBlockedFunctionsCount_Call {
	return &IMcms_TimelockGetBlockedFunctionsCount_Call{Call: _e.mock.On("TimelockGetBlockedFunctionsCount", ctx, opts, timelock)}
}

func (_c *IMcms_TimelockGetBlockedFunctionsCount_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object)) *IMcms_TimelockGetBlockedFunctionsCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object))
	})
	return _c
}

func (_c *IMcms_TimelockGetBlockedFunctionsCount_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_TimelockGetBlockedFunctionsCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_TimelockGetBlockedFunctionsCount_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcms_TimelockGetBlockedFunctionsCount_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetTimestamp provides a mock function with given fields: ctx, opts, timelock, id
func (_m *IMcms) TimelockGetTimestamp(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetTimestamp")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, []byte) error); ok {
		r1 = rf(ctx, opts, timelock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_TimelockGetTimestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetTimestamp'
type IMcms_TimelockGetTimestamp_Call struct {
	*mock.Call
}

// TimelockGetTimestamp is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - id []byte
func (_e *IMcms_Expecter) TimelockGetTimestamp(ctx interface{}, opts interface{}, timelock interface{}, id interface{}) *IMcms_TimelockGetTimestamp_Call {
	return &IMcms_TimelockGetTimestamp_Call{Call: _e.mock.On("TimelockGetTimestamp", ctx, opts, timelock, id)}
}

func (_c *IMcms_TimelockGetTimestamp_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte)) *IMcms_TimelockGetTimestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].([]byte))
	})
	return _c
}

func (_c *IMcms_TimelockGetTimestamp_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_TimelockGetTimestamp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_TimelockGetTimestamp_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, []byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_TimelockGetTimestamp_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperation provides a mock function with given fields: ctx, opts, timelock, id
func (_m *IMcms) TimelockIsOperation(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperation")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, []byte) error); ok {
		r1 = rf(ctx, opts, timelock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_TimelockIsOperation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperation'
type IMcms_TimelockIsOperation_Call struct {
	*mock.Call
}

// TimelockIsOperation is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - id []byte
func (_e *IMcms_Expecter) TimelockIsOperation(ctx interface{}, opts interface{}, timelock interface{}, id interface{}) *IMcms_TimelockIsOperation_Call {
	return &IMcms_TimelockIsOperation_Call{Call: _e.mock.On("TimelockIsOperation", ctx, opts, timelock, id)}
}

func (_c *IMcms_TimelockIsOperation_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte)) *IMcms_TimelockIsOperation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].([]byte))
	})
	return _c
}

func (_c *IMcms_TimelockIsOperation_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_TimelockIsOperation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_TimelockIsOperation_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, []byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_TimelockIsOperation_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationDone provides a mock function with given fields: ctx, opts, timelock, id
func (_m *IMcms) TimelockIsOperationDone(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationDone")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, []byte) error); ok {
		r1 = rf(ctx, opts, timelock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_TimelockIsOperationDone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationDone'
type IMcms_TimelockIsOperationDone_Call struct {
	*mock.Call
}

// TimelockIsOperationDone is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - id []byte
func (_e *IMcms_Expecter) TimelockIsOperationDone(ctx interface{}, opts interface{}, timelock interface{}, id interface{}) *IMcms_TimelockIsOperationDone_Call {
	return &IMcms_TimelockIsOperationDone_Call{Call: _e.mock.On("TimelockIsOperationDone", ctx, opts, timelock, id)}
}

func (_c *IMcms_TimelockIsOperationDone_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte)) *IMcms_TimelockIsOperationDone_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].([]byte))
	})
	return _c
}

func (_c *IMcms_TimelockIsOperationDone_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_TimelockIsOperationDone_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_TimelockIsOperationDone_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, []byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_TimelockIsOperationDone_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationPending provides a mock function with given fields: ctx, opts, timelock, id
func (_m *IMcms) TimelockIsOperationPending(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationPending")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, []byte) error); ok {
		r1 = rf(ctx, opts, timelock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_TimelockIsOperationPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationPending'
type IMcms_TimelockIsOperationPending_Call struct {
	*mock.Call
}

// TimelockIsOperationPending is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - id []byte
func (_e *IMcms_Expecter) TimelockIsOperationPending(ctx interface{}, opts interface{}, timelock interface{}, id interface{}) *IMcms_TimelockIsOperationPending_Call {
	return &IMcms_TimelockIsOperationPending_Call{Call: _e.mock.On("TimelockIsOperationPending", ctx, opts, timelock, id)}
}

func (_c *IMcms_TimelockIsOperationPending_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte)) *IMcms_TimelockIsOperationPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].([]byte))
	})
	return _c
}

func (_c *IMcms_TimelockIsOperationPending_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_TimelockIsOperationPending_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_TimelockIsOperationPending_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, []byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_TimelockIsOperationPending_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationReady provides a mock function with given fields: ctx, opts, timelock, clock, id
func (_m *IMcms) TimelockIsOperationReady(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, id []byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock, clock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationReady")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, []byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock, clock, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, []byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock, clock, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, []byte) error); ok {
		r1 = rf(ctx, opts, timelock, clock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_TimelockIsOperationReady_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationReady'
type IMcms_TimelockIsOperationReady_Call struct {
	*mock.Call
}

// TimelockIsOperationReady is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - clock bind.Object
//   - id []byte
func (_e *IMcms_Expecter) TimelockIsOperationReady(ctx interface{}, opts interface{}, timelock interface{}, clock interface{}, id interface{}) *IMcms_TimelockIsOperationReady_Call {
	return &IMcms_TimelockIsOperationReady_Call{Call: _e.mock.On("TimelockIsOperationReady", ctx, opts, timelock, clock, id)}
}

func (_c *IMcms_TimelockIsOperationReady_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, id []byte)) *IMcms_TimelockIsOperationReady_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].([]byte))
	})
	return _c
}

func (_c *IMcms_TimelockIsOperationReady_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_TimelockIsOperationReady_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_TimelockIsOperationReady_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, []byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_TimelockIsOperationReady_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockMinDelay provides a mock function with given fields: ctx, opts, timelock
func (_m *IMcms) TimelockMinDelay(ctx context.Context, opts *bind.CallOpts, timelock bind.Object) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, timelock)

	if len(ret) == 0 {
		panic("no return value specified for TimelockMinDelay")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, timelock)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, timelock)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object) error); ok {
		r1 = rf(ctx, opts, timelock)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_TimelockMinDelay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockMinDelay'
type IMcms_TimelockMinDelay_Call struct {
	*mock.Call
}

// TimelockMinDelay is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
func (_e *IMcms_Expecter) TimelockMinDelay(ctx interface{}, opts interface{}, timelock interface{}) *IMcms_TimelockMinDelay_Call {
	return &IMcms_TimelockMinDelay_Call{Call: _e.mock.On("TimelockMinDelay", ctx, opts, timelock)}
}

func (_c *IMcms_TimelockMinDelay_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object)) *IMcms_TimelockMinDelay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object))
	})
	return _c
}

func (_c *IMcms_TimelockMinDelay_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_TimelockMinDelay_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_TimelockMinDelay_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object) (*models.SuiTransactionBlockResponse, error)) *IMcms_TimelockMinDelay_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockRole provides a mock function with given fields: ctx, opts
func (_m *IMcms) TimelockRole(ctx context.Context, opts *bind.CallOpts) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for TimelockRole")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_TimelockRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockRole'
type IMcms_TimelockRole_Call struct {
	*mock.Call
}

// TimelockRole is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
func (_e *IMcms_Expecter) TimelockRole(ctx interface{}, opts interface{}) *IMcms_TimelockRole_Call {
	return &IMcms_TimelockRole_Call{Call: _e.mock.On("TimelockRole", ctx, opts)}
}

func (_c *IMcms_TimelockRole_Call) Run(run func(ctx context.Context, opts *bind.CallOpts)) *IMcms_TimelockRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts))
	})
	return _c
}

func (_c *IMcms_TimelockRole_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_TimelockRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_TimelockRole_Call) RunAndReturn(run func(context.Context, *bind.CallOpts) (*models.SuiTransactionBlockResponse, error)) *IMcms_TimelockRole_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyMerkleProof provides a mock function with given fields: ctx, opts, proof, root, leaf
func (_m *IMcms) VerifyMerkleProof(ctx context.Context, opts *bind.CallOpts, proof [][]byte, root []byte, leaf []byte) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts, proof, root, leaf)

	if len(ret) == 0 {
		panic("no return value specified for VerifyMerkleProof")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, [][]byte, []byte, []byte) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts, proof, root, leaf)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, [][]byte, []byte, []byte) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts, proof, root, leaf)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, [][]byte, []byte, []byte) error); ok {
		r1 = rf(ctx, opts, proof, root, leaf)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_VerifyMerkleProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyMerkleProof'
type IMcms_VerifyMerkleProof_Call struct {
	*mock.Call
}

// VerifyMerkleProof is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - proof [][]byte
//   - root []byte
//   - leaf []byte
func (_e *IMcms_Expecter) VerifyMerkleProof(ctx interface{}, opts interface{}, proof interface{}, root interface{}, leaf interface{}) *IMcms_VerifyMerkleProof_Call {
	return &IMcms_VerifyMerkleProof_Call{Call: _e.mock.On("VerifyMerkleProof", ctx, opts, proof, root, leaf)}
}

func (_c *IMcms_VerifyMerkleProof_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, proof [][]byte, root []byte, leaf []byte)) *IMcms_VerifyMerkleProof_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].([][]byte), args[3].([]byte), args[4].([]byte))
	})
	return _c
}

func (_c *IMcms_VerifyMerkleProof_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_VerifyMerkleProof_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_VerifyMerkleProof_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, [][]byte, []byte, []byte) (*models.SuiTransactionBlockResponse, error)) *IMcms_VerifyMerkleProof_Call {
	_c.Call.Return(run)
	return _c
}

// ZeroHash provides a mock function with given fields: ctx, opts
func (_m *IMcms) ZeroHash(ctx context.Context, opts *bind.CallOpts) (*models.SuiTransactionBlockResponse, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ZeroHash")
	}

	var r0 *models.SuiTransactionBlockResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) (*models.SuiTransactionBlockResponse, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) *models.SuiTransactionBlockResponse); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.SuiTransactionBlockResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcms_ZeroHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZeroHash'
type IMcms_ZeroHash_Call struct {
	*mock.Call
}

// ZeroHash is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
func (_e *IMcms_Expecter) ZeroHash(ctx interface{}, opts interface{}) *IMcms_ZeroHash_Call {
	return &IMcms_ZeroHash_Call{Call: _e.mock.On("ZeroHash", ctx, opts)}
}

func (_c *IMcms_ZeroHash_Call) Run(run func(ctx context.Context, opts *bind.CallOpts)) *IMcms_ZeroHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts))
	})
	return _c
}

func (_c *IMcms_ZeroHash_Call) Return(_a0 *models.SuiTransactionBlockResponse, _a1 error) *IMcms_ZeroHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcms_ZeroHash_Call) RunAndReturn(run func(context.Context, *bind.CallOpts) (*models.SuiTransactionBlockResponse, error)) *IMcms_ZeroHash_Call {
	_c.Call.Return(run)
	return _c
}

// NewIMcms creates a new instance of IMcms. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIMcms(t interface {
	mock.TestingT
	Cleanup(func())
}) *IMcms {
	mock := &IMcms{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

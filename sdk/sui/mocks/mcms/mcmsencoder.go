// Code generated by mockery v2.53.5. DO NOT EDIT.

package mock_module_mcms

import (
	big "math/big"

	bind "github.com/smartcontractkit/chainlink-sui/bindings/bind"
	mock "github.com/stretchr/testify/mock"

	module_mcms "github.com/smartcontractkit/chainlink-sui/bindings/generated/mcms/mcms"
)

// McmsEncoder is an autogenerated mock type for the McmsEncoder type
type McmsEncoder struct {
	mock.Mock
}

type McmsEncoder_Expecter struct {
	mock *mock.Mock
}

func (_m *McmsEncoder) EXPECT() *McmsEncoder_Expecter {
	return &McmsEncoder_Expecter{mock: &_m.Mock}
}

// BypasserRole provides a mock function with no fields
func (_m *McmsEncoder) BypasserRole() (*bind.EncodedCall, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for BypasserRole")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func() (*bind.EncodedCall, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *bind.EncodedCall); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_BypasserRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BypasserRole'
type McmsEncoder_BypasserRole_Call struct {
	*mock.Call
}

// BypasserRole is a helper method to define mock.On call
func (_e *McmsEncoder_Expecter) BypasserRole() *McmsEncoder_BypasserRole_Call {
	return &McmsEncoder_BypasserRole_Call{Call: _e.mock.On("BypasserRole")}
}

func (_c *McmsEncoder_BypasserRole_Call) Run(run func()) *McmsEncoder_BypasserRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *McmsEncoder_BypasserRole_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_BypasserRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_BypasserRole_Call) RunAndReturn(run func() (*bind.EncodedCall, error)) *McmsEncoder_BypasserRole_Call {
	_c.Call.Return(run)
	return _c
}

// BypasserRoleWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) BypasserRoleWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BypasserRoleWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_BypasserRoleWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BypasserRoleWithArgs'
type McmsEncoder_BypasserRoleWithArgs_Call struct {
	*mock.Call
}

// BypasserRoleWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) BypasserRoleWithArgs(args ...interface{}) *McmsEncoder_BypasserRoleWithArgs_Call {
	return &McmsEncoder_BypasserRoleWithArgs_Call{Call: _e.mock.On("BypasserRoleWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_BypasserRoleWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_BypasserRoleWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_BypasserRoleWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_BypasserRoleWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_BypasserRoleWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_BypasserRoleWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// CancellerRole provides a mock function with no fields
func (_m *McmsEncoder) CancellerRole() (*bind.EncodedCall, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CancellerRole")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func() (*bind.EncodedCall, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *bind.EncodedCall); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_CancellerRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancellerRole'
type McmsEncoder_CancellerRole_Call struct {
	*mock.Call
}

// CancellerRole is a helper method to define mock.On call
func (_e *McmsEncoder_Expecter) CancellerRole() *McmsEncoder_CancellerRole_Call {
	return &McmsEncoder_CancellerRole_Call{Call: _e.mock.On("CancellerRole")}
}

func (_c *McmsEncoder_CancellerRole_Call) Run(run func()) *McmsEncoder_CancellerRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *McmsEncoder_CancellerRole_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_CancellerRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_CancellerRole_Call) RunAndReturn(run func() (*bind.EncodedCall, error)) *McmsEncoder_CancellerRole_Call {
	_c.Call.Return(run)
	return _c
}

// CancellerRoleWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) CancellerRoleWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancellerRoleWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_CancellerRoleWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancellerRoleWithArgs'
type McmsEncoder_CancellerRoleWithArgs_Call struct {
	*mock.Call
}

// CancellerRoleWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) CancellerRoleWithArgs(args ...interface{}) *McmsEncoder_CancellerRoleWithArgs_Call {
	return &McmsEncoder_CancellerRoleWithArgs_Call{Call: _e.mock.On("CancellerRoleWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_CancellerRoleWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_CancellerRoleWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_CancellerRoleWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_CancellerRoleWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_CancellerRoleWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_CancellerRoleWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ChainId provides a mock function with given fields: rootMetadata
func (_m *McmsEncoder) ChainId(rootMetadata module_mcms.RootMetadata) (*bind.EncodedCall, error) {
	ret := _m.Called(rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for ChainId")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) (*bind.EncodedCall, error)); ok {
		return rf(rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) *bind.EncodedCall); ok {
		r0 = rf(rootMetadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.RootMetadata) error); ok {
		r1 = rf(rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ChainId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainId'
type McmsEncoder_ChainId_Call struct {
	*mock.Call
}

// ChainId is a helper method to define mock.On call
//   - rootMetadata module_mcms.RootMetadata
func (_e *McmsEncoder_Expecter) ChainId(rootMetadata interface{}) *McmsEncoder_ChainId_Call {
	return &McmsEncoder_ChainId_Call{Call: _e.mock.On("ChainId", rootMetadata)}
}

func (_c *McmsEncoder_ChainId_Call) Run(run func(rootMetadata module_mcms.RootMetadata)) *McmsEncoder_ChainId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *McmsEncoder_ChainId_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ChainId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ChainId_Call) RunAndReturn(run func(module_mcms.RootMetadata) (*bind.EncodedCall, error)) *McmsEncoder_ChainId_Call {
	_c.Call.Return(run)
	return _c
}

// ChainIdWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) ChainIdWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChainIdWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ChainIdWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainIdWithArgs'
type McmsEncoder_ChainIdWithArgs_Call struct {
	*mock.Call
}

// ChainIdWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) ChainIdWithArgs(args ...interface{}) *McmsEncoder_ChainIdWithArgs_Call {
	return &McmsEncoder_ChainIdWithArgs_Call{Call: _e.mock.On("ChainIdWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_ChainIdWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_ChainIdWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_ChainIdWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ChainIdWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ChainIdWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_ChainIdWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ComputeEthMessageHash provides a mock function with given fields: root, validUntil
func (_m *McmsEncoder) ComputeEthMessageHash(root []byte, validUntil uint64) (*bind.EncodedCall, error) {
	ret := _m.Called(root, validUntil)

	if len(ret) == 0 {
		panic("no return value specified for ComputeEthMessageHash")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, uint64) (*bind.EncodedCall, error)); ok {
		return rf(root, validUntil)
	}
	if rf, ok := ret.Get(0).(func([]byte, uint64) *bind.EncodedCall); ok {
		r0 = rf(root, validUntil)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte, uint64) error); ok {
		r1 = rf(root, validUntil)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ComputeEthMessageHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputeEthMessageHash'
type McmsEncoder_ComputeEthMessageHash_Call struct {
	*mock.Call
}

// ComputeEthMessageHash is a helper method to define mock.On call
//   - root []byte
//   - validUntil uint64
func (_e *McmsEncoder_Expecter) ComputeEthMessageHash(root interface{}, validUntil interface{}) *McmsEncoder_ComputeEthMessageHash_Call {
	return &McmsEncoder_ComputeEthMessageHash_Call{Call: _e.mock.On("ComputeEthMessageHash", root, validUntil)}
}

func (_c *McmsEncoder_ComputeEthMessageHash_Call) Run(run func(root []byte, validUntil uint64)) *McmsEncoder_ComputeEthMessageHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].(uint64))
	})
	return _c
}

func (_c *McmsEncoder_ComputeEthMessageHash_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ComputeEthMessageHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ComputeEthMessageHash_Call) RunAndReturn(run func([]byte, uint64) (*bind.EncodedCall, error)) *McmsEncoder_ComputeEthMessageHash_Call {
	_c.Call.Return(run)
	return _c
}

// ComputeEthMessageHashWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) ComputeEthMessageHashWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ComputeEthMessageHashWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ComputeEthMessageHashWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputeEthMessageHashWithArgs'
type McmsEncoder_ComputeEthMessageHashWithArgs_Call struct {
	*mock.Call
}

// ComputeEthMessageHashWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) ComputeEthMessageHashWithArgs(args ...interface{}) *McmsEncoder_ComputeEthMessageHashWithArgs_Call {
	return &McmsEncoder_ComputeEthMessageHashWithArgs_Call{Call: _e.mock.On("ComputeEthMessageHashWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_ComputeEthMessageHashWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_ComputeEthMessageHashWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_ComputeEthMessageHashWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ComputeEthMessageHashWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ComputeEthMessageHashWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_ComputeEthMessageHashWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigGroupParents provides a mock function with given fields: config
func (_m *McmsEncoder) ConfigGroupParents(config module_mcms.Config) (*bind.EncodedCall, error) {
	ret := _m.Called(config)

	if len(ret) == 0 {
		panic("no return value specified for ConfigGroupParents")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.Config) (*bind.EncodedCall, error)); ok {
		return rf(config)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.Config) *bind.EncodedCall); ok {
		r0 = rf(config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.Config) error); ok {
		r1 = rf(config)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ConfigGroupParents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigGroupParents'
type McmsEncoder_ConfigGroupParents_Call struct {
	*mock.Call
}

// ConfigGroupParents is a helper method to define mock.On call
//   - config module_mcms.Config
func (_e *McmsEncoder_Expecter) ConfigGroupParents(config interface{}) *McmsEncoder_ConfigGroupParents_Call {
	return &McmsEncoder_ConfigGroupParents_Call{Call: _e.mock.On("ConfigGroupParents", config)}
}

func (_c *McmsEncoder_ConfigGroupParents_Call) Run(run func(config module_mcms.Config)) *McmsEncoder_ConfigGroupParents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.Config))
	})
	return _c
}

func (_c *McmsEncoder_ConfigGroupParents_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ConfigGroupParents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ConfigGroupParents_Call) RunAndReturn(run func(module_mcms.Config) (*bind.EncodedCall, error)) *McmsEncoder_ConfigGroupParents_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigGroupParentsWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) ConfigGroupParentsWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ConfigGroupParentsWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ConfigGroupParentsWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigGroupParentsWithArgs'
type McmsEncoder_ConfigGroupParentsWithArgs_Call struct {
	*mock.Call
}

// ConfigGroupParentsWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) ConfigGroupParentsWithArgs(args ...interface{}) *McmsEncoder_ConfigGroupParentsWithArgs_Call {
	return &McmsEncoder_ConfigGroupParentsWithArgs_Call{Call: _e.mock.On("ConfigGroupParentsWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_ConfigGroupParentsWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_ConfigGroupParentsWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_ConfigGroupParentsWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ConfigGroupParentsWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ConfigGroupParentsWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_ConfigGroupParentsWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigGroupQuorums provides a mock function with given fields: config
func (_m *McmsEncoder) ConfigGroupQuorums(config module_mcms.Config) (*bind.EncodedCall, error) {
	ret := _m.Called(config)

	if len(ret) == 0 {
		panic("no return value specified for ConfigGroupQuorums")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.Config) (*bind.EncodedCall, error)); ok {
		return rf(config)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.Config) *bind.EncodedCall); ok {
		r0 = rf(config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.Config) error); ok {
		r1 = rf(config)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ConfigGroupQuorums_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigGroupQuorums'
type McmsEncoder_ConfigGroupQuorums_Call struct {
	*mock.Call
}

// ConfigGroupQuorums is a helper method to define mock.On call
//   - config module_mcms.Config
func (_e *McmsEncoder_Expecter) ConfigGroupQuorums(config interface{}) *McmsEncoder_ConfigGroupQuorums_Call {
	return &McmsEncoder_ConfigGroupQuorums_Call{Call: _e.mock.On("ConfigGroupQuorums", config)}
}

func (_c *McmsEncoder_ConfigGroupQuorums_Call) Run(run func(config module_mcms.Config)) *McmsEncoder_ConfigGroupQuorums_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.Config))
	})
	return _c
}

func (_c *McmsEncoder_ConfigGroupQuorums_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ConfigGroupQuorums_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ConfigGroupQuorums_Call) RunAndReturn(run func(module_mcms.Config) (*bind.EncodedCall, error)) *McmsEncoder_ConfigGroupQuorums_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigGroupQuorumsWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) ConfigGroupQuorumsWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ConfigGroupQuorumsWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ConfigGroupQuorumsWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigGroupQuorumsWithArgs'
type McmsEncoder_ConfigGroupQuorumsWithArgs_Call struct {
	*mock.Call
}

// ConfigGroupQuorumsWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) ConfigGroupQuorumsWithArgs(args ...interface{}) *McmsEncoder_ConfigGroupQuorumsWithArgs_Call {
	return &McmsEncoder_ConfigGroupQuorumsWithArgs_Call{Call: _e.mock.On("ConfigGroupQuorumsWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_ConfigGroupQuorumsWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_ConfigGroupQuorumsWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_ConfigGroupQuorumsWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ConfigGroupQuorumsWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ConfigGroupQuorumsWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_ConfigGroupQuorumsWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigSigners provides a mock function with given fields: config
func (_m *McmsEncoder) ConfigSigners(config module_mcms.Config) (*bind.EncodedCall, error) {
	ret := _m.Called(config)

	if len(ret) == 0 {
		panic("no return value specified for ConfigSigners")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.Config) (*bind.EncodedCall, error)); ok {
		return rf(config)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.Config) *bind.EncodedCall); ok {
		r0 = rf(config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.Config) error); ok {
		r1 = rf(config)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ConfigSigners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigSigners'
type McmsEncoder_ConfigSigners_Call struct {
	*mock.Call
}

// ConfigSigners is a helper method to define mock.On call
//   - config module_mcms.Config
func (_e *McmsEncoder_Expecter) ConfigSigners(config interface{}) *McmsEncoder_ConfigSigners_Call {
	return &McmsEncoder_ConfigSigners_Call{Call: _e.mock.On("ConfigSigners", config)}
}

func (_c *McmsEncoder_ConfigSigners_Call) Run(run func(config module_mcms.Config)) *McmsEncoder_ConfigSigners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.Config))
	})
	return _c
}

func (_c *McmsEncoder_ConfigSigners_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ConfigSigners_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ConfigSigners_Call) RunAndReturn(run func(module_mcms.Config) (*bind.EncodedCall, error)) *McmsEncoder_ConfigSigners_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigSignersWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) ConfigSignersWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ConfigSignersWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ConfigSignersWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigSignersWithArgs'
type McmsEncoder_ConfigSignersWithArgs_Call struct {
	*mock.Call
}

// ConfigSignersWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) ConfigSignersWithArgs(args ...interface{}) *McmsEncoder_ConfigSignersWithArgs_Call {
	return &McmsEncoder_ConfigSignersWithArgs_Call{Call: _e.mock.On("ConfigSignersWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_ConfigSignersWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_ConfigSignersWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_ConfigSignersWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ConfigSignersWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ConfigSignersWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_ConfigSignersWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCalls provides a mock function with given fields: targets, moduleNames, functionNames, datas
func (_m *McmsEncoder) CreateCalls(targets []string, moduleNames []string, functionNames []string, datas [][]byte) (*bind.EncodedCall, error) {
	ret := _m.Called(targets, moduleNames, functionNames, datas)

	if len(ret) == 0 {
		panic("no return value specified for CreateCalls")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func([]string, []string, []string, [][]byte) (*bind.EncodedCall, error)); ok {
		return rf(targets, moduleNames, functionNames, datas)
	}
	if rf, ok := ret.Get(0).(func([]string, []string, []string, [][]byte) *bind.EncodedCall); ok {
		r0 = rf(targets, moduleNames, functionNames, datas)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func([]string, []string, []string, [][]byte) error); ok {
		r1 = rf(targets, moduleNames, functionNames, datas)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_CreateCalls_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCalls'
type McmsEncoder_CreateCalls_Call struct {
	*mock.Call
}

// CreateCalls is a helper method to define mock.On call
//   - targets []string
//   - moduleNames []string
//   - functionNames []string
//   - datas [][]byte
func (_e *McmsEncoder_Expecter) CreateCalls(targets interface{}, moduleNames interface{}, functionNames interface{}, datas interface{}) *McmsEncoder_CreateCalls_Call {
	return &McmsEncoder_CreateCalls_Call{Call: _e.mock.On("CreateCalls", targets, moduleNames, functionNames, datas)}
}

func (_c *McmsEncoder_CreateCalls_Call) Run(run func(targets []string, moduleNames []string, functionNames []string, datas [][]byte)) *McmsEncoder_CreateCalls_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]string), args[1].([]string), args[2].([]string), args[3].([][]byte))
	})
	return _c
}

func (_c *McmsEncoder_CreateCalls_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_CreateCalls_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_CreateCalls_Call) RunAndReturn(run func([]string, []string, []string, [][]byte) (*bind.EncodedCall, error)) *McmsEncoder_CreateCalls_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCallsWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) CreateCallsWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCallsWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_CreateCallsWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCallsWithArgs'
type McmsEncoder_CreateCallsWithArgs_Call struct {
	*mock.Call
}

// CreateCallsWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) CreateCallsWithArgs(args ...interface{}) *McmsEncoder_CreateCallsWithArgs_Call {
	return &McmsEncoder_CreateCallsWithArgs_Call{Call: _e.mock.On("CreateCallsWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_CreateCallsWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_CreateCallsWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_CreateCallsWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_CreateCallsWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_CreateCallsWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_CreateCallsWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// Data provides a mock function with given fields: call
func (_m *McmsEncoder) Data(call module_mcms.Call) (*bind.EncodedCall, error) {
	ret := _m.Called(call)

	if len(ret) == 0 {
		panic("no return value specified for Data")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.Call) (*bind.EncodedCall, error)); ok {
		return rf(call)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.Call) *bind.EncodedCall); ok {
		r0 = rf(call)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.Call) error); ok {
		r1 = rf(call)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_Data_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Data'
type McmsEncoder_Data_Call struct {
	*mock.Call
}

// Data is a helper method to define mock.On call
//   - call module_mcms.Call
func (_e *McmsEncoder_Expecter) Data(call interface{}) *McmsEncoder_Data_Call {
	return &McmsEncoder_Data_Call{Call: _e.mock.On("Data", call)}
}

func (_c *McmsEncoder_Data_Call) Run(run func(call module_mcms.Call)) *McmsEncoder_Data_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.Call))
	})
	return _c
}

func (_c *McmsEncoder_Data_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_Data_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_Data_Call) RunAndReturn(run func(module_mcms.Call) (*bind.EncodedCall, error)) *McmsEncoder_Data_Call {
	_c.Call.Return(run)
	return _c
}

// DataWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) DataWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DataWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DataWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DataWithArgs'
type McmsEncoder_DataWithArgs_Call struct {
	*mock.Call
}

// DataWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) DataWithArgs(args ...interface{}) *McmsEncoder_DataWithArgs_Call {
	return &McmsEncoder_DataWithArgs_Call{Call: _e.mock.On("DataWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_DataWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_DataWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_DataWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DataWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DataWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_DataWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockBlockFunction provides a mock function with given fields: timelock, timelockCallbackParams
func (_m *McmsEncoder) DispatchTimelockBlockFunction(timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockBlockFunction")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error)); ok {
		return rf(timelock, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, module_mcms.TimelockCallbackParams) *bind.EncodedCall); ok {
		r0 = rf(timelock, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(timelock, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DispatchTimelockBlockFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockBlockFunction'
type McmsEncoder_DispatchTimelockBlockFunction_Call struct {
	*mock.Call
}

// DispatchTimelockBlockFunction is a helper method to define mock.On call
//   - timelock bind.Object
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *McmsEncoder_Expecter) DispatchTimelockBlockFunction(timelock interface{}, timelockCallbackParams interface{}) *McmsEncoder_DispatchTimelockBlockFunction_Call {
	return &McmsEncoder_DispatchTimelockBlockFunction_Call{Call: _e.mock.On("DispatchTimelockBlockFunction", timelock, timelockCallbackParams)}
}

func (_c *McmsEncoder_DispatchTimelockBlockFunction_Call) Run(run func(timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams)) *McmsEncoder_DispatchTimelockBlockFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *McmsEncoder_DispatchTimelockBlockFunction_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DispatchTimelockBlockFunction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DispatchTimelockBlockFunction_Call) RunAndReturn(run func(bind.Object, module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error)) *McmsEncoder_DispatchTimelockBlockFunction_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockBlockFunctionWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) DispatchTimelockBlockFunctionWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockBlockFunctionWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DispatchTimelockBlockFunctionWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockBlockFunctionWithArgs'
type McmsEncoder_DispatchTimelockBlockFunctionWithArgs_Call struct {
	*mock.Call
}

// DispatchTimelockBlockFunctionWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) DispatchTimelockBlockFunctionWithArgs(args ...interface{}) *McmsEncoder_DispatchTimelockBlockFunctionWithArgs_Call {
	return &McmsEncoder_DispatchTimelockBlockFunctionWithArgs_Call{Call: _e.mock.On("DispatchTimelockBlockFunctionWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_DispatchTimelockBlockFunctionWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_DispatchTimelockBlockFunctionWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_DispatchTimelockBlockFunctionWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DispatchTimelockBlockFunctionWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DispatchTimelockBlockFunctionWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_DispatchTimelockBlockFunctionWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockBypasserExecuteBatch provides a mock function with given fields: timelockCallbackParams
func (_m *McmsEncoder) DispatchTimelockBypasserExecuteBatch(timelockCallbackParams module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error) {
	ret := _m.Called(timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockBypasserExecuteBatch")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error)); ok {
		return rf(timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.TimelockCallbackParams) *bind.EncodedCall); ok {
		r0 = rf(timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DispatchTimelockBypasserExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockBypasserExecuteBatch'
type McmsEncoder_DispatchTimelockBypasserExecuteBatch_Call struct {
	*mock.Call
}

// DispatchTimelockBypasserExecuteBatch is a helper method to define mock.On call
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *McmsEncoder_Expecter) DispatchTimelockBypasserExecuteBatch(timelockCallbackParams interface{}) *McmsEncoder_DispatchTimelockBypasserExecuteBatch_Call {
	return &McmsEncoder_DispatchTimelockBypasserExecuteBatch_Call{Call: _e.mock.On("DispatchTimelockBypasserExecuteBatch", timelockCallbackParams)}
}

func (_c *McmsEncoder_DispatchTimelockBypasserExecuteBatch_Call) Run(run func(timelockCallbackParams module_mcms.TimelockCallbackParams)) *McmsEncoder_DispatchTimelockBypasserExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *McmsEncoder_DispatchTimelockBypasserExecuteBatch_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DispatchTimelockBypasserExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DispatchTimelockBypasserExecuteBatch_Call) RunAndReturn(run func(module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error)) *McmsEncoder_DispatchTimelockBypasserExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockBypasserExecuteBatchWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) DispatchTimelockBypasserExecuteBatchWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockBypasserExecuteBatchWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DispatchTimelockBypasserExecuteBatchWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockBypasserExecuteBatchWithArgs'
type McmsEncoder_DispatchTimelockBypasserExecuteBatchWithArgs_Call struct {
	*mock.Call
}

// DispatchTimelockBypasserExecuteBatchWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) DispatchTimelockBypasserExecuteBatchWithArgs(args ...interface{}) *McmsEncoder_DispatchTimelockBypasserExecuteBatchWithArgs_Call {
	return &McmsEncoder_DispatchTimelockBypasserExecuteBatchWithArgs_Call{Call: _e.mock.On("DispatchTimelockBypasserExecuteBatchWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_DispatchTimelockBypasserExecuteBatchWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_DispatchTimelockBypasserExecuteBatchWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_DispatchTimelockBypasserExecuteBatchWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DispatchTimelockBypasserExecuteBatchWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DispatchTimelockBypasserExecuteBatchWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_DispatchTimelockBypasserExecuteBatchWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockCancel provides a mock function with given fields: timelock, timelockCallbackParams
func (_m *McmsEncoder) DispatchTimelockCancel(timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockCancel")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error)); ok {
		return rf(timelock, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, module_mcms.TimelockCallbackParams) *bind.EncodedCall); ok {
		r0 = rf(timelock, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(timelock, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DispatchTimelockCancel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockCancel'
type McmsEncoder_DispatchTimelockCancel_Call struct {
	*mock.Call
}

// DispatchTimelockCancel is a helper method to define mock.On call
//   - timelock bind.Object
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *McmsEncoder_Expecter) DispatchTimelockCancel(timelock interface{}, timelockCallbackParams interface{}) *McmsEncoder_DispatchTimelockCancel_Call {
	return &McmsEncoder_DispatchTimelockCancel_Call{Call: _e.mock.On("DispatchTimelockCancel", timelock, timelockCallbackParams)}
}

func (_c *McmsEncoder_DispatchTimelockCancel_Call) Run(run func(timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams)) *McmsEncoder_DispatchTimelockCancel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *McmsEncoder_DispatchTimelockCancel_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DispatchTimelockCancel_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DispatchTimelockCancel_Call) RunAndReturn(run func(bind.Object, module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error)) *McmsEncoder_DispatchTimelockCancel_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockCancelWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) DispatchTimelockCancelWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockCancelWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DispatchTimelockCancelWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockCancelWithArgs'
type McmsEncoder_DispatchTimelockCancelWithArgs_Call struct {
	*mock.Call
}

// DispatchTimelockCancelWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) DispatchTimelockCancelWithArgs(args ...interface{}) *McmsEncoder_DispatchTimelockCancelWithArgs_Call {
	return &McmsEncoder_DispatchTimelockCancelWithArgs_Call{Call: _e.mock.On("DispatchTimelockCancelWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_DispatchTimelockCancelWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_DispatchTimelockCancelWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_DispatchTimelockCancelWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DispatchTimelockCancelWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DispatchTimelockCancelWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_DispatchTimelockCancelWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockExecuteBatch provides a mock function with given fields: timelock, clock, registry, timelockCallbackParams
func (_m *McmsEncoder) DispatchTimelockExecuteBatch(timelock bind.Object, clock bind.Object, registry bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, clock, registry, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockExecuteBatch")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error)); ok {
		return rf(timelock, clock, registry, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) *bind.EncodedCall); ok {
		r0 = rf(timelock, clock, registry, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(timelock, clock, registry, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DispatchTimelockExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockExecuteBatch'
type McmsEncoder_DispatchTimelockExecuteBatch_Call struct {
	*mock.Call
}

// DispatchTimelockExecuteBatch is a helper method to define mock.On call
//   - timelock bind.Object
//   - clock bind.Object
//   - registry bind.Object
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *McmsEncoder_Expecter) DispatchTimelockExecuteBatch(timelock interface{}, clock interface{}, registry interface{}, timelockCallbackParams interface{}) *McmsEncoder_DispatchTimelockExecuteBatch_Call {
	return &McmsEncoder_DispatchTimelockExecuteBatch_Call{Call: _e.mock.On("DispatchTimelockExecuteBatch", timelock, clock, registry, timelockCallbackParams)}
}

func (_c *McmsEncoder_DispatchTimelockExecuteBatch_Call) Run(run func(timelock bind.Object, clock bind.Object, registry bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams)) *McmsEncoder_DispatchTimelockExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(bind.Object), args[3].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *McmsEncoder_DispatchTimelockExecuteBatch_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DispatchTimelockExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DispatchTimelockExecuteBatch_Call) RunAndReturn(run func(bind.Object, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error)) *McmsEncoder_DispatchTimelockExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockExecuteBatchWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) DispatchTimelockExecuteBatchWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockExecuteBatchWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DispatchTimelockExecuteBatchWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockExecuteBatchWithArgs'
type McmsEncoder_DispatchTimelockExecuteBatchWithArgs_Call struct {
	*mock.Call
}

// DispatchTimelockExecuteBatchWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) DispatchTimelockExecuteBatchWithArgs(args ...interface{}) *McmsEncoder_DispatchTimelockExecuteBatchWithArgs_Call {
	return &McmsEncoder_DispatchTimelockExecuteBatchWithArgs_Call{Call: _e.mock.On("DispatchTimelockExecuteBatchWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_DispatchTimelockExecuteBatchWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_DispatchTimelockExecuteBatchWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_DispatchTimelockExecuteBatchWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DispatchTimelockExecuteBatchWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DispatchTimelockExecuteBatchWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_DispatchTimelockExecuteBatchWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockScheduleBatch provides a mock function with given fields: timelock, clock, timelockCallbackParams
func (_m *McmsEncoder) DispatchTimelockScheduleBatch(timelock bind.Object, clock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, clock, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockScheduleBatch")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error)); ok {
		return rf(timelock, clock, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, module_mcms.TimelockCallbackParams) *bind.EncodedCall); ok {
		r0 = rf(timelock, clock, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(timelock, clock, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DispatchTimelockScheduleBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockScheduleBatch'
type McmsEncoder_DispatchTimelockScheduleBatch_Call struct {
	*mock.Call
}

// DispatchTimelockScheduleBatch is a helper method to define mock.On call
//   - timelock bind.Object
//   - clock bind.Object
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *McmsEncoder_Expecter) DispatchTimelockScheduleBatch(timelock interface{}, clock interface{}, timelockCallbackParams interface{}) *McmsEncoder_DispatchTimelockScheduleBatch_Call {
	return &McmsEncoder_DispatchTimelockScheduleBatch_Call{Call: _e.mock.On("DispatchTimelockScheduleBatch", timelock, clock, timelockCallbackParams)}
}

func (_c *McmsEncoder_DispatchTimelockScheduleBatch_Call) Run(run func(timelock bind.Object, clock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams)) *McmsEncoder_DispatchTimelockScheduleBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *McmsEncoder_DispatchTimelockScheduleBatch_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DispatchTimelockScheduleBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DispatchTimelockScheduleBatch_Call) RunAndReturn(run func(bind.Object, bind.Object, module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error)) *McmsEncoder_DispatchTimelockScheduleBatch_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockScheduleBatchWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) DispatchTimelockScheduleBatchWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockScheduleBatchWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DispatchTimelockScheduleBatchWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockScheduleBatchWithArgs'
type McmsEncoder_DispatchTimelockScheduleBatchWithArgs_Call struct {
	*mock.Call
}

// DispatchTimelockScheduleBatchWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) DispatchTimelockScheduleBatchWithArgs(args ...interface{}) *McmsEncoder_DispatchTimelockScheduleBatchWithArgs_Call {
	return &McmsEncoder_DispatchTimelockScheduleBatchWithArgs_Call{Call: _e.mock.On("DispatchTimelockScheduleBatchWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_DispatchTimelockScheduleBatchWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_DispatchTimelockScheduleBatchWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_DispatchTimelockScheduleBatchWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DispatchTimelockScheduleBatchWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DispatchTimelockScheduleBatchWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_DispatchTimelockScheduleBatchWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockUnblockFunction provides a mock function with given fields: timelock, timelockCallbackParams
func (_m *McmsEncoder) DispatchTimelockUnblockFunction(timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockUnblockFunction")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error)); ok {
		return rf(timelock, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, module_mcms.TimelockCallbackParams) *bind.EncodedCall); ok {
		r0 = rf(timelock, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(timelock, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DispatchTimelockUnblockFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockUnblockFunction'
type McmsEncoder_DispatchTimelockUnblockFunction_Call struct {
	*mock.Call
}

// DispatchTimelockUnblockFunction is a helper method to define mock.On call
//   - timelock bind.Object
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *McmsEncoder_Expecter) DispatchTimelockUnblockFunction(timelock interface{}, timelockCallbackParams interface{}) *McmsEncoder_DispatchTimelockUnblockFunction_Call {
	return &McmsEncoder_DispatchTimelockUnblockFunction_Call{Call: _e.mock.On("DispatchTimelockUnblockFunction", timelock, timelockCallbackParams)}
}

func (_c *McmsEncoder_DispatchTimelockUnblockFunction_Call) Run(run func(timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams)) *McmsEncoder_DispatchTimelockUnblockFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *McmsEncoder_DispatchTimelockUnblockFunction_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DispatchTimelockUnblockFunction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DispatchTimelockUnblockFunction_Call) RunAndReturn(run func(bind.Object, module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error)) *McmsEncoder_DispatchTimelockUnblockFunction_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockUnblockFunctionWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) DispatchTimelockUnblockFunctionWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockUnblockFunctionWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DispatchTimelockUnblockFunctionWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockUnblockFunctionWithArgs'
type McmsEncoder_DispatchTimelockUnblockFunctionWithArgs_Call struct {
	*mock.Call
}

// DispatchTimelockUnblockFunctionWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) DispatchTimelockUnblockFunctionWithArgs(args ...interface{}) *McmsEncoder_DispatchTimelockUnblockFunctionWithArgs_Call {
	return &McmsEncoder_DispatchTimelockUnblockFunctionWithArgs_Call{Call: _e.mock.On("DispatchTimelockUnblockFunctionWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_DispatchTimelockUnblockFunctionWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_DispatchTimelockUnblockFunctionWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_DispatchTimelockUnblockFunctionWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DispatchTimelockUnblockFunctionWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DispatchTimelockUnblockFunctionWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_DispatchTimelockUnblockFunctionWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockUpdateMinDelay provides a mock function with given fields: timelock, timelockCallbackParams
func (_m *McmsEncoder) DispatchTimelockUpdateMinDelay(timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockUpdateMinDelay")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error)); ok {
		return rf(timelock, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, module_mcms.TimelockCallbackParams) *bind.EncodedCall); ok {
		r0 = rf(timelock, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(timelock, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DispatchTimelockUpdateMinDelay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockUpdateMinDelay'
type McmsEncoder_DispatchTimelockUpdateMinDelay_Call struct {
	*mock.Call
}

// DispatchTimelockUpdateMinDelay is a helper method to define mock.On call
//   - timelock bind.Object
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *McmsEncoder_Expecter) DispatchTimelockUpdateMinDelay(timelock interface{}, timelockCallbackParams interface{}) *McmsEncoder_DispatchTimelockUpdateMinDelay_Call {
	return &McmsEncoder_DispatchTimelockUpdateMinDelay_Call{Call: _e.mock.On("DispatchTimelockUpdateMinDelay", timelock, timelockCallbackParams)}
}

func (_c *McmsEncoder_DispatchTimelockUpdateMinDelay_Call) Run(run func(timelock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams)) *McmsEncoder_DispatchTimelockUpdateMinDelay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *McmsEncoder_DispatchTimelockUpdateMinDelay_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DispatchTimelockUpdateMinDelay_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DispatchTimelockUpdateMinDelay_Call) RunAndReturn(run func(bind.Object, module_mcms.TimelockCallbackParams) (*bind.EncodedCall, error)) *McmsEncoder_DispatchTimelockUpdateMinDelay_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockUpdateMinDelayWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) DispatchTimelockUpdateMinDelayWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockUpdateMinDelayWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_DispatchTimelockUpdateMinDelayWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockUpdateMinDelayWithArgs'
type McmsEncoder_DispatchTimelockUpdateMinDelayWithArgs_Call struct {
	*mock.Call
}

// DispatchTimelockUpdateMinDelayWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) DispatchTimelockUpdateMinDelayWithArgs(args ...interface{}) *McmsEncoder_DispatchTimelockUpdateMinDelayWithArgs_Call {
	return &McmsEncoder_DispatchTimelockUpdateMinDelayWithArgs_Call{Call: _e.mock.On("DispatchTimelockUpdateMinDelayWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_DispatchTimelockUpdateMinDelayWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_DispatchTimelockUpdateMinDelayWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_DispatchTimelockUpdateMinDelayWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_DispatchTimelockUpdateMinDelayWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_DispatchTimelockUpdateMinDelayWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_DispatchTimelockUpdateMinDelayWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// Execute provides a mock function with given fields: state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof
func (_m *McmsEncoder) Execute(state bind.Object, clock bind.Object, role byte, chainId *big.Int, multisigAddr string, nonce uint64, to string, moduleName string, functionName string, data []byte, proof [][]byte) (*bind.EncodedCall, error) {
	ret := _m.Called(state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, byte, *big.Int, string, uint64, string, string, string, []byte, [][]byte) (*bind.EncodedCall, error)); ok {
		return rf(state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, byte, *big.Int, string, uint64, string, string, string, []byte, [][]byte) *bind.EncodedCall); ok {
		r0 = rf(state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, byte, *big.Int, string, uint64, string, string, string, []byte, [][]byte) error); ok {
		r1 = rf(state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type McmsEncoder_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - state bind.Object
//   - clock bind.Object
//   - role byte
//   - chainId *big.Int
//   - multisigAddr string
//   - nonce uint64
//   - to string
//   - moduleName string
//   - functionName string
//   - data []byte
//   - proof [][]byte
func (_e *McmsEncoder_Expecter) Execute(state interface{}, clock interface{}, role interface{}, chainId interface{}, multisigAddr interface{}, nonce interface{}, to interface{}, moduleName interface{}, functionName interface{}, data interface{}, proof interface{}) *McmsEncoder_Execute_Call {
	return &McmsEncoder_Execute_Call{Call: _e.mock.On("Execute", state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)}
}

func (_c *McmsEncoder_Execute_Call) Run(run func(state bind.Object, clock bind.Object, role byte, chainId *big.Int, multisigAddr string, nonce uint64, to string, moduleName string, functionName string, data []byte, proof [][]byte)) *McmsEncoder_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(byte), args[3].(*big.Int), args[4].(string), args[5].(uint64), args[6].(string), args[7].(string), args[8].(string), args[9].([]byte), args[10].([][]byte))
	})
	return _c
}

func (_c *McmsEncoder_Execute_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_Execute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_Execute_Call) RunAndReturn(run func(bind.Object, bind.Object, byte, *big.Int, string, uint64, string, string, string, []byte, [][]byte) (*bind.EncodedCall, error)) *McmsEncoder_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) ExecuteWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ExecuteWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteWithArgs'
type McmsEncoder_ExecuteWithArgs_Call struct {
	*mock.Call
}

// ExecuteWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) ExecuteWithArgs(args ...interface{}) *McmsEncoder_ExecuteWithArgs_Call {
	return &McmsEncoder_ExecuteWithArgs_Call{Call: _e.mock.On("ExecuteWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_ExecuteWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_ExecuteWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_ExecuteWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ExecuteWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ExecuteWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_ExecuteWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ExpiringRootAndOpCount provides a mock function with given fields: state, role
func (_m *McmsEncoder) ExpiringRootAndOpCount(state bind.Object, role byte) (*bind.EncodedCall, error) {
	ret := _m.Called(state, role)

	if len(ret) == 0 {
		panic("no return value specified for ExpiringRootAndOpCount")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, byte) (*bind.EncodedCall, error)); ok {
		return rf(state, role)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, byte) *bind.EncodedCall); ok {
		r0 = rf(state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, byte) error); ok {
		r1 = rf(state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ExpiringRootAndOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpiringRootAndOpCount'
type McmsEncoder_ExpiringRootAndOpCount_Call struct {
	*mock.Call
}

// ExpiringRootAndOpCount is a helper method to define mock.On call
//   - state bind.Object
//   - role byte
func (_e *McmsEncoder_Expecter) ExpiringRootAndOpCount(state interface{}, role interface{}) *McmsEncoder_ExpiringRootAndOpCount_Call {
	return &McmsEncoder_ExpiringRootAndOpCount_Call{Call: _e.mock.On("ExpiringRootAndOpCount", state, role)}
}

func (_c *McmsEncoder_ExpiringRootAndOpCount_Call) Run(run func(state bind.Object, role byte)) *McmsEncoder_ExpiringRootAndOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(byte))
	})
	return _c
}

func (_c *McmsEncoder_ExpiringRootAndOpCount_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ExpiringRootAndOpCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ExpiringRootAndOpCount_Call) RunAndReturn(run func(bind.Object, byte) (*bind.EncodedCall, error)) *McmsEncoder_ExpiringRootAndOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// ExpiringRootAndOpCountWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) ExpiringRootAndOpCountWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExpiringRootAndOpCountWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ExpiringRootAndOpCountWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpiringRootAndOpCountWithArgs'
type McmsEncoder_ExpiringRootAndOpCountWithArgs_Call struct {
	*mock.Call
}

// ExpiringRootAndOpCountWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) ExpiringRootAndOpCountWithArgs(args ...interface{}) *McmsEncoder_ExpiringRootAndOpCountWithArgs_Call {
	return &McmsEncoder_ExpiringRootAndOpCountWithArgs_Call{Call: _e.mock.On("ExpiringRootAndOpCountWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_ExpiringRootAndOpCountWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_ExpiringRootAndOpCountWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_ExpiringRootAndOpCountWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ExpiringRootAndOpCountWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ExpiringRootAndOpCountWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_ExpiringRootAndOpCountWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionName provides a mock function with given fields: function
func (_m *McmsEncoder) FunctionName(function module_mcms.Function) (*bind.EncodedCall, error) {
	ret := _m.Called(function)

	if len(ret) == 0 {
		panic("no return value specified for FunctionName")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.Function) (*bind.EncodedCall, error)); ok {
		return rf(function)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.Function) *bind.EncodedCall); ok {
		r0 = rf(function)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.Function) error); ok {
		r1 = rf(function)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_FunctionName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionName'
type McmsEncoder_FunctionName_Call struct {
	*mock.Call
}

// FunctionName is a helper method to define mock.On call
//   - function module_mcms.Function
func (_e *McmsEncoder_Expecter) FunctionName(function interface{}) *McmsEncoder_FunctionName_Call {
	return &McmsEncoder_FunctionName_Call{Call: _e.mock.On("FunctionName", function)}
}

func (_c *McmsEncoder_FunctionName_Call) Run(run func(function module_mcms.Function)) *McmsEncoder_FunctionName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.Function))
	})
	return _c
}

func (_c *McmsEncoder_FunctionName_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_FunctionName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_FunctionName_Call) RunAndReturn(run func(module_mcms.Function) (*bind.EncodedCall, error)) *McmsEncoder_FunctionName_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionNameWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) FunctionNameWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FunctionNameWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_FunctionNameWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionNameWithArgs'
type McmsEncoder_FunctionNameWithArgs_Call struct {
	*mock.Call
}

// FunctionNameWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) FunctionNameWithArgs(args ...interface{}) *McmsEncoder_FunctionNameWithArgs_Call {
	return &McmsEncoder_FunctionNameWithArgs_Call{Call: _e.mock.On("FunctionNameWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_FunctionNameWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_FunctionNameWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_FunctionNameWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_FunctionNameWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_FunctionNameWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_FunctionNameWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// GetConfig provides a mock function with given fields: state, role
func (_m *McmsEncoder) GetConfig(state bind.Object, role byte) (*bind.EncodedCall, error) {
	ret := _m.Called(state, role)

	if len(ret) == 0 {
		panic("no return value specified for GetConfig")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, byte) (*bind.EncodedCall, error)); ok {
		return rf(state, role)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, byte) *bind.EncodedCall); ok {
		r0 = rf(state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, byte) error); ok {
		r1 = rf(state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_GetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConfig'
type McmsEncoder_GetConfig_Call struct {
	*mock.Call
}

// GetConfig is a helper method to define mock.On call
//   - state bind.Object
//   - role byte
func (_e *McmsEncoder_Expecter) GetConfig(state interface{}, role interface{}) *McmsEncoder_GetConfig_Call {
	return &McmsEncoder_GetConfig_Call{Call: _e.mock.On("GetConfig", state, role)}
}

func (_c *McmsEncoder_GetConfig_Call) Run(run func(state bind.Object, role byte)) *McmsEncoder_GetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(byte))
	})
	return _c
}

func (_c *McmsEncoder_GetConfig_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_GetConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_GetConfig_Call) RunAndReturn(run func(bind.Object, byte) (*bind.EncodedCall, error)) *McmsEncoder_GetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetConfigWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) GetConfigWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConfigWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_GetConfigWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConfigWithArgs'
type McmsEncoder_GetConfigWithArgs_Call struct {
	*mock.Call
}

// GetConfigWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) GetConfigWithArgs(args ...interface{}) *McmsEncoder_GetConfigWithArgs_Call {
	return &McmsEncoder_GetConfigWithArgs_Call{Call: _e.mock.On("GetConfigWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_GetConfigWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_GetConfigWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_GetConfigWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_GetConfigWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_GetConfigWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_GetConfigWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// GetOpCount provides a mock function with given fields: state, role
func (_m *McmsEncoder) GetOpCount(state bind.Object, role byte) (*bind.EncodedCall, error) {
	ret := _m.Called(state, role)

	if len(ret) == 0 {
		panic("no return value specified for GetOpCount")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, byte) (*bind.EncodedCall, error)); ok {
		return rf(state, role)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, byte) *bind.EncodedCall); ok {
		r0 = rf(state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, byte) error); ok {
		r1 = rf(state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_GetOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOpCount'
type McmsEncoder_GetOpCount_Call struct {
	*mock.Call
}

// GetOpCount is a helper method to define mock.On call
//   - state bind.Object
//   - role byte
func (_e *McmsEncoder_Expecter) GetOpCount(state interface{}, role interface{}) *McmsEncoder_GetOpCount_Call {
	return &McmsEncoder_GetOpCount_Call{Call: _e.mock.On("GetOpCount", state, role)}
}

func (_c *McmsEncoder_GetOpCount_Call) Run(run func(state bind.Object, role byte)) *McmsEncoder_GetOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(byte))
	})
	return _c
}

func (_c *McmsEncoder_GetOpCount_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_GetOpCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_GetOpCount_Call) RunAndReturn(run func(bind.Object, byte) (*bind.EncodedCall, error)) *McmsEncoder_GetOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetOpCountWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) GetOpCountWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetOpCountWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_GetOpCountWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOpCountWithArgs'
type McmsEncoder_GetOpCountWithArgs_Call struct {
	*mock.Call
}

// GetOpCountWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) GetOpCountWithArgs(args ...interface{}) *McmsEncoder_GetOpCountWithArgs_Call {
	return &McmsEncoder_GetOpCountWithArgs_Call{Call: _e.mock.On("GetOpCountWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_GetOpCountWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_GetOpCountWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_GetOpCountWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_GetOpCountWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_GetOpCountWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_GetOpCountWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoot provides a mock function with given fields: state, role
func (_m *McmsEncoder) GetRoot(state bind.Object, role byte) (*bind.EncodedCall, error) {
	ret := _m.Called(state, role)

	if len(ret) == 0 {
		panic("no return value specified for GetRoot")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, byte) (*bind.EncodedCall, error)); ok {
		return rf(state, role)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, byte) *bind.EncodedCall); ok {
		r0 = rf(state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, byte) error); ok {
		r1 = rf(state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_GetRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoot'
type McmsEncoder_GetRoot_Call struct {
	*mock.Call
}

// GetRoot is a helper method to define mock.On call
//   - state bind.Object
//   - role byte
func (_e *McmsEncoder_Expecter) GetRoot(state interface{}, role interface{}) *McmsEncoder_GetRoot_Call {
	return &McmsEncoder_GetRoot_Call{Call: _e.mock.On("GetRoot", state, role)}
}

func (_c *McmsEncoder_GetRoot_Call) Run(run func(state bind.Object, role byte)) *McmsEncoder_GetRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(byte))
	})
	return _c
}

func (_c *McmsEncoder_GetRoot_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_GetRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_GetRoot_Call) RunAndReturn(run func(bind.Object, byte) (*bind.EncodedCall, error)) *McmsEncoder_GetRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetRootMetadata provides a mock function with given fields: state, role
func (_m *McmsEncoder) GetRootMetadata(state bind.Object, role byte) (*bind.EncodedCall, error) {
	ret := _m.Called(state, role)

	if len(ret) == 0 {
		panic("no return value specified for GetRootMetadata")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, byte) (*bind.EncodedCall, error)); ok {
		return rf(state, role)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, byte) *bind.EncodedCall); ok {
		r0 = rf(state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, byte) error); ok {
		r1 = rf(state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_GetRootMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRootMetadata'
type McmsEncoder_GetRootMetadata_Call struct {
	*mock.Call
}

// GetRootMetadata is a helper method to define mock.On call
//   - state bind.Object
//   - role byte
func (_e *McmsEncoder_Expecter) GetRootMetadata(state interface{}, role interface{}) *McmsEncoder_GetRootMetadata_Call {
	return &McmsEncoder_GetRootMetadata_Call{Call: _e.mock.On("GetRootMetadata", state, role)}
}

func (_c *McmsEncoder_GetRootMetadata_Call) Run(run func(state bind.Object, role byte)) *McmsEncoder_GetRootMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(byte))
	})
	return _c
}

func (_c *McmsEncoder_GetRootMetadata_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_GetRootMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_GetRootMetadata_Call) RunAndReturn(run func(bind.Object, byte) (*bind.EncodedCall, error)) *McmsEncoder_GetRootMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// GetRootMetadataWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) GetRootMetadataWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRootMetadataWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_GetRootMetadataWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRootMetadataWithArgs'
type McmsEncoder_GetRootMetadataWithArgs_Call struct {
	*mock.Call
}

// GetRootMetadataWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) GetRootMetadataWithArgs(args ...interface{}) *McmsEncoder_GetRootMetadataWithArgs_Call {
	return &McmsEncoder_GetRootMetadataWithArgs_Call{Call: _e.mock.On("GetRootMetadataWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_GetRootMetadataWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_GetRootMetadataWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_GetRootMetadataWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_GetRootMetadataWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_GetRootMetadataWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_GetRootMetadataWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// GetRootWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) GetRootWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRootWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_GetRootWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRootWithArgs'
type McmsEncoder_GetRootWithArgs_Call struct {
	*mock.Call
}

// GetRootWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) GetRootWithArgs(args ...interface{}) *McmsEncoder_GetRootWithArgs_Call {
	return &McmsEncoder_GetRootWithArgs_Call{Call: _e.mock.On("GetRootWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_GetRootWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_GetRootWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_GetRootWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_GetRootWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_GetRootWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_GetRootWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// HashOpLeaf provides a mock function with given fields: domainSeparator, op
func (_m *McmsEncoder) HashOpLeaf(domainSeparator []byte, op module_mcms.Op) (*bind.EncodedCall, error) {
	ret := _m.Called(domainSeparator, op)

	if len(ret) == 0 {
		panic("no return value specified for HashOpLeaf")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, module_mcms.Op) (*bind.EncodedCall, error)); ok {
		return rf(domainSeparator, op)
	}
	if rf, ok := ret.Get(0).(func([]byte, module_mcms.Op) *bind.EncodedCall); ok {
		r0 = rf(domainSeparator, op)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte, module_mcms.Op) error); ok {
		r1 = rf(domainSeparator, op)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_HashOpLeaf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashOpLeaf'
type McmsEncoder_HashOpLeaf_Call struct {
	*mock.Call
}

// HashOpLeaf is a helper method to define mock.On call
//   - domainSeparator []byte
//   - op module_mcms.Op
func (_e *McmsEncoder_Expecter) HashOpLeaf(domainSeparator interface{}, op interface{}) *McmsEncoder_HashOpLeaf_Call {
	return &McmsEncoder_HashOpLeaf_Call{Call: _e.mock.On("HashOpLeaf", domainSeparator, op)}
}

func (_c *McmsEncoder_HashOpLeaf_Call) Run(run func(domainSeparator []byte, op module_mcms.Op)) *McmsEncoder_HashOpLeaf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].(module_mcms.Op))
	})
	return _c
}

func (_c *McmsEncoder_HashOpLeaf_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_HashOpLeaf_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_HashOpLeaf_Call) RunAndReturn(run func([]byte, module_mcms.Op) (*bind.EncodedCall, error)) *McmsEncoder_HashOpLeaf_Call {
	_c.Call.Return(run)
	return _c
}

// HashOpLeafWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) HashOpLeafWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HashOpLeafWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_HashOpLeafWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashOpLeafWithArgs'
type McmsEncoder_HashOpLeafWithArgs_Call struct {
	*mock.Call
}

// HashOpLeafWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) HashOpLeafWithArgs(args ...interface{}) *McmsEncoder_HashOpLeafWithArgs_Call {
	return &McmsEncoder_HashOpLeafWithArgs_Call{Call: _e.mock.On("HashOpLeafWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_HashOpLeafWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_HashOpLeafWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_HashOpLeafWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_HashOpLeafWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_HashOpLeafWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_HashOpLeafWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// HashOperationBatch provides a mock function with given fields: calls, predecessor, salt
func (_m *McmsEncoder) HashOperationBatch(calls []module_mcms.Call, predecessor []byte, salt []byte) (*bind.EncodedCall, error) {
	ret := _m.Called(calls, predecessor, salt)

	if len(ret) == 0 {
		panic("no return value specified for HashOperationBatch")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func([]module_mcms.Call, []byte, []byte) (*bind.EncodedCall, error)); ok {
		return rf(calls, predecessor, salt)
	}
	if rf, ok := ret.Get(0).(func([]module_mcms.Call, []byte, []byte) *bind.EncodedCall); ok {
		r0 = rf(calls, predecessor, salt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func([]module_mcms.Call, []byte, []byte) error); ok {
		r1 = rf(calls, predecessor, salt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_HashOperationBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashOperationBatch'
type McmsEncoder_HashOperationBatch_Call struct {
	*mock.Call
}

// HashOperationBatch is a helper method to define mock.On call
//   - calls []module_mcms.Call
//   - predecessor []byte
//   - salt []byte
func (_e *McmsEncoder_Expecter) HashOperationBatch(calls interface{}, predecessor interface{}, salt interface{}) *McmsEncoder_HashOperationBatch_Call {
	return &McmsEncoder_HashOperationBatch_Call{Call: _e.mock.On("HashOperationBatch", calls, predecessor, salt)}
}

func (_c *McmsEncoder_HashOperationBatch_Call) Run(run func(calls []module_mcms.Call, predecessor []byte, salt []byte)) *McmsEncoder_HashOperationBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]module_mcms.Call), args[1].([]byte), args[2].([]byte))
	})
	return _c
}

func (_c *McmsEncoder_HashOperationBatch_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_HashOperationBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_HashOperationBatch_Call) RunAndReturn(run func([]module_mcms.Call, []byte, []byte) (*bind.EncodedCall, error)) *McmsEncoder_HashOperationBatch_Call {
	_c.Call.Return(run)
	return _c
}

// HashOperationBatchWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) HashOperationBatchWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HashOperationBatchWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_HashOperationBatchWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashOperationBatchWithArgs'
type McmsEncoder_HashOperationBatchWithArgs_Call struct {
	*mock.Call
}

// HashOperationBatchWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) HashOperationBatchWithArgs(args ...interface{}) *McmsEncoder_HashOperationBatchWithArgs_Call {
	return &McmsEncoder_HashOperationBatchWithArgs_Call{Call: _e.mock.On("HashOperationBatchWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_HashOperationBatchWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_HashOperationBatchWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_HashOperationBatchWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_HashOperationBatchWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_HashOperationBatchWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_HashOperationBatchWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// IsValidRole provides a mock function with given fields: role
func (_m *McmsEncoder) IsValidRole(role byte) (*bind.EncodedCall, error) {
	ret := _m.Called(role)

	if len(ret) == 0 {
		panic("no return value specified for IsValidRole")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(byte) (*bind.EncodedCall, error)); ok {
		return rf(role)
	}
	if rf, ok := ret.Get(0).(func(byte) *bind.EncodedCall); ok {
		r0 = rf(role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(byte) error); ok {
		r1 = rf(role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_IsValidRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsValidRole'
type McmsEncoder_IsValidRole_Call struct {
	*mock.Call
}

// IsValidRole is a helper method to define mock.On call
//   - role byte
func (_e *McmsEncoder_Expecter) IsValidRole(role interface{}) *McmsEncoder_IsValidRole_Call {
	return &McmsEncoder_IsValidRole_Call{Call: _e.mock.On("IsValidRole", role)}
}

func (_c *McmsEncoder_IsValidRole_Call) Run(run func(role byte)) *McmsEncoder_IsValidRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(byte))
	})
	return _c
}

func (_c *McmsEncoder_IsValidRole_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_IsValidRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_IsValidRole_Call) RunAndReturn(run func(byte) (*bind.EncodedCall, error)) *McmsEncoder_IsValidRole_Call {
	_c.Call.Return(run)
	return _c
}

// IsValidRoleWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) IsValidRoleWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IsValidRoleWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_IsValidRoleWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsValidRoleWithArgs'
type McmsEncoder_IsValidRoleWithArgs_Call struct {
	*mock.Call
}

// IsValidRoleWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) IsValidRoleWithArgs(args ...interface{}) *McmsEncoder_IsValidRoleWithArgs_Call {
	return &McmsEncoder_IsValidRoleWithArgs_Call{Call: _e.mock.On("IsValidRoleWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_IsValidRoleWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_IsValidRoleWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_IsValidRoleWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_IsValidRoleWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_IsValidRoleWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_IsValidRoleWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// MaxNumSigners provides a mock function with no fields
func (_m *McmsEncoder) MaxNumSigners() (*bind.EncodedCall, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MaxNumSigners")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func() (*bind.EncodedCall, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *bind.EncodedCall); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_MaxNumSigners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxNumSigners'
type McmsEncoder_MaxNumSigners_Call struct {
	*mock.Call
}

// MaxNumSigners is a helper method to define mock.On call
func (_e *McmsEncoder_Expecter) MaxNumSigners() *McmsEncoder_MaxNumSigners_Call {
	return &McmsEncoder_MaxNumSigners_Call{Call: _e.mock.On("MaxNumSigners")}
}

func (_c *McmsEncoder_MaxNumSigners_Call) Run(run func()) *McmsEncoder_MaxNumSigners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *McmsEncoder_MaxNumSigners_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_MaxNumSigners_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_MaxNumSigners_Call) RunAndReturn(run func() (*bind.EncodedCall, error)) *McmsEncoder_MaxNumSigners_Call {
	_c.Call.Return(run)
	return _c
}

// MaxNumSignersWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) MaxNumSignersWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MaxNumSignersWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_MaxNumSignersWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxNumSignersWithArgs'
type McmsEncoder_MaxNumSignersWithArgs_Call struct {
	*mock.Call
}

// MaxNumSignersWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) MaxNumSignersWithArgs(args ...interface{}) *McmsEncoder_MaxNumSignersWithArgs_Call {
	return &McmsEncoder_MaxNumSignersWithArgs_Call{Call: _e.mock.On("MaxNumSignersWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_MaxNumSignersWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_MaxNumSignersWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_MaxNumSignersWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_MaxNumSignersWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_MaxNumSignersWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_MaxNumSignersWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// McmsDispatchToAccount provides a mock function with given fields: registry, accountState, executingCallbackParams
func (_m *McmsEncoder) McmsDispatchToAccount(registry bind.Object, accountState bind.Object, executingCallbackParams bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(registry, accountState, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsDispatchToAccount")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(registry, accountState, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) *bind.EncodedCall); ok {
		r0 = rf(registry, accountState, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(registry, accountState, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsDispatchToAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsDispatchToAccount'
type McmsEncoder_McmsDispatchToAccount_Call struct {
	*mock.Call
}

// McmsDispatchToAccount is a helper method to define mock.On call
//   - registry bind.Object
//   - accountState bind.Object
//   - executingCallbackParams bind.Object
func (_e *McmsEncoder_Expecter) McmsDispatchToAccount(registry interface{}, accountState interface{}, executingCallbackParams interface{}) *McmsEncoder_McmsDispatchToAccount_Call {
	return &McmsEncoder_McmsDispatchToAccount_Call{Call: _e.mock.On("McmsDispatchToAccount", registry, accountState, executingCallbackParams)}
}

func (_c *McmsEncoder_McmsDispatchToAccount_Call) Run(run func(registry bind.Object, accountState bind.Object, executingCallbackParams bind.Object)) *McmsEncoder_McmsDispatchToAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(bind.Object))
	})
	return _c
}

func (_c *McmsEncoder_McmsDispatchToAccount_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsDispatchToAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsDispatchToAccount_Call) RunAndReturn(run func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)) *McmsEncoder_McmsDispatchToAccount_Call {
	_c.Call.Return(run)
	return _c
}

// McmsDispatchToAccountWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) McmsDispatchToAccountWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for McmsDispatchToAccountWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsDispatchToAccountWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsDispatchToAccountWithArgs'
type McmsEncoder_McmsDispatchToAccountWithArgs_Call struct {
	*mock.Call
}

// McmsDispatchToAccountWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) McmsDispatchToAccountWithArgs(args ...interface{}) *McmsEncoder_McmsDispatchToAccountWithArgs_Call {
	return &McmsEncoder_McmsDispatchToAccountWithArgs_Call{Call: _e.mock.On("McmsDispatchToAccountWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_McmsDispatchToAccountWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_McmsDispatchToAccountWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_McmsDispatchToAccountWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsDispatchToAccountWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsDispatchToAccountWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_McmsDispatchToAccountWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// McmsDispatchToDeployer provides a mock function with given fields: registry, deployerState, executingCallbackParams
func (_m *McmsEncoder) McmsDispatchToDeployer(registry bind.Object, deployerState bind.Object, executingCallbackParams bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(registry, deployerState, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsDispatchToDeployer")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(registry, deployerState, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) *bind.EncodedCall); ok {
		r0 = rf(registry, deployerState, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(registry, deployerState, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsDispatchToDeployer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsDispatchToDeployer'
type McmsEncoder_McmsDispatchToDeployer_Call struct {
	*mock.Call
}

// McmsDispatchToDeployer is a helper method to define mock.On call
//   - registry bind.Object
//   - deployerState bind.Object
//   - executingCallbackParams bind.Object
func (_e *McmsEncoder_Expecter) McmsDispatchToDeployer(registry interface{}, deployerState interface{}, executingCallbackParams interface{}) *McmsEncoder_McmsDispatchToDeployer_Call {
	return &McmsEncoder_McmsDispatchToDeployer_Call{Call: _e.mock.On("McmsDispatchToDeployer", registry, deployerState, executingCallbackParams)}
}

func (_c *McmsEncoder_McmsDispatchToDeployer_Call) Run(run func(registry bind.Object, deployerState bind.Object, executingCallbackParams bind.Object)) *McmsEncoder_McmsDispatchToDeployer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(bind.Object))
	})
	return _c
}

func (_c *McmsEncoder_McmsDispatchToDeployer_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsDispatchToDeployer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsDispatchToDeployer_Call) RunAndReturn(run func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)) *McmsEncoder_McmsDispatchToDeployer_Call {
	_c.Call.Return(run)
	return _c
}

// McmsDispatchToDeployerWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) McmsDispatchToDeployerWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for McmsDispatchToDeployerWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsDispatchToDeployerWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsDispatchToDeployerWithArgs'
type McmsEncoder_McmsDispatchToDeployerWithArgs_Call struct {
	*mock.Call
}

// McmsDispatchToDeployerWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) McmsDispatchToDeployerWithArgs(args ...interface{}) *McmsEncoder_McmsDispatchToDeployerWithArgs_Call {
	return &McmsEncoder_McmsDispatchToDeployerWithArgs_Call{Call: _e.mock.On("McmsDispatchToDeployerWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_McmsDispatchToDeployerWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_McmsDispatchToDeployerWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_McmsDispatchToDeployerWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsDispatchToDeployerWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsDispatchToDeployerWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_McmsDispatchToDeployerWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// McmsDispatchToRegistry provides a mock function with given fields: registry, executingCallbackParams
func (_m *McmsEncoder) McmsDispatchToRegistry(registry bind.Object, executingCallbackParams bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsDispatchToRegistry")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object) *bind.EncodedCall); ok {
		r0 = rf(registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object) error); ok {
		r1 = rf(registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsDispatchToRegistry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsDispatchToRegistry'
type McmsEncoder_McmsDispatchToRegistry_Call struct {
	*mock.Call
}

// McmsDispatchToRegistry is a helper method to define mock.On call
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *McmsEncoder_Expecter) McmsDispatchToRegistry(registry interface{}, executingCallbackParams interface{}) *McmsEncoder_McmsDispatchToRegistry_Call {
	return &McmsEncoder_McmsDispatchToRegistry_Call{Call: _e.mock.On("McmsDispatchToRegistry", registry, executingCallbackParams)}
}

func (_c *McmsEncoder_McmsDispatchToRegistry_Call) Run(run func(registry bind.Object, executingCallbackParams bind.Object)) *McmsEncoder_McmsDispatchToRegistry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object))
	})
	return _c
}

func (_c *McmsEncoder_McmsDispatchToRegistry_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsDispatchToRegistry_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsDispatchToRegistry_Call) RunAndReturn(run func(bind.Object, bind.Object) (*bind.EncodedCall, error)) *McmsEncoder_McmsDispatchToRegistry_Call {
	_c.Call.Return(run)
	return _c
}

// McmsDispatchToRegistryWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) McmsDispatchToRegistryWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for McmsDispatchToRegistryWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsDispatchToRegistryWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsDispatchToRegistryWithArgs'
type McmsEncoder_McmsDispatchToRegistryWithArgs_Call struct {
	*mock.Call
}

// McmsDispatchToRegistryWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) McmsDispatchToRegistryWithArgs(args ...interface{}) *McmsEncoder_McmsDispatchToRegistryWithArgs_Call {
	return &McmsEncoder_McmsDispatchToRegistryWithArgs_Call{Call: _e.mock.On("McmsDispatchToRegistryWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_McmsDispatchToRegistryWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_McmsDispatchToRegistryWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_McmsDispatchToRegistryWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsDispatchToRegistryWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsDispatchToRegistryWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_McmsDispatchToRegistryWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// McmsSetConfig provides a mock function with given fields: registry, state, executingCallbackParams
func (_m *McmsEncoder) McmsSetConfig(registry bind.Object, state bind.Object, executingCallbackParams bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(registry, state, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsSetConfig")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(registry, state, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) *bind.EncodedCall); ok {
		r0 = rf(registry, state, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(registry, state, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsSetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsSetConfig'
type McmsEncoder_McmsSetConfig_Call struct {
	*mock.Call
}

// McmsSetConfig is a helper method to define mock.On call
//   - registry bind.Object
//   - state bind.Object
//   - executingCallbackParams bind.Object
func (_e *McmsEncoder_Expecter) McmsSetConfig(registry interface{}, state interface{}, executingCallbackParams interface{}) *McmsEncoder_McmsSetConfig_Call {
	return &McmsEncoder_McmsSetConfig_Call{Call: _e.mock.On("McmsSetConfig", registry, state, executingCallbackParams)}
}

func (_c *McmsEncoder_McmsSetConfig_Call) Run(run func(registry bind.Object, state bind.Object, executingCallbackParams bind.Object)) *McmsEncoder_McmsSetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(bind.Object))
	})
	return _c
}

func (_c *McmsEncoder_McmsSetConfig_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsSetConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsSetConfig_Call) RunAndReturn(run func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)) *McmsEncoder_McmsSetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// McmsSetConfigWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) McmsSetConfigWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for McmsSetConfigWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsSetConfigWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsSetConfigWithArgs'
type McmsEncoder_McmsSetConfigWithArgs_Call struct {
	*mock.Call
}

// McmsSetConfigWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) McmsSetConfigWithArgs(args ...interface{}) *McmsEncoder_McmsSetConfigWithArgs_Call {
	return &McmsEncoder_McmsSetConfigWithArgs_Call{Call: _e.mock.On("McmsSetConfigWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_McmsSetConfigWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_McmsSetConfigWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_McmsSetConfigWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsSetConfigWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsSetConfigWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_McmsSetConfigWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockBlockFunction provides a mock function with given fields: timelock, registry, executingCallbackParams
func (_m *McmsEncoder) McmsTimelockBlockFunction(timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockBlockFunction")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(timelock, registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) *bind.EncodedCall); ok {
		r0 = rf(timelock, registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(timelock, registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsTimelockBlockFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockBlockFunction'
type McmsEncoder_McmsTimelockBlockFunction_Call struct {
	*mock.Call
}

// McmsTimelockBlockFunction is a helper method to define mock.On call
//   - timelock bind.Object
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *McmsEncoder_Expecter) McmsTimelockBlockFunction(timelock interface{}, registry interface{}, executingCallbackParams interface{}) *McmsEncoder_McmsTimelockBlockFunction_Call {
	return &McmsEncoder_McmsTimelockBlockFunction_Call{Call: _e.mock.On("McmsTimelockBlockFunction", timelock, registry, executingCallbackParams)}
}

func (_c *McmsEncoder_McmsTimelockBlockFunction_Call) Run(run func(timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object)) *McmsEncoder_McmsTimelockBlockFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(bind.Object))
	})
	return _c
}

func (_c *McmsEncoder_McmsTimelockBlockFunction_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsTimelockBlockFunction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsTimelockBlockFunction_Call) RunAndReturn(run func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)) *McmsEncoder_McmsTimelockBlockFunction_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockBlockFunctionWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) McmsTimelockBlockFunctionWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockBlockFunctionWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsTimelockBlockFunctionWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockBlockFunctionWithArgs'
type McmsEncoder_McmsTimelockBlockFunctionWithArgs_Call struct {
	*mock.Call
}

// McmsTimelockBlockFunctionWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) McmsTimelockBlockFunctionWithArgs(args ...interface{}) *McmsEncoder_McmsTimelockBlockFunctionWithArgs_Call {
	return &McmsEncoder_McmsTimelockBlockFunctionWithArgs_Call{Call: _e.mock.On("McmsTimelockBlockFunctionWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_McmsTimelockBlockFunctionWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_McmsTimelockBlockFunctionWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_McmsTimelockBlockFunctionWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsTimelockBlockFunctionWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsTimelockBlockFunctionWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_McmsTimelockBlockFunctionWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockBypasserExecuteBatch provides a mock function with given fields: registry, executingCallbackParams
func (_m *McmsEncoder) McmsTimelockBypasserExecuteBatch(registry bind.Object, executingCallbackParams bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockBypasserExecuteBatch")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object) *bind.EncodedCall); ok {
		r0 = rf(registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object) error); ok {
		r1 = rf(registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsTimelockBypasserExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockBypasserExecuteBatch'
type McmsEncoder_McmsTimelockBypasserExecuteBatch_Call struct {
	*mock.Call
}

// McmsTimelockBypasserExecuteBatch is a helper method to define mock.On call
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *McmsEncoder_Expecter) McmsTimelockBypasserExecuteBatch(registry interface{}, executingCallbackParams interface{}) *McmsEncoder_McmsTimelockBypasserExecuteBatch_Call {
	return &McmsEncoder_McmsTimelockBypasserExecuteBatch_Call{Call: _e.mock.On("McmsTimelockBypasserExecuteBatch", registry, executingCallbackParams)}
}

func (_c *McmsEncoder_McmsTimelockBypasserExecuteBatch_Call) Run(run func(registry bind.Object, executingCallbackParams bind.Object)) *McmsEncoder_McmsTimelockBypasserExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object))
	})
	return _c
}

func (_c *McmsEncoder_McmsTimelockBypasserExecuteBatch_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsTimelockBypasserExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsTimelockBypasserExecuteBatch_Call) RunAndReturn(run func(bind.Object, bind.Object) (*bind.EncodedCall, error)) *McmsEncoder_McmsTimelockBypasserExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockBypasserExecuteBatchWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) McmsTimelockBypasserExecuteBatchWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockBypasserExecuteBatchWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsTimelockBypasserExecuteBatchWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockBypasserExecuteBatchWithArgs'
type McmsEncoder_McmsTimelockBypasserExecuteBatchWithArgs_Call struct {
	*mock.Call
}

// McmsTimelockBypasserExecuteBatchWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) McmsTimelockBypasserExecuteBatchWithArgs(args ...interface{}) *McmsEncoder_McmsTimelockBypasserExecuteBatchWithArgs_Call {
	return &McmsEncoder_McmsTimelockBypasserExecuteBatchWithArgs_Call{Call: _e.mock.On("McmsTimelockBypasserExecuteBatchWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_McmsTimelockBypasserExecuteBatchWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_McmsTimelockBypasserExecuteBatchWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_McmsTimelockBypasserExecuteBatchWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsTimelockBypasserExecuteBatchWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsTimelockBypasserExecuteBatchWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_McmsTimelockBypasserExecuteBatchWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockCancel provides a mock function with given fields: timelock, registry, executingCallbackParams
func (_m *McmsEncoder) McmsTimelockCancel(timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockCancel")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(timelock, registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) *bind.EncodedCall); ok {
		r0 = rf(timelock, registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(timelock, registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsTimelockCancel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockCancel'
type McmsEncoder_McmsTimelockCancel_Call struct {
	*mock.Call
}

// McmsTimelockCancel is a helper method to define mock.On call
//   - timelock bind.Object
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *McmsEncoder_Expecter) McmsTimelockCancel(timelock interface{}, registry interface{}, executingCallbackParams interface{}) *McmsEncoder_McmsTimelockCancel_Call {
	return &McmsEncoder_McmsTimelockCancel_Call{Call: _e.mock.On("McmsTimelockCancel", timelock, registry, executingCallbackParams)}
}

func (_c *McmsEncoder_McmsTimelockCancel_Call) Run(run func(timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object)) *McmsEncoder_McmsTimelockCancel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(bind.Object))
	})
	return _c
}

func (_c *McmsEncoder_McmsTimelockCancel_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsTimelockCancel_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsTimelockCancel_Call) RunAndReturn(run func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)) *McmsEncoder_McmsTimelockCancel_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockCancelWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) McmsTimelockCancelWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockCancelWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsTimelockCancelWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockCancelWithArgs'
type McmsEncoder_McmsTimelockCancelWithArgs_Call struct {
	*mock.Call
}

// McmsTimelockCancelWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) McmsTimelockCancelWithArgs(args ...interface{}) *McmsEncoder_McmsTimelockCancelWithArgs_Call {
	return &McmsEncoder_McmsTimelockCancelWithArgs_Call{Call: _e.mock.On("McmsTimelockCancelWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_McmsTimelockCancelWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_McmsTimelockCancelWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_McmsTimelockCancelWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsTimelockCancelWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsTimelockCancelWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_McmsTimelockCancelWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockExecuteBatch provides a mock function with given fields: timelock, clock, registry, executingCallbackParams
func (_m *McmsEncoder) McmsTimelockExecuteBatch(timelock bind.Object, clock bind.Object, registry bind.Object, executingCallbackParams bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, clock, registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockExecuteBatch")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(timelock, clock, registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object, bind.Object) *bind.EncodedCall); ok {
		r0 = rf(timelock, clock, registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(timelock, clock, registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsTimelockExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockExecuteBatch'
type McmsEncoder_McmsTimelockExecuteBatch_Call struct {
	*mock.Call
}

// McmsTimelockExecuteBatch is a helper method to define mock.On call
//   - timelock bind.Object
//   - clock bind.Object
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *McmsEncoder_Expecter) McmsTimelockExecuteBatch(timelock interface{}, clock interface{}, registry interface{}, executingCallbackParams interface{}) *McmsEncoder_McmsTimelockExecuteBatch_Call {
	return &McmsEncoder_McmsTimelockExecuteBatch_Call{Call: _e.mock.On("McmsTimelockExecuteBatch", timelock, clock, registry, executingCallbackParams)}
}

func (_c *McmsEncoder_McmsTimelockExecuteBatch_Call) Run(run func(timelock bind.Object, clock bind.Object, registry bind.Object, executingCallbackParams bind.Object)) *McmsEncoder_McmsTimelockExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(bind.Object), args[3].(bind.Object))
	})
	return _c
}

func (_c *McmsEncoder_McmsTimelockExecuteBatch_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsTimelockExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsTimelockExecuteBatch_Call) RunAndReturn(run func(bind.Object, bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)) *McmsEncoder_McmsTimelockExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockExecuteBatchWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) McmsTimelockExecuteBatchWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockExecuteBatchWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsTimelockExecuteBatchWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockExecuteBatchWithArgs'
type McmsEncoder_McmsTimelockExecuteBatchWithArgs_Call struct {
	*mock.Call
}

// McmsTimelockExecuteBatchWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) McmsTimelockExecuteBatchWithArgs(args ...interface{}) *McmsEncoder_McmsTimelockExecuteBatchWithArgs_Call {
	return &McmsEncoder_McmsTimelockExecuteBatchWithArgs_Call{Call: _e.mock.On("McmsTimelockExecuteBatchWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_McmsTimelockExecuteBatchWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_McmsTimelockExecuteBatchWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_McmsTimelockExecuteBatchWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsTimelockExecuteBatchWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsTimelockExecuteBatchWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_McmsTimelockExecuteBatchWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockScheduleBatch provides a mock function with given fields: timelock, clock, registry, executingCallbackParams
func (_m *McmsEncoder) McmsTimelockScheduleBatch(timelock bind.Object, clock bind.Object, registry bind.Object, executingCallbackParams bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, clock, registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockScheduleBatch")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(timelock, clock, registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object, bind.Object) *bind.EncodedCall); ok {
		r0 = rf(timelock, clock, registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(timelock, clock, registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsTimelockScheduleBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockScheduleBatch'
type McmsEncoder_McmsTimelockScheduleBatch_Call struct {
	*mock.Call
}

// McmsTimelockScheduleBatch is a helper method to define mock.On call
//   - timelock bind.Object
//   - clock bind.Object
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *McmsEncoder_Expecter) McmsTimelockScheduleBatch(timelock interface{}, clock interface{}, registry interface{}, executingCallbackParams interface{}) *McmsEncoder_McmsTimelockScheduleBatch_Call {
	return &McmsEncoder_McmsTimelockScheduleBatch_Call{Call: _e.mock.On("McmsTimelockScheduleBatch", timelock, clock, registry, executingCallbackParams)}
}

func (_c *McmsEncoder_McmsTimelockScheduleBatch_Call) Run(run func(timelock bind.Object, clock bind.Object, registry bind.Object, executingCallbackParams bind.Object)) *McmsEncoder_McmsTimelockScheduleBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(bind.Object), args[3].(bind.Object))
	})
	return _c
}

func (_c *McmsEncoder_McmsTimelockScheduleBatch_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsTimelockScheduleBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsTimelockScheduleBatch_Call) RunAndReturn(run func(bind.Object, bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)) *McmsEncoder_McmsTimelockScheduleBatch_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockScheduleBatchWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) McmsTimelockScheduleBatchWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockScheduleBatchWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsTimelockScheduleBatchWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockScheduleBatchWithArgs'
type McmsEncoder_McmsTimelockScheduleBatchWithArgs_Call struct {
	*mock.Call
}

// McmsTimelockScheduleBatchWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) McmsTimelockScheduleBatchWithArgs(args ...interface{}) *McmsEncoder_McmsTimelockScheduleBatchWithArgs_Call {
	return &McmsEncoder_McmsTimelockScheduleBatchWithArgs_Call{Call: _e.mock.On("McmsTimelockScheduleBatchWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_McmsTimelockScheduleBatchWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_McmsTimelockScheduleBatchWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_McmsTimelockScheduleBatchWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsTimelockScheduleBatchWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsTimelockScheduleBatchWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_McmsTimelockScheduleBatchWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockUnblockFunction provides a mock function with given fields: timelock, registry, executingCallbackParams
func (_m *McmsEncoder) McmsTimelockUnblockFunction(timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockUnblockFunction")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(timelock, registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) *bind.EncodedCall); ok {
		r0 = rf(timelock, registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(timelock, registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsTimelockUnblockFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockUnblockFunction'
type McmsEncoder_McmsTimelockUnblockFunction_Call struct {
	*mock.Call
}

// McmsTimelockUnblockFunction is a helper method to define mock.On call
//   - timelock bind.Object
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *McmsEncoder_Expecter) McmsTimelockUnblockFunction(timelock interface{}, registry interface{}, executingCallbackParams interface{}) *McmsEncoder_McmsTimelockUnblockFunction_Call {
	return &McmsEncoder_McmsTimelockUnblockFunction_Call{Call: _e.mock.On("McmsTimelockUnblockFunction", timelock, registry, executingCallbackParams)}
}

func (_c *McmsEncoder_McmsTimelockUnblockFunction_Call) Run(run func(timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object)) *McmsEncoder_McmsTimelockUnblockFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(bind.Object))
	})
	return _c
}

func (_c *McmsEncoder_McmsTimelockUnblockFunction_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsTimelockUnblockFunction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsTimelockUnblockFunction_Call) RunAndReturn(run func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)) *McmsEncoder_McmsTimelockUnblockFunction_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockUnblockFunctionWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) McmsTimelockUnblockFunctionWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockUnblockFunctionWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsTimelockUnblockFunctionWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockUnblockFunctionWithArgs'
type McmsEncoder_McmsTimelockUnblockFunctionWithArgs_Call struct {
	*mock.Call
}

// McmsTimelockUnblockFunctionWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) McmsTimelockUnblockFunctionWithArgs(args ...interface{}) *McmsEncoder_McmsTimelockUnblockFunctionWithArgs_Call {
	return &McmsEncoder_McmsTimelockUnblockFunctionWithArgs_Call{Call: _e.mock.On("McmsTimelockUnblockFunctionWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_McmsTimelockUnblockFunctionWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_McmsTimelockUnblockFunctionWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_McmsTimelockUnblockFunctionWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsTimelockUnblockFunctionWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsTimelockUnblockFunctionWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_McmsTimelockUnblockFunctionWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockUpdateMinDelay provides a mock function with given fields: timelock, registry, executingCallbackParams
func (_m *McmsEncoder) McmsTimelockUpdateMinDelay(timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, registry, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockUpdateMinDelay")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(timelock, registry, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object) *bind.EncodedCall); ok {
		r0 = rf(timelock, registry, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(timelock, registry, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsTimelockUpdateMinDelay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockUpdateMinDelay'
type McmsEncoder_McmsTimelockUpdateMinDelay_Call struct {
	*mock.Call
}

// McmsTimelockUpdateMinDelay is a helper method to define mock.On call
//   - timelock bind.Object
//   - registry bind.Object
//   - executingCallbackParams bind.Object
func (_e *McmsEncoder_Expecter) McmsTimelockUpdateMinDelay(timelock interface{}, registry interface{}, executingCallbackParams interface{}) *McmsEncoder_McmsTimelockUpdateMinDelay_Call {
	return &McmsEncoder_McmsTimelockUpdateMinDelay_Call{Call: _e.mock.On("McmsTimelockUpdateMinDelay", timelock, registry, executingCallbackParams)}
}

func (_c *McmsEncoder_McmsTimelockUpdateMinDelay_Call) Run(run func(timelock bind.Object, registry bind.Object, executingCallbackParams bind.Object)) *McmsEncoder_McmsTimelockUpdateMinDelay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(bind.Object))
	})
	return _c
}

func (_c *McmsEncoder_McmsTimelockUpdateMinDelay_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsTimelockUpdateMinDelay_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsTimelockUpdateMinDelay_Call) RunAndReturn(run func(bind.Object, bind.Object, bind.Object) (*bind.EncodedCall, error)) *McmsEncoder_McmsTimelockUpdateMinDelay_Call {
	_c.Call.Return(run)
	return _c
}

// McmsTimelockUpdateMinDelayWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) McmsTimelockUpdateMinDelayWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for McmsTimelockUpdateMinDelayWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_McmsTimelockUpdateMinDelayWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'McmsTimelockUpdateMinDelayWithArgs'
type McmsEncoder_McmsTimelockUpdateMinDelayWithArgs_Call struct {
	*mock.Call
}

// McmsTimelockUpdateMinDelayWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) McmsTimelockUpdateMinDelayWithArgs(args ...interface{}) *McmsEncoder_McmsTimelockUpdateMinDelayWithArgs_Call {
	return &McmsEncoder_McmsTimelockUpdateMinDelayWithArgs_Call{Call: _e.mock.On("McmsTimelockUpdateMinDelayWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_McmsTimelockUpdateMinDelayWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_McmsTimelockUpdateMinDelayWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_McmsTimelockUpdateMinDelayWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_McmsTimelockUpdateMinDelayWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_McmsTimelockUpdateMinDelayWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_McmsTimelockUpdateMinDelayWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ModuleName provides a mock function with given fields: function
func (_m *McmsEncoder) ModuleName(function module_mcms.Function) (*bind.EncodedCall, error) {
	ret := _m.Called(function)

	if len(ret) == 0 {
		panic("no return value specified for ModuleName")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.Function) (*bind.EncodedCall, error)); ok {
		return rf(function)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.Function) *bind.EncodedCall); ok {
		r0 = rf(function)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.Function) error); ok {
		r1 = rf(function)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ModuleName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModuleName'
type McmsEncoder_ModuleName_Call struct {
	*mock.Call
}

// ModuleName is a helper method to define mock.On call
//   - function module_mcms.Function
func (_e *McmsEncoder_Expecter) ModuleName(function interface{}) *McmsEncoder_ModuleName_Call {
	return &McmsEncoder_ModuleName_Call{Call: _e.mock.On("ModuleName", function)}
}

func (_c *McmsEncoder_ModuleName_Call) Run(run func(function module_mcms.Function)) *McmsEncoder_ModuleName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.Function))
	})
	return _c
}

func (_c *McmsEncoder_ModuleName_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ModuleName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ModuleName_Call) RunAndReturn(run func(module_mcms.Function) (*bind.EncodedCall, error)) *McmsEncoder_ModuleName_Call {
	_c.Call.Return(run)
	return _c
}

// ModuleNameWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) ModuleNameWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModuleNameWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ModuleNameWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModuleNameWithArgs'
type McmsEncoder_ModuleNameWithArgs_Call struct {
	*mock.Call
}

// ModuleNameWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) ModuleNameWithArgs(args ...interface{}) *McmsEncoder_ModuleNameWithArgs_Call {
	return &McmsEncoder_ModuleNameWithArgs_Call{Call: _e.mock.On("ModuleNameWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_ModuleNameWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_ModuleNameWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_ModuleNameWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ModuleNameWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ModuleNameWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_ModuleNameWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// NumGroups provides a mock function with no fields
func (_m *McmsEncoder) NumGroups() (*bind.EncodedCall, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for NumGroups")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func() (*bind.EncodedCall, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *bind.EncodedCall); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_NumGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NumGroups'
type McmsEncoder_NumGroups_Call struct {
	*mock.Call
}

// NumGroups is a helper method to define mock.On call
func (_e *McmsEncoder_Expecter) NumGroups() *McmsEncoder_NumGroups_Call {
	return &McmsEncoder_NumGroups_Call{Call: _e.mock.On("NumGroups")}
}

func (_c *McmsEncoder_NumGroups_Call) Run(run func()) *McmsEncoder_NumGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *McmsEncoder_NumGroups_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_NumGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_NumGroups_Call) RunAndReturn(run func() (*bind.EncodedCall, error)) *McmsEncoder_NumGroups_Call {
	_c.Call.Return(run)
	return _c
}

// NumGroupsWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) NumGroupsWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NumGroupsWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_NumGroupsWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NumGroupsWithArgs'
type McmsEncoder_NumGroupsWithArgs_Call struct {
	*mock.Call
}

// NumGroupsWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) NumGroupsWithArgs(args ...interface{}) *McmsEncoder_NumGroupsWithArgs_Call {
	return &McmsEncoder_NumGroupsWithArgs_Call{Call: _e.mock.On("NumGroupsWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_NumGroupsWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_NumGroupsWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_NumGroupsWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_NumGroupsWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_NumGroupsWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_NumGroupsWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// OverridePreviousRoot provides a mock function with given fields: rootMetadata
func (_m *McmsEncoder) OverridePreviousRoot(rootMetadata module_mcms.RootMetadata) (*bind.EncodedCall, error) {
	ret := _m.Called(rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for OverridePreviousRoot")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) (*bind.EncodedCall, error)); ok {
		return rf(rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) *bind.EncodedCall); ok {
		r0 = rf(rootMetadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.RootMetadata) error); ok {
		r1 = rf(rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_OverridePreviousRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OverridePreviousRoot'
type McmsEncoder_OverridePreviousRoot_Call struct {
	*mock.Call
}

// OverridePreviousRoot is a helper method to define mock.On call
//   - rootMetadata module_mcms.RootMetadata
func (_e *McmsEncoder_Expecter) OverridePreviousRoot(rootMetadata interface{}) *McmsEncoder_OverridePreviousRoot_Call {
	return &McmsEncoder_OverridePreviousRoot_Call{Call: _e.mock.On("OverridePreviousRoot", rootMetadata)}
}

func (_c *McmsEncoder_OverridePreviousRoot_Call) Run(run func(rootMetadata module_mcms.RootMetadata)) *McmsEncoder_OverridePreviousRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *McmsEncoder_OverridePreviousRoot_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_OverridePreviousRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_OverridePreviousRoot_Call) RunAndReturn(run func(module_mcms.RootMetadata) (*bind.EncodedCall, error)) *McmsEncoder_OverridePreviousRoot_Call {
	_c.Call.Return(run)
	return _c
}

// OverridePreviousRootWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) OverridePreviousRootWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for OverridePreviousRootWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_OverridePreviousRootWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OverridePreviousRootWithArgs'
type McmsEncoder_OverridePreviousRootWithArgs_Call struct {
	*mock.Call
}

// OverridePreviousRootWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) OverridePreviousRootWithArgs(args ...interface{}) *McmsEncoder_OverridePreviousRootWithArgs_Call {
	return &McmsEncoder_OverridePreviousRootWithArgs_Call{Call: _e.mock.On("OverridePreviousRootWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_OverridePreviousRootWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_OverridePreviousRootWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_OverridePreviousRootWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_OverridePreviousRootWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_OverridePreviousRootWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_OverridePreviousRootWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// PostOpCount provides a mock function with given fields: rootMetadata
func (_m *McmsEncoder) PostOpCount(rootMetadata module_mcms.RootMetadata) (*bind.EncodedCall, error) {
	ret := _m.Called(rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for PostOpCount")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) (*bind.EncodedCall, error)); ok {
		return rf(rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) *bind.EncodedCall); ok {
		r0 = rf(rootMetadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.RootMetadata) error); ok {
		r1 = rf(rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_PostOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PostOpCount'
type McmsEncoder_PostOpCount_Call struct {
	*mock.Call
}

// PostOpCount is a helper method to define mock.On call
//   - rootMetadata module_mcms.RootMetadata
func (_e *McmsEncoder_Expecter) PostOpCount(rootMetadata interface{}) *McmsEncoder_PostOpCount_Call {
	return &McmsEncoder_PostOpCount_Call{Call: _e.mock.On("PostOpCount", rootMetadata)}
}

func (_c *McmsEncoder_PostOpCount_Call) Run(run func(rootMetadata module_mcms.RootMetadata)) *McmsEncoder_PostOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *McmsEncoder_PostOpCount_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_PostOpCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_PostOpCount_Call) RunAndReturn(run func(module_mcms.RootMetadata) (*bind.EncodedCall, error)) *McmsEncoder_PostOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// PostOpCountWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) PostOpCountWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PostOpCountWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_PostOpCountWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PostOpCountWithArgs'
type McmsEncoder_PostOpCountWithArgs_Call struct {
	*mock.Call
}

// PostOpCountWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) PostOpCountWithArgs(args ...interface{}) *McmsEncoder_PostOpCountWithArgs_Call {
	return &McmsEncoder_PostOpCountWithArgs_Call{Call: _e.mock.On("PostOpCountWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_PostOpCountWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_PostOpCountWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_PostOpCountWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_PostOpCountWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_PostOpCountWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_PostOpCountWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// PreOpCount provides a mock function with given fields: rootMetadata
func (_m *McmsEncoder) PreOpCount(rootMetadata module_mcms.RootMetadata) (*bind.EncodedCall, error) {
	ret := _m.Called(rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for PreOpCount")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) (*bind.EncodedCall, error)); ok {
		return rf(rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) *bind.EncodedCall); ok {
		r0 = rf(rootMetadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.RootMetadata) error); ok {
		r1 = rf(rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_PreOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PreOpCount'
type McmsEncoder_PreOpCount_Call struct {
	*mock.Call
}

// PreOpCount is a helper method to define mock.On call
//   - rootMetadata module_mcms.RootMetadata
func (_e *McmsEncoder_Expecter) PreOpCount(rootMetadata interface{}) *McmsEncoder_PreOpCount_Call {
	return &McmsEncoder_PreOpCount_Call{Call: _e.mock.On("PreOpCount", rootMetadata)}
}

func (_c *McmsEncoder_PreOpCount_Call) Run(run func(rootMetadata module_mcms.RootMetadata)) *McmsEncoder_PreOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *McmsEncoder_PreOpCount_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_PreOpCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_PreOpCount_Call) RunAndReturn(run func(module_mcms.RootMetadata) (*bind.EncodedCall, error)) *McmsEncoder_PreOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// PreOpCountWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) PreOpCountWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PreOpCountWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_PreOpCountWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PreOpCountWithArgs'
type McmsEncoder_PreOpCountWithArgs_Call struct {
	*mock.Call
}

// PreOpCountWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) PreOpCountWithArgs(args ...interface{}) *McmsEncoder_PreOpCountWithArgs_Call {
	return &McmsEncoder_PreOpCountWithArgs_Call{Call: _e.mock.On("PreOpCountWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_PreOpCountWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_PreOpCountWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_PreOpCountWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_PreOpCountWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_PreOpCountWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_PreOpCountWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ProposerRole provides a mock function with no fields
func (_m *McmsEncoder) ProposerRole() (*bind.EncodedCall, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ProposerRole")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func() (*bind.EncodedCall, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *bind.EncodedCall); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ProposerRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProposerRole'
type McmsEncoder_ProposerRole_Call struct {
	*mock.Call
}

// ProposerRole is a helper method to define mock.On call
func (_e *McmsEncoder_Expecter) ProposerRole() *McmsEncoder_ProposerRole_Call {
	return &McmsEncoder_ProposerRole_Call{Call: _e.mock.On("ProposerRole")}
}

func (_c *McmsEncoder_ProposerRole_Call) Run(run func()) *McmsEncoder_ProposerRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *McmsEncoder_ProposerRole_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ProposerRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ProposerRole_Call) RunAndReturn(run func() (*bind.EncodedCall, error)) *McmsEncoder_ProposerRole_Call {
	_c.Call.Return(run)
	return _c
}

// ProposerRoleWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) ProposerRoleWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ProposerRoleWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ProposerRoleWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProposerRoleWithArgs'
type McmsEncoder_ProposerRoleWithArgs_Call struct {
	*mock.Call
}

// ProposerRoleWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) ProposerRoleWithArgs(args ...interface{}) *McmsEncoder_ProposerRoleWithArgs_Call {
	return &McmsEncoder_ProposerRoleWithArgs_Call{Call: _e.mock.On("ProposerRoleWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_ProposerRoleWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_ProposerRoleWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_ProposerRoleWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ProposerRoleWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ProposerRoleWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_ProposerRoleWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// Role provides a mock function with given fields: rootMetadata
func (_m *McmsEncoder) Role(rootMetadata module_mcms.RootMetadata) (*bind.EncodedCall, error) {
	ret := _m.Called(rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for Role")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) (*bind.EncodedCall, error)); ok {
		return rf(rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) *bind.EncodedCall); ok {
		r0 = rf(rootMetadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.RootMetadata) error); ok {
		r1 = rf(rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_Role_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Role'
type McmsEncoder_Role_Call struct {
	*mock.Call
}

// Role is a helper method to define mock.On call
//   - rootMetadata module_mcms.RootMetadata
func (_e *McmsEncoder_Expecter) Role(rootMetadata interface{}) *McmsEncoder_Role_Call {
	return &McmsEncoder_Role_Call{Call: _e.mock.On("Role", rootMetadata)}
}

func (_c *McmsEncoder_Role_Call) Run(run func(rootMetadata module_mcms.RootMetadata)) *McmsEncoder_Role_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *McmsEncoder_Role_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_Role_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_Role_Call) RunAndReturn(run func(module_mcms.RootMetadata) (*bind.EncodedCall, error)) *McmsEncoder_Role_Call {
	_c.Call.Return(run)
	return _c
}

// RoleWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) RoleWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RoleWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_RoleWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RoleWithArgs'
type McmsEncoder_RoleWithArgs_Call struct {
	*mock.Call
}

// RoleWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) RoleWithArgs(args ...interface{}) *McmsEncoder_RoleWithArgs_Call {
	return &McmsEncoder_RoleWithArgs_Call{Call: _e.mock.On("RoleWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_RoleWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_RoleWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_RoleWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_RoleWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_RoleWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_RoleWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// RootMetadata provides a mock function with given fields: multisig
func (_m *McmsEncoder) RootMetadata(multisig module_mcms.Multisig) (*bind.EncodedCall, error) {
	ret := _m.Called(multisig)

	if len(ret) == 0 {
		panic("no return value specified for RootMetadata")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.Multisig) (*bind.EncodedCall, error)); ok {
		return rf(multisig)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.Multisig) *bind.EncodedCall); ok {
		r0 = rf(multisig)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.Multisig) error); ok {
		r1 = rf(multisig)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_RootMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RootMetadata'
type McmsEncoder_RootMetadata_Call struct {
	*mock.Call
}

// RootMetadata is a helper method to define mock.On call
//   - multisig module_mcms.Multisig
func (_e *McmsEncoder_Expecter) RootMetadata(multisig interface{}) *McmsEncoder_RootMetadata_Call {
	return &McmsEncoder_RootMetadata_Call{Call: _e.mock.On("RootMetadata", multisig)}
}

func (_c *McmsEncoder_RootMetadata_Call) Run(run func(multisig module_mcms.Multisig)) *McmsEncoder_RootMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.Multisig))
	})
	return _c
}

func (_c *McmsEncoder_RootMetadata_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_RootMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_RootMetadata_Call) RunAndReturn(run func(module_mcms.Multisig) (*bind.EncodedCall, error)) *McmsEncoder_RootMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// RootMetadataMultisig provides a mock function with given fields: rootMetadata
func (_m *McmsEncoder) RootMetadataMultisig(rootMetadata module_mcms.RootMetadata) (*bind.EncodedCall, error) {
	ret := _m.Called(rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for RootMetadataMultisig")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) (*bind.EncodedCall, error)); ok {
		return rf(rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.RootMetadata) *bind.EncodedCall); ok {
		r0 = rf(rootMetadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.RootMetadata) error); ok {
		r1 = rf(rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_RootMetadataMultisig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RootMetadataMultisig'
type McmsEncoder_RootMetadataMultisig_Call struct {
	*mock.Call
}

// RootMetadataMultisig is a helper method to define mock.On call
//   - rootMetadata module_mcms.RootMetadata
func (_e *McmsEncoder_Expecter) RootMetadataMultisig(rootMetadata interface{}) *McmsEncoder_RootMetadataMultisig_Call {
	return &McmsEncoder_RootMetadataMultisig_Call{Call: _e.mock.On("RootMetadataMultisig", rootMetadata)}
}

func (_c *McmsEncoder_RootMetadataMultisig_Call) Run(run func(rootMetadata module_mcms.RootMetadata)) *McmsEncoder_RootMetadataMultisig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *McmsEncoder_RootMetadataMultisig_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_RootMetadataMultisig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_RootMetadataMultisig_Call) RunAndReturn(run func(module_mcms.RootMetadata) (*bind.EncodedCall, error)) *McmsEncoder_RootMetadataMultisig_Call {
	_c.Call.Return(run)
	return _c
}

// RootMetadataMultisigWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) RootMetadataMultisigWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RootMetadataMultisigWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_RootMetadataMultisigWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RootMetadataMultisigWithArgs'
type McmsEncoder_RootMetadataMultisigWithArgs_Call struct {
	*mock.Call
}

// RootMetadataMultisigWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) RootMetadataMultisigWithArgs(args ...interface{}) *McmsEncoder_RootMetadataMultisigWithArgs_Call {
	return &McmsEncoder_RootMetadataMultisigWithArgs_Call{Call: _e.mock.On("RootMetadataMultisigWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_RootMetadataMultisigWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_RootMetadataMultisigWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_RootMetadataMultisigWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_RootMetadataMultisigWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_RootMetadataMultisigWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_RootMetadataMultisigWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// RootMetadataWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) RootMetadataWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RootMetadataWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_RootMetadataWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RootMetadataWithArgs'
type McmsEncoder_RootMetadataWithArgs_Call struct {
	*mock.Call
}

// RootMetadataWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) RootMetadataWithArgs(args ...interface{}) *McmsEncoder_RootMetadataWithArgs_Call {
	return &McmsEncoder_RootMetadataWithArgs_Call{Call: _e.mock.On("RootMetadataWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_RootMetadataWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_RootMetadataWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_RootMetadataWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_RootMetadataWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_RootMetadataWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_RootMetadataWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// SeenSignedHashes provides a mock function with given fields: state, role
func (_m *McmsEncoder) SeenSignedHashes(state bind.Object, role byte) (*bind.EncodedCall, error) {
	ret := _m.Called(state, role)

	if len(ret) == 0 {
		panic("no return value specified for SeenSignedHashes")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, byte) (*bind.EncodedCall, error)); ok {
		return rf(state, role)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, byte) *bind.EncodedCall); ok {
		r0 = rf(state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, byte) error); ok {
		r1 = rf(state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_SeenSignedHashes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SeenSignedHashes'
type McmsEncoder_SeenSignedHashes_Call struct {
	*mock.Call
}

// SeenSignedHashes is a helper method to define mock.On call
//   - state bind.Object
//   - role byte
func (_e *McmsEncoder_Expecter) SeenSignedHashes(state interface{}, role interface{}) *McmsEncoder_SeenSignedHashes_Call {
	return &McmsEncoder_SeenSignedHashes_Call{Call: _e.mock.On("SeenSignedHashes", state, role)}
}

func (_c *McmsEncoder_SeenSignedHashes_Call) Run(run func(state bind.Object, role byte)) *McmsEncoder_SeenSignedHashes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(byte))
	})
	return _c
}

func (_c *McmsEncoder_SeenSignedHashes_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_SeenSignedHashes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_SeenSignedHashes_Call) RunAndReturn(run func(bind.Object, byte) (*bind.EncodedCall, error)) *McmsEncoder_SeenSignedHashes_Call {
	_c.Call.Return(run)
	return _c
}

// SeenSignedHashesWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) SeenSignedHashesWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SeenSignedHashesWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_SeenSignedHashesWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SeenSignedHashesWithArgs'
type McmsEncoder_SeenSignedHashesWithArgs_Call struct {
	*mock.Call
}

// SeenSignedHashesWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) SeenSignedHashesWithArgs(args ...interface{}) *McmsEncoder_SeenSignedHashesWithArgs_Call {
	return &McmsEncoder_SeenSignedHashesWithArgs_Call{Call: _e.mock.On("SeenSignedHashesWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_SeenSignedHashesWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_SeenSignedHashesWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_SeenSignedHashesWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_SeenSignedHashesWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_SeenSignedHashesWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_SeenSignedHashesWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// SetConfig provides a mock function with given fields: param, state, role, chainId, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot
func (_m *McmsEncoder) SetConfig(param bind.Object, state bind.Object, role byte, chainId *big.Int, signerAddresses [][]byte, signerGroups []byte, groupQuorums []byte, groupParents []byte, clearRoot bool) (*bind.EncodedCall, error) {
	ret := _m.Called(param, state, role, chainId, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)

	if len(ret) == 0 {
		panic("no return value specified for SetConfig")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, byte, *big.Int, [][]byte, []byte, []byte, []byte, bool) (*bind.EncodedCall, error)); ok {
		return rf(param, state, role, chainId, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, byte, *big.Int, [][]byte, []byte, []byte, []byte, bool) *bind.EncodedCall); ok {
		r0 = rf(param, state, role, chainId, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, byte, *big.Int, [][]byte, []byte, []byte, []byte, bool) error); ok {
		r1 = rf(param, state, role, chainId, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_SetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetConfig'
type McmsEncoder_SetConfig_Call struct {
	*mock.Call
}

// SetConfig is a helper method to define mock.On call
//   - param bind.Object
//   - state bind.Object
//   - role byte
//   - chainId *big.Int
//   - signerAddresses [][]byte
//   - signerGroups []byte
//   - groupQuorums []byte
//   - groupParents []byte
//   - clearRoot bool
func (_e *McmsEncoder_Expecter) SetConfig(param interface{}, state interface{}, role interface{}, chainId interface{}, signerAddresses interface{}, signerGroups interface{}, groupQuorums interface{}, groupParents interface{}, clearRoot interface{}) *McmsEncoder_SetConfig_Call {
	return &McmsEncoder_SetConfig_Call{Call: _e.mock.On("SetConfig", param, state, role, chainId, signerAddresses, signerGroups, groupQuorums, groupParents, clearRoot)}
}

func (_c *McmsEncoder_SetConfig_Call) Run(run func(param bind.Object, state bind.Object, role byte, chainId *big.Int, signerAddresses [][]byte, signerGroups []byte, groupQuorums []byte, groupParents []byte, clearRoot bool)) *McmsEncoder_SetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(byte), args[3].(*big.Int), args[4].([][]byte), args[5].([]byte), args[6].([]byte), args[7].([]byte), args[8].(bool))
	})
	return _c
}

func (_c *McmsEncoder_SetConfig_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_SetConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_SetConfig_Call) RunAndReturn(run func(bind.Object, bind.Object, byte, *big.Int, [][]byte, []byte, []byte, []byte, bool) (*bind.EncodedCall, error)) *McmsEncoder_SetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// SetConfigWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) SetConfigWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetConfigWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_SetConfigWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetConfigWithArgs'
type McmsEncoder_SetConfigWithArgs_Call struct {
	*mock.Call
}

// SetConfigWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) SetConfigWithArgs(args ...interface{}) *McmsEncoder_SetConfigWithArgs_Call {
	return &McmsEncoder_SetConfigWithArgs_Call{Call: _e.mock.On("SetConfigWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_SetConfigWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_SetConfigWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_SetConfigWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_SetConfigWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_SetConfigWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_SetConfigWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// SetRoot provides a mock function with given fields: state, clock, role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures
func (_m *McmsEncoder) SetRoot(state bind.Object, clock bind.Object, role byte, root []byte, validUntil uint64, chainId *big.Int, multisigAddr string, preOpCount uint64, postOpCount uint64, overridePreviousRoot bool, metadataProof [][]byte, signatures [][]byte) (*bind.EncodedCall, error) {
	ret := _m.Called(state, clock, role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)

	if len(ret) == 0 {
		panic("no return value specified for SetRoot")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, byte, []byte, uint64, *big.Int, string, uint64, uint64, bool, [][]byte, [][]byte) (*bind.EncodedCall, error)); ok {
		return rf(state, clock, role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, byte, []byte, uint64, *big.Int, string, uint64, uint64, bool, [][]byte, [][]byte) *bind.EncodedCall); ok {
		r0 = rf(state, clock, role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, byte, []byte, uint64, *big.Int, string, uint64, uint64, bool, [][]byte, [][]byte) error); ok {
		r1 = rf(state, clock, role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_SetRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRoot'
type McmsEncoder_SetRoot_Call struct {
	*mock.Call
}

// SetRoot is a helper method to define mock.On call
//   - state bind.Object
//   - clock bind.Object
//   - role byte
//   - root []byte
//   - validUntil uint64
//   - chainId *big.Int
//   - multisigAddr string
//   - preOpCount uint64
//   - postOpCount uint64
//   - overridePreviousRoot bool
//   - metadataProof [][]byte
//   - signatures [][]byte
func (_e *McmsEncoder_Expecter) SetRoot(state interface{}, clock interface{}, role interface{}, root interface{}, validUntil interface{}, chainId interface{}, multisigAddr interface{}, preOpCount interface{}, postOpCount interface{}, overridePreviousRoot interface{}, metadataProof interface{}, signatures interface{}) *McmsEncoder_SetRoot_Call {
	return &McmsEncoder_SetRoot_Call{Call: _e.mock.On("SetRoot", state, clock, role, root, validUntil, chainId, multisigAddr, preOpCount, postOpCount, overridePreviousRoot, metadataProof, signatures)}
}

func (_c *McmsEncoder_SetRoot_Call) Run(run func(state bind.Object, clock bind.Object, role byte, root []byte, validUntil uint64, chainId *big.Int, multisigAddr string, preOpCount uint64, postOpCount uint64, overridePreviousRoot bool, metadataProof [][]byte, signatures [][]byte)) *McmsEncoder_SetRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(byte), args[3].([]byte), args[4].(uint64), args[5].(*big.Int), args[6].(string), args[7].(uint64), args[8].(uint64), args[9].(bool), args[10].([][]byte), args[11].([][]byte))
	})
	return _c
}

func (_c *McmsEncoder_SetRoot_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_SetRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_SetRoot_Call) RunAndReturn(run func(bind.Object, bind.Object, byte, []byte, uint64, *big.Int, string, uint64, uint64, bool, [][]byte, [][]byte) (*bind.EncodedCall, error)) *McmsEncoder_SetRoot_Call {
	_c.Call.Return(run)
	return _c
}

// SetRootWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) SetRootWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetRootWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_SetRootWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRootWithArgs'
type McmsEncoder_SetRootWithArgs_Call struct {
	*mock.Call
}

// SetRootWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) SetRootWithArgs(args ...interface{}) *McmsEncoder_SetRootWithArgs_Call {
	return &McmsEncoder_SetRootWithArgs_Call{Call: _e.mock.On("SetRootWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_SetRootWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_SetRootWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_SetRootWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_SetRootWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_SetRootWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_SetRootWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// SignerView provides a mock function with given fields: signer
func (_m *McmsEncoder) SignerView(signer module_mcms.Signer) (*bind.EncodedCall, error) {
	ret := _m.Called(signer)

	if len(ret) == 0 {
		panic("no return value specified for SignerView")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.Signer) (*bind.EncodedCall, error)); ok {
		return rf(signer)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.Signer) *bind.EncodedCall); ok {
		r0 = rf(signer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.Signer) error); ok {
		r1 = rf(signer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_SignerView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignerView'
type McmsEncoder_SignerView_Call struct {
	*mock.Call
}

// SignerView is a helper method to define mock.On call
//   - signer module_mcms.Signer
func (_e *McmsEncoder_Expecter) SignerView(signer interface{}) *McmsEncoder_SignerView_Call {
	return &McmsEncoder_SignerView_Call{Call: _e.mock.On("SignerView", signer)}
}

func (_c *McmsEncoder_SignerView_Call) Run(run func(signer module_mcms.Signer)) *McmsEncoder_SignerView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.Signer))
	})
	return _c
}

func (_c *McmsEncoder_SignerView_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_SignerView_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_SignerView_Call) RunAndReturn(run func(module_mcms.Signer) (*bind.EncodedCall, error)) *McmsEncoder_SignerView_Call {
	_c.Call.Return(run)
	return _c
}

// SignerViewWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) SignerViewWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SignerViewWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_SignerViewWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignerViewWithArgs'
type McmsEncoder_SignerViewWithArgs_Call struct {
	*mock.Call
}

// SignerViewWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) SignerViewWithArgs(args ...interface{}) *McmsEncoder_SignerViewWithArgs_Call {
	return &McmsEncoder_SignerViewWithArgs_Call{Call: _e.mock.On("SignerViewWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_SignerViewWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_SignerViewWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_SignerViewWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_SignerViewWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_SignerViewWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_SignerViewWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// Signers provides a mock function with given fields: state, role
func (_m *McmsEncoder) Signers(state bind.Object, role byte) (*bind.EncodedCall, error) {
	ret := _m.Called(state, role)

	if len(ret) == 0 {
		panic("no return value specified for Signers")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, byte) (*bind.EncodedCall, error)); ok {
		return rf(state, role)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, byte) *bind.EncodedCall); ok {
		r0 = rf(state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, byte) error); ok {
		r1 = rf(state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_Signers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Signers'
type McmsEncoder_Signers_Call struct {
	*mock.Call
}

// Signers is a helper method to define mock.On call
//   - state bind.Object
//   - role byte
func (_e *McmsEncoder_Expecter) Signers(state interface{}, role interface{}) *McmsEncoder_Signers_Call {
	return &McmsEncoder_Signers_Call{Call: _e.mock.On("Signers", state, role)}
}

func (_c *McmsEncoder_Signers_Call) Run(run func(state bind.Object, role byte)) *McmsEncoder_Signers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(byte))
	})
	return _c
}

func (_c *McmsEncoder_Signers_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_Signers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_Signers_Call) RunAndReturn(run func(bind.Object, byte) (*bind.EncodedCall, error)) *McmsEncoder_Signers_Call {
	_c.Call.Return(run)
	return _c
}

// SignersWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) SignersWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SignersWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_SignersWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignersWithArgs'
type McmsEncoder_SignersWithArgs_Call struct {
	*mock.Call
}

// SignersWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) SignersWithArgs(args ...interface{}) *McmsEncoder_SignersWithArgs_Call {
	return &McmsEncoder_SignersWithArgs_Call{Call: _e.mock.On("SignersWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_SignersWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_SignersWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_SignersWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_SignersWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_SignersWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_SignersWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// Target provides a mock function with given fields: function
func (_m *McmsEncoder) Target(function module_mcms.Function) (*bind.EncodedCall, error) {
	ret := _m.Called(function)

	if len(ret) == 0 {
		panic("no return value specified for Target")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(module_mcms.Function) (*bind.EncodedCall, error)); ok {
		return rf(function)
	}
	if rf, ok := ret.Get(0).(func(module_mcms.Function) *bind.EncodedCall); ok {
		r0 = rf(function)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(module_mcms.Function) error); ok {
		r1 = rf(function)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_Target_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Target'
type McmsEncoder_Target_Call struct {
	*mock.Call
}

// Target is a helper method to define mock.On call
//   - function module_mcms.Function
func (_e *McmsEncoder_Expecter) Target(function interface{}) *McmsEncoder_Target_Call {
	return &McmsEncoder_Target_Call{Call: _e.mock.On("Target", function)}
}

func (_c *McmsEncoder_Target_Call) Run(run func(function module_mcms.Function)) *McmsEncoder_Target_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(module_mcms.Function))
	})
	return _c
}

func (_c *McmsEncoder_Target_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_Target_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_Target_Call) RunAndReturn(run func(module_mcms.Function) (*bind.EncodedCall, error)) *McmsEncoder_Target_Call {
	_c.Call.Return(run)
	return _c
}

// TargetWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) TargetWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TargetWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TargetWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TargetWithArgs'
type McmsEncoder_TargetWithArgs_Call struct {
	*mock.Call
}

// TargetWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) TargetWithArgs(args ...interface{}) *McmsEncoder_TargetWithArgs_Call {
	return &McmsEncoder_TargetWithArgs_Call{Call: _e.mock.On("TargetWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_TargetWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_TargetWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_TargetWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TargetWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TargetWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_TargetWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockExecuteBatch provides a mock function with given fields: timelock, clock, registry, targets, moduleNames, functionNames, datas, predecessor, salt
func (_m *McmsEncoder) TimelockExecuteBatch(timelock bind.Object, clock bind.Object, registry bind.Object, targets []string, moduleNames []string, functionNames []string, datas [][]byte, predecessor []byte, salt []byte) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, clock, registry, targets, moduleNames, functionNames, datas, predecessor, salt)

	if len(ret) == 0 {
		panic("no return value specified for TimelockExecuteBatch")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object, []string, []string, []string, [][]byte, []byte, []byte) (*bind.EncodedCall, error)); ok {
		return rf(timelock, clock, registry, targets, moduleNames, functionNames, datas, predecessor, salt)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, bind.Object, []string, []string, []string, [][]byte, []byte, []byte) *bind.EncodedCall); ok {
		r0 = rf(timelock, clock, registry, targets, moduleNames, functionNames, datas, predecessor, salt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, bind.Object, []string, []string, []string, [][]byte, []byte, []byte) error); ok {
		r1 = rf(timelock, clock, registry, targets, moduleNames, functionNames, datas, predecessor, salt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockExecuteBatch'
type McmsEncoder_TimelockExecuteBatch_Call struct {
	*mock.Call
}

// TimelockExecuteBatch is a helper method to define mock.On call
//   - timelock bind.Object
//   - clock bind.Object
//   - registry bind.Object
//   - targets []string
//   - moduleNames []string
//   - functionNames []string
//   - datas [][]byte
//   - predecessor []byte
//   - salt []byte
func (_e *McmsEncoder_Expecter) TimelockExecuteBatch(timelock interface{}, clock interface{}, registry interface{}, targets interface{}, moduleNames interface{}, functionNames interface{}, datas interface{}, predecessor interface{}, salt interface{}) *McmsEncoder_TimelockExecuteBatch_Call {
	return &McmsEncoder_TimelockExecuteBatch_Call{Call: _e.mock.On("TimelockExecuteBatch", timelock, clock, registry, targets, moduleNames, functionNames, datas, predecessor, salt)}
}

func (_c *McmsEncoder_TimelockExecuteBatch_Call) Run(run func(timelock bind.Object, clock bind.Object, registry bind.Object, targets []string, moduleNames []string, functionNames []string, datas [][]byte, predecessor []byte, salt []byte)) *McmsEncoder_TimelockExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].(bind.Object), args[3].([]string), args[4].([]string), args[5].([]string), args[6].([][]byte), args[7].([]byte), args[8].([]byte))
	})
	return _c
}

func (_c *McmsEncoder_TimelockExecuteBatch_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockExecuteBatch_Call) RunAndReturn(run func(bind.Object, bind.Object, bind.Object, []string, []string, []string, [][]byte, []byte, []byte) (*bind.EncodedCall, error)) *McmsEncoder_TimelockExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockExecuteBatchWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) TimelockExecuteBatchWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimelockExecuteBatchWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockExecuteBatchWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockExecuteBatchWithArgs'
type McmsEncoder_TimelockExecuteBatchWithArgs_Call struct {
	*mock.Call
}

// TimelockExecuteBatchWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) TimelockExecuteBatchWithArgs(args ...interface{}) *McmsEncoder_TimelockExecuteBatchWithArgs_Call {
	return &McmsEncoder_TimelockExecuteBatchWithArgs_Call{Call: _e.mock.On("TimelockExecuteBatchWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_TimelockExecuteBatchWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_TimelockExecuteBatchWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_TimelockExecuteBatchWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockExecuteBatchWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockExecuteBatchWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_TimelockExecuteBatchWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunction provides a mock function with given fields: timelock, index
func (_m *McmsEncoder) TimelockGetBlockedFunction(timelock bind.Object, index uint64) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, index)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunction")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, uint64) (*bind.EncodedCall, error)); ok {
		return rf(timelock, index)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, uint64) *bind.EncodedCall); ok {
		r0 = rf(timelock, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, uint64) error); ok {
		r1 = rf(timelock, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockGetBlockedFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunction'
type McmsEncoder_TimelockGetBlockedFunction_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunction is a helper method to define mock.On call
//   - timelock bind.Object
//   - index uint64
func (_e *McmsEncoder_Expecter) TimelockGetBlockedFunction(timelock interface{}, index interface{}) *McmsEncoder_TimelockGetBlockedFunction_Call {
	return &McmsEncoder_TimelockGetBlockedFunction_Call{Call: _e.mock.On("TimelockGetBlockedFunction", timelock, index)}
}

func (_c *McmsEncoder_TimelockGetBlockedFunction_Call) Run(run func(timelock bind.Object, index uint64)) *McmsEncoder_TimelockGetBlockedFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(uint64))
	})
	return _c
}

func (_c *McmsEncoder_TimelockGetBlockedFunction_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockGetBlockedFunction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockGetBlockedFunction_Call) RunAndReturn(run func(bind.Object, uint64) (*bind.EncodedCall, error)) *McmsEncoder_TimelockGetBlockedFunction_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunctionWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) TimelockGetBlockedFunctionWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunctionWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockGetBlockedFunctionWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunctionWithArgs'
type McmsEncoder_TimelockGetBlockedFunctionWithArgs_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunctionWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) TimelockGetBlockedFunctionWithArgs(args ...interface{}) *McmsEncoder_TimelockGetBlockedFunctionWithArgs_Call {
	return &McmsEncoder_TimelockGetBlockedFunctionWithArgs_Call{Call: _e.mock.On("TimelockGetBlockedFunctionWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_TimelockGetBlockedFunctionWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_TimelockGetBlockedFunctionWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_TimelockGetBlockedFunctionWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockGetBlockedFunctionWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockGetBlockedFunctionWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_TimelockGetBlockedFunctionWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunctions provides a mock function with given fields: timelock
func (_m *McmsEncoder) TimelockGetBlockedFunctions(timelock bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunctions")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(timelock)
	}
	if rf, ok := ret.Get(0).(func(bind.Object) *bind.EncodedCall); ok {
		r0 = rf(timelock)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object) error); ok {
		r1 = rf(timelock)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockGetBlockedFunctions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunctions'
type McmsEncoder_TimelockGetBlockedFunctions_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunctions is a helper method to define mock.On call
//   - timelock bind.Object
func (_e *McmsEncoder_Expecter) TimelockGetBlockedFunctions(timelock interface{}) *McmsEncoder_TimelockGetBlockedFunctions_Call {
	return &McmsEncoder_TimelockGetBlockedFunctions_Call{Call: _e.mock.On("TimelockGetBlockedFunctions", timelock)}
}

func (_c *McmsEncoder_TimelockGetBlockedFunctions_Call) Run(run func(timelock bind.Object)) *McmsEncoder_TimelockGetBlockedFunctions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object))
	})
	return _c
}

func (_c *McmsEncoder_TimelockGetBlockedFunctions_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockGetBlockedFunctions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockGetBlockedFunctions_Call) RunAndReturn(run func(bind.Object) (*bind.EncodedCall, error)) *McmsEncoder_TimelockGetBlockedFunctions_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunctionsCount provides a mock function with given fields: timelock
func (_m *McmsEncoder) TimelockGetBlockedFunctionsCount(timelock bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunctionsCount")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(timelock)
	}
	if rf, ok := ret.Get(0).(func(bind.Object) *bind.EncodedCall); ok {
		r0 = rf(timelock)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object) error); ok {
		r1 = rf(timelock)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockGetBlockedFunctionsCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunctionsCount'
type McmsEncoder_TimelockGetBlockedFunctionsCount_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunctionsCount is a helper method to define mock.On call
//   - timelock bind.Object
func (_e *McmsEncoder_Expecter) TimelockGetBlockedFunctionsCount(timelock interface{}) *McmsEncoder_TimelockGetBlockedFunctionsCount_Call {
	return &McmsEncoder_TimelockGetBlockedFunctionsCount_Call{Call: _e.mock.On("TimelockGetBlockedFunctionsCount", timelock)}
}

func (_c *McmsEncoder_TimelockGetBlockedFunctionsCount_Call) Run(run func(timelock bind.Object)) *McmsEncoder_TimelockGetBlockedFunctionsCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object))
	})
	return _c
}

func (_c *McmsEncoder_TimelockGetBlockedFunctionsCount_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockGetBlockedFunctionsCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockGetBlockedFunctionsCount_Call) RunAndReturn(run func(bind.Object) (*bind.EncodedCall, error)) *McmsEncoder_TimelockGetBlockedFunctionsCount_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunctionsCountWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) TimelockGetBlockedFunctionsCountWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunctionsCountWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockGetBlockedFunctionsCountWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunctionsCountWithArgs'
type McmsEncoder_TimelockGetBlockedFunctionsCountWithArgs_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunctionsCountWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) TimelockGetBlockedFunctionsCountWithArgs(args ...interface{}) *McmsEncoder_TimelockGetBlockedFunctionsCountWithArgs_Call {
	return &McmsEncoder_TimelockGetBlockedFunctionsCountWithArgs_Call{Call: _e.mock.On("TimelockGetBlockedFunctionsCountWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_TimelockGetBlockedFunctionsCountWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_TimelockGetBlockedFunctionsCountWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_TimelockGetBlockedFunctionsCountWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockGetBlockedFunctionsCountWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockGetBlockedFunctionsCountWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_TimelockGetBlockedFunctionsCountWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunctionsWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) TimelockGetBlockedFunctionsWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunctionsWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockGetBlockedFunctionsWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunctionsWithArgs'
type McmsEncoder_TimelockGetBlockedFunctionsWithArgs_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunctionsWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) TimelockGetBlockedFunctionsWithArgs(args ...interface{}) *McmsEncoder_TimelockGetBlockedFunctionsWithArgs_Call {
	return &McmsEncoder_TimelockGetBlockedFunctionsWithArgs_Call{Call: _e.mock.On("TimelockGetBlockedFunctionsWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_TimelockGetBlockedFunctionsWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_TimelockGetBlockedFunctionsWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_TimelockGetBlockedFunctionsWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockGetBlockedFunctionsWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockGetBlockedFunctionsWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_TimelockGetBlockedFunctionsWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetTimestamp provides a mock function with given fields: timelock, id
func (_m *McmsEncoder) TimelockGetTimestamp(timelock bind.Object, id []byte) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetTimestamp")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, []byte) (*bind.EncodedCall, error)); ok {
		return rf(timelock, id)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, []byte) *bind.EncodedCall); ok {
		r0 = rf(timelock, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, []byte) error); ok {
		r1 = rf(timelock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockGetTimestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetTimestamp'
type McmsEncoder_TimelockGetTimestamp_Call struct {
	*mock.Call
}

// TimelockGetTimestamp is a helper method to define mock.On call
//   - timelock bind.Object
//   - id []byte
func (_e *McmsEncoder_Expecter) TimelockGetTimestamp(timelock interface{}, id interface{}) *McmsEncoder_TimelockGetTimestamp_Call {
	return &McmsEncoder_TimelockGetTimestamp_Call{Call: _e.mock.On("TimelockGetTimestamp", timelock, id)}
}

func (_c *McmsEncoder_TimelockGetTimestamp_Call) Run(run func(timelock bind.Object, id []byte)) *McmsEncoder_TimelockGetTimestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].([]byte))
	})
	return _c
}

func (_c *McmsEncoder_TimelockGetTimestamp_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockGetTimestamp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockGetTimestamp_Call) RunAndReturn(run func(bind.Object, []byte) (*bind.EncodedCall, error)) *McmsEncoder_TimelockGetTimestamp_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetTimestampWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) TimelockGetTimestampWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetTimestampWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockGetTimestampWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetTimestampWithArgs'
type McmsEncoder_TimelockGetTimestampWithArgs_Call struct {
	*mock.Call
}

// TimelockGetTimestampWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) TimelockGetTimestampWithArgs(args ...interface{}) *McmsEncoder_TimelockGetTimestampWithArgs_Call {
	return &McmsEncoder_TimelockGetTimestampWithArgs_Call{Call: _e.mock.On("TimelockGetTimestampWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_TimelockGetTimestampWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_TimelockGetTimestampWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_TimelockGetTimestampWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockGetTimestampWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockGetTimestampWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_TimelockGetTimestampWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperation provides a mock function with given fields: timelock, id
func (_m *McmsEncoder) TimelockIsOperation(timelock bind.Object, id []byte) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperation")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, []byte) (*bind.EncodedCall, error)); ok {
		return rf(timelock, id)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, []byte) *bind.EncodedCall); ok {
		r0 = rf(timelock, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, []byte) error); ok {
		r1 = rf(timelock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockIsOperation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperation'
type McmsEncoder_TimelockIsOperation_Call struct {
	*mock.Call
}

// TimelockIsOperation is a helper method to define mock.On call
//   - timelock bind.Object
//   - id []byte
func (_e *McmsEncoder_Expecter) TimelockIsOperation(timelock interface{}, id interface{}) *McmsEncoder_TimelockIsOperation_Call {
	return &McmsEncoder_TimelockIsOperation_Call{Call: _e.mock.On("TimelockIsOperation", timelock, id)}
}

func (_c *McmsEncoder_TimelockIsOperation_Call) Run(run func(timelock bind.Object, id []byte)) *McmsEncoder_TimelockIsOperation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].([]byte))
	})
	return _c
}

func (_c *McmsEncoder_TimelockIsOperation_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockIsOperation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockIsOperation_Call) RunAndReturn(run func(bind.Object, []byte) (*bind.EncodedCall, error)) *McmsEncoder_TimelockIsOperation_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationDone provides a mock function with given fields: timelock, id
func (_m *McmsEncoder) TimelockIsOperationDone(timelock bind.Object, id []byte) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationDone")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, []byte) (*bind.EncodedCall, error)); ok {
		return rf(timelock, id)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, []byte) *bind.EncodedCall); ok {
		r0 = rf(timelock, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, []byte) error); ok {
		r1 = rf(timelock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockIsOperationDone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationDone'
type McmsEncoder_TimelockIsOperationDone_Call struct {
	*mock.Call
}

// TimelockIsOperationDone is a helper method to define mock.On call
//   - timelock bind.Object
//   - id []byte
func (_e *McmsEncoder_Expecter) TimelockIsOperationDone(timelock interface{}, id interface{}) *McmsEncoder_TimelockIsOperationDone_Call {
	return &McmsEncoder_TimelockIsOperationDone_Call{Call: _e.mock.On("TimelockIsOperationDone", timelock, id)}
}

func (_c *McmsEncoder_TimelockIsOperationDone_Call) Run(run func(timelock bind.Object, id []byte)) *McmsEncoder_TimelockIsOperationDone_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].([]byte))
	})
	return _c
}

func (_c *McmsEncoder_TimelockIsOperationDone_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockIsOperationDone_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockIsOperationDone_Call) RunAndReturn(run func(bind.Object, []byte) (*bind.EncodedCall, error)) *McmsEncoder_TimelockIsOperationDone_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationDoneWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) TimelockIsOperationDoneWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationDoneWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockIsOperationDoneWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationDoneWithArgs'
type McmsEncoder_TimelockIsOperationDoneWithArgs_Call struct {
	*mock.Call
}

// TimelockIsOperationDoneWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) TimelockIsOperationDoneWithArgs(args ...interface{}) *McmsEncoder_TimelockIsOperationDoneWithArgs_Call {
	return &McmsEncoder_TimelockIsOperationDoneWithArgs_Call{Call: _e.mock.On("TimelockIsOperationDoneWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_TimelockIsOperationDoneWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_TimelockIsOperationDoneWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_TimelockIsOperationDoneWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockIsOperationDoneWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockIsOperationDoneWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_TimelockIsOperationDoneWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationPending provides a mock function with given fields: timelock, id
func (_m *McmsEncoder) TimelockIsOperationPending(timelock bind.Object, id []byte) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationPending")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, []byte) (*bind.EncodedCall, error)); ok {
		return rf(timelock, id)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, []byte) *bind.EncodedCall); ok {
		r0 = rf(timelock, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, []byte) error); ok {
		r1 = rf(timelock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockIsOperationPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationPending'
type McmsEncoder_TimelockIsOperationPending_Call struct {
	*mock.Call
}

// TimelockIsOperationPending is a helper method to define mock.On call
//   - timelock bind.Object
//   - id []byte
func (_e *McmsEncoder_Expecter) TimelockIsOperationPending(timelock interface{}, id interface{}) *McmsEncoder_TimelockIsOperationPending_Call {
	return &McmsEncoder_TimelockIsOperationPending_Call{Call: _e.mock.On("TimelockIsOperationPending", timelock, id)}
}

func (_c *McmsEncoder_TimelockIsOperationPending_Call) Run(run func(timelock bind.Object, id []byte)) *McmsEncoder_TimelockIsOperationPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].([]byte))
	})
	return _c
}

func (_c *McmsEncoder_TimelockIsOperationPending_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockIsOperationPending_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockIsOperationPending_Call) RunAndReturn(run func(bind.Object, []byte) (*bind.EncodedCall, error)) *McmsEncoder_TimelockIsOperationPending_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationPendingWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) TimelockIsOperationPendingWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationPendingWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockIsOperationPendingWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationPendingWithArgs'
type McmsEncoder_TimelockIsOperationPendingWithArgs_Call struct {
	*mock.Call
}

// TimelockIsOperationPendingWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) TimelockIsOperationPendingWithArgs(args ...interface{}) *McmsEncoder_TimelockIsOperationPendingWithArgs_Call {
	return &McmsEncoder_TimelockIsOperationPendingWithArgs_Call{Call: _e.mock.On("TimelockIsOperationPendingWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_TimelockIsOperationPendingWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_TimelockIsOperationPendingWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_TimelockIsOperationPendingWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockIsOperationPendingWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockIsOperationPendingWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_TimelockIsOperationPendingWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationReady provides a mock function with given fields: timelock, clock, id
func (_m *McmsEncoder) TimelockIsOperationReady(timelock bind.Object, clock bind.Object, id []byte) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock, clock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationReady")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, []byte) (*bind.EncodedCall, error)); ok {
		return rf(timelock, clock, id)
	}
	if rf, ok := ret.Get(0).(func(bind.Object, bind.Object, []byte) *bind.EncodedCall); ok {
		r0 = rf(timelock, clock, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object, bind.Object, []byte) error); ok {
		r1 = rf(timelock, clock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockIsOperationReady_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationReady'
type McmsEncoder_TimelockIsOperationReady_Call struct {
	*mock.Call
}

// TimelockIsOperationReady is a helper method to define mock.On call
//   - timelock bind.Object
//   - clock bind.Object
//   - id []byte
func (_e *McmsEncoder_Expecter) TimelockIsOperationReady(timelock interface{}, clock interface{}, id interface{}) *McmsEncoder_TimelockIsOperationReady_Call {
	return &McmsEncoder_TimelockIsOperationReady_Call{Call: _e.mock.On("TimelockIsOperationReady", timelock, clock, id)}
}

func (_c *McmsEncoder_TimelockIsOperationReady_Call) Run(run func(timelock bind.Object, clock bind.Object, id []byte)) *McmsEncoder_TimelockIsOperationReady_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object), args[1].(bind.Object), args[2].([]byte))
	})
	return _c
}

func (_c *McmsEncoder_TimelockIsOperationReady_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockIsOperationReady_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockIsOperationReady_Call) RunAndReturn(run func(bind.Object, bind.Object, []byte) (*bind.EncodedCall, error)) *McmsEncoder_TimelockIsOperationReady_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationReadyWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) TimelockIsOperationReadyWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationReadyWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockIsOperationReadyWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationReadyWithArgs'
type McmsEncoder_TimelockIsOperationReadyWithArgs_Call struct {
	*mock.Call
}

// TimelockIsOperationReadyWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) TimelockIsOperationReadyWithArgs(args ...interface{}) *McmsEncoder_TimelockIsOperationReadyWithArgs_Call {
	return &McmsEncoder_TimelockIsOperationReadyWithArgs_Call{Call: _e.mock.On("TimelockIsOperationReadyWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_TimelockIsOperationReadyWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_TimelockIsOperationReadyWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_TimelockIsOperationReadyWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockIsOperationReadyWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockIsOperationReadyWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_TimelockIsOperationReadyWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) TimelockIsOperationWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockIsOperationWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationWithArgs'
type McmsEncoder_TimelockIsOperationWithArgs_Call struct {
	*mock.Call
}

// TimelockIsOperationWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) TimelockIsOperationWithArgs(args ...interface{}) *McmsEncoder_TimelockIsOperationWithArgs_Call {
	return &McmsEncoder_TimelockIsOperationWithArgs_Call{Call: _e.mock.On("TimelockIsOperationWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_TimelockIsOperationWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_TimelockIsOperationWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_TimelockIsOperationWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockIsOperationWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockIsOperationWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_TimelockIsOperationWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockMinDelay provides a mock function with given fields: timelock
func (_m *McmsEncoder) TimelockMinDelay(timelock bind.Object) (*bind.EncodedCall, error) {
	ret := _m.Called(timelock)

	if len(ret) == 0 {
		panic("no return value specified for TimelockMinDelay")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(bind.Object) (*bind.EncodedCall, error)); ok {
		return rf(timelock)
	}
	if rf, ok := ret.Get(0).(func(bind.Object) *bind.EncodedCall); ok {
		r0 = rf(timelock)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(bind.Object) error); ok {
		r1 = rf(timelock)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockMinDelay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockMinDelay'
type McmsEncoder_TimelockMinDelay_Call struct {
	*mock.Call
}

// TimelockMinDelay is a helper method to define mock.On call
//   - timelock bind.Object
func (_e *McmsEncoder_Expecter) TimelockMinDelay(timelock interface{}) *McmsEncoder_TimelockMinDelay_Call {
	return &McmsEncoder_TimelockMinDelay_Call{Call: _e.mock.On("TimelockMinDelay", timelock)}
}

func (_c *McmsEncoder_TimelockMinDelay_Call) Run(run func(timelock bind.Object)) *McmsEncoder_TimelockMinDelay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bind.Object))
	})
	return _c
}

func (_c *McmsEncoder_TimelockMinDelay_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockMinDelay_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockMinDelay_Call) RunAndReturn(run func(bind.Object) (*bind.EncodedCall, error)) *McmsEncoder_TimelockMinDelay_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockMinDelayWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) TimelockMinDelayWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimelockMinDelayWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockMinDelayWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockMinDelayWithArgs'
type McmsEncoder_TimelockMinDelayWithArgs_Call struct {
	*mock.Call
}

// TimelockMinDelayWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) TimelockMinDelayWithArgs(args ...interface{}) *McmsEncoder_TimelockMinDelayWithArgs_Call {
	return &McmsEncoder_TimelockMinDelayWithArgs_Call{Call: _e.mock.On("TimelockMinDelayWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_TimelockMinDelayWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_TimelockMinDelayWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_TimelockMinDelayWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockMinDelayWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockMinDelayWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_TimelockMinDelayWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockRole provides a mock function with no fields
func (_m *McmsEncoder) TimelockRole() (*bind.EncodedCall, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TimelockRole")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func() (*bind.EncodedCall, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *bind.EncodedCall); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockRole'
type McmsEncoder_TimelockRole_Call struct {
	*mock.Call
}

// TimelockRole is a helper method to define mock.On call
func (_e *McmsEncoder_Expecter) TimelockRole() *McmsEncoder_TimelockRole_Call {
	return &McmsEncoder_TimelockRole_Call{Call: _e.mock.On("TimelockRole")}
}

func (_c *McmsEncoder_TimelockRole_Call) Run(run func()) *McmsEncoder_TimelockRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *McmsEncoder_TimelockRole_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockRole_Call) RunAndReturn(run func() (*bind.EncodedCall, error)) *McmsEncoder_TimelockRole_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockRoleWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) TimelockRoleWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimelockRoleWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_TimelockRoleWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockRoleWithArgs'
type McmsEncoder_TimelockRoleWithArgs_Call struct {
	*mock.Call
}

// TimelockRoleWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) TimelockRoleWithArgs(args ...interface{}) *McmsEncoder_TimelockRoleWithArgs_Call {
	return &McmsEncoder_TimelockRoleWithArgs_Call{Call: _e.mock.On("TimelockRoleWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_TimelockRoleWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_TimelockRoleWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_TimelockRoleWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_TimelockRoleWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_TimelockRoleWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_TimelockRoleWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyMerkleProof provides a mock function with given fields: proof, root, leaf
func (_m *McmsEncoder) VerifyMerkleProof(proof [][]byte, root []byte, leaf []byte) (*bind.EncodedCall, error) {
	ret := _m.Called(proof, root, leaf)

	if len(ret) == 0 {
		panic("no return value specified for VerifyMerkleProof")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func([][]byte, []byte, []byte) (*bind.EncodedCall, error)); ok {
		return rf(proof, root, leaf)
	}
	if rf, ok := ret.Get(0).(func([][]byte, []byte, []byte) *bind.EncodedCall); ok {
		r0 = rf(proof, root, leaf)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func([][]byte, []byte, []byte) error); ok {
		r1 = rf(proof, root, leaf)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_VerifyMerkleProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyMerkleProof'
type McmsEncoder_VerifyMerkleProof_Call struct {
	*mock.Call
}

// VerifyMerkleProof is a helper method to define mock.On call
//   - proof [][]byte
//   - root []byte
//   - leaf []byte
func (_e *McmsEncoder_Expecter) VerifyMerkleProof(proof interface{}, root interface{}, leaf interface{}) *McmsEncoder_VerifyMerkleProof_Call {
	return &McmsEncoder_VerifyMerkleProof_Call{Call: _e.mock.On("VerifyMerkleProof", proof, root, leaf)}
}

func (_c *McmsEncoder_VerifyMerkleProof_Call) Run(run func(proof [][]byte, root []byte, leaf []byte)) *McmsEncoder_VerifyMerkleProof_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([][]byte), args[1].([]byte), args[2].([]byte))
	})
	return _c
}

func (_c *McmsEncoder_VerifyMerkleProof_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_VerifyMerkleProof_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_VerifyMerkleProof_Call) RunAndReturn(run func([][]byte, []byte, []byte) (*bind.EncodedCall, error)) *McmsEncoder_VerifyMerkleProof_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyMerkleProofWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) VerifyMerkleProofWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VerifyMerkleProofWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_VerifyMerkleProofWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyMerkleProofWithArgs'
type McmsEncoder_VerifyMerkleProofWithArgs_Call struct {
	*mock.Call
}

// VerifyMerkleProofWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) VerifyMerkleProofWithArgs(args ...interface{}) *McmsEncoder_VerifyMerkleProofWithArgs_Call {
	return &McmsEncoder_VerifyMerkleProofWithArgs_Call{Call: _e.mock.On("VerifyMerkleProofWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_VerifyMerkleProofWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_VerifyMerkleProofWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_VerifyMerkleProofWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_VerifyMerkleProofWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_VerifyMerkleProofWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_VerifyMerkleProofWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ZeroHash provides a mock function with no fields
func (_m *McmsEncoder) ZeroHash() (*bind.EncodedCall, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ZeroHash")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func() (*bind.EncodedCall, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *bind.EncodedCall); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ZeroHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZeroHash'
type McmsEncoder_ZeroHash_Call struct {
	*mock.Call
}

// ZeroHash is a helper method to define mock.On call
func (_e *McmsEncoder_Expecter) ZeroHash() *McmsEncoder_ZeroHash_Call {
	return &McmsEncoder_ZeroHash_Call{Call: _e.mock.On("ZeroHash")}
}

func (_c *McmsEncoder_ZeroHash_Call) Run(run func()) *McmsEncoder_ZeroHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *McmsEncoder_ZeroHash_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ZeroHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ZeroHash_Call) RunAndReturn(run func() (*bind.EncodedCall, error)) *McmsEncoder_ZeroHash_Call {
	_c.Call.Return(run)
	return _c
}

// ZeroHashWithArgs provides a mock function with given fields: args
func (_m *McmsEncoder) ZeroHashWithArgs(args ...interface{}) (*bind.EncodedCall, error) {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZeroHashWithArgs")
	}

	var r0 *bind.EncodedCall
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*bind.EncodedCall, error)); ok {
		return rf(args...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *bind.EncodedCall); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bind.EncodedCall)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// McmsEncoder_ZeroHashWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZeroHashWithArgs'
type McmsEncoder_ZeroHashWithArgs_Call struct {
	*mock.Call
}

// ZeroHashWithArgs is a helper method to define mock.On call
//   - args ...interface{}
func (_e *McmsEncoder_Expecter) ZeroHashWithArgs(args ...interface{}) *McmsEncoder_ZeroHashWithArgs_Call {
	return &McmsEncoder_ZeroHashWithArgs_Call{Call: _e.mock.On("ZeroHashWithArgs",
		append([]interface{}{}, args...)...)}
}

func (_c *McmsEncoder_ZeroHashWithArgs_Call) Run(run func(args ...interface{})) *McmsEncoder_ZeroHashWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *McmsEncoder_ZeroHashWithArgs_Call) Return(_a0 *bind.EncodedCall, _a1 error) *McmsEncoder_ZeroHashWithArgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *McmsEncoder_ZeroHashWithArgs_Call) RunAndReturn(run func(...interface{}) (*bind.EncodedCall, error)) *McmsEncoder_ZeroHashWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// NewMcmsEncoder creates a new instance of McmsEncoder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMcmsEncoder(t interface {
	mock.TestingT
	Cleanup(func())
}) *McmsEncoder {
	mock := &McmsEncoder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

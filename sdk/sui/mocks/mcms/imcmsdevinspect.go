// Code generated by mockery v2.53.4. DO NOT EDIT.

package mock_module_mcms

import (
	context "context"
	big "math/big"

	bind "github.com/smartcontractkit/chainlink-sui/bindings/bind"

	mock "github.com/stretchr/testify/mock"

	module_mcms "github.com/smartcontractkit/chainlink-sui/bindings/generated/mcms/mcms"
)

// IMcmsDevInspect is an autogenerated mock type for the IMcmsDevInspect type
type IMcmsDevInspect struct {
	mock.Mock
}

type IMcmsDevInspect_Expecter struct {
	mock *mock.Mock
}

func (_m *IMcmsDevInspect) EXPECT() *IMcmsDevInspect_Expecter {
	return &IMcmsDevInspect_Expecter{mock: &_m.Mock}
}

// BypasserRole provides a mock function with given fields: ctx, opts
func (_m *IMcmsDevInspect) BypasserRole(ctx context.Context, opts *bind.CallOpts) (byte, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for BypasserRole")
	}

	var r0 byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) (byte, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) byte); ok {
		r0 = rf(ctx, opts)
	} else {
		r0 = ret.Get(0).(byte)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_BypasserRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BypasserRole'
type IMcmsDevInspect_BypasserRole_Call struct {
	*mock.Call
}

// BypasserRole is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
func (_e *IMcmsDevInspect_Expecter) BypasserRole(ctx interface{}, opts interface{}) *IMcmsDevInspect_BypasserRole_Call {
	return &IMcmsDevInspect_BypasserRole_Call{Call: _e.mock.On("BypasserRole", ctx, opts)}
}

func (_c *IMcmsDevInspect_BypasserRole_Call) Run(run func(ctx context.Context, opts *bind.CallOpts)) *IMcmsDevInspect_BypasserRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts))
	})
	return _c
}

func (_c *IMcmsDevInspect_BypasserRole_Call) Return(_a0 byte, _a1 error) *IMcmsDevInspect_BypasserRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_BypasserRole_Call) RunAndReturn(run func(context.Context, *bind.CallOpts) (byte, error)) *IMcmsDevInspect_BypasserRole_Call {
	_c.Call.Return(run)
	return _c
}

// CancellerRole provides a mock function with given fields: ctx, opts
func (_m *IMcmsDevInspect) CancellerRole(ctx context.Context, opts *bind.CallOpts) (byte, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for CancellerRole")
	}

	var r0 byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) (byte, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) byte); ok {
		r0 = rf(ctx, opts)
	} else {
		r0 = ret.Get(0).(byte)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_CancellerRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancellerRole'
type IMcmsDevInspect_CancellerRole_Call struct {
	*mock.Call
}

// CancellerRole is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
func (_e *IMcmsDevInspect_Expecter) CancellerRole(ctx interface{}, opts interface{}) *IMcmsDevInspect_CancellerRole_Call {
	return &IMcmsDevInspect_CancellerRole_Call{Call: _e.mock.On("CancellerRole", ctx, opts)}
}

func (_c *IMcmsDevInspect_CancellerRole_Call) Run(run func(ctx context.Context, opts *bind.CallOpts)) *IMcmsDevInspect_CancellerRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts))
	})
	return _c
}

func (_c *IMcmsDevInspect_CancellerRole_Call) Return(_a0 byte, _a1 error) *IMcmsDevInspect_CancellerRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_CancellerRole_Call) RunAndReturn(run func(context.Context, *bind.CallOpts) (byte, error)) *IMcmsDevInspect_CancellerRole_Call {
	_c.Call.Return(run)
	return _c
}

// ChainId provides a mock function with given fields: ctx, opts, rootMetadata
func (_m *IMcmsDevInspect) ChainId(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata) (*big.Int, error) {
	ret := _m.Called(ctx, opts, rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for ChainId")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (*big.Int, error)); ok {
		return rf(ctx, opts, rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) *big.Int); ok {
		r0 = rf(ctx, opts, rootMetadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) error); ok {
		r1 = rf(ctx, opts, rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_ChainId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainId'
type IMcmsDevInspect_ChainId_Call struct {
	*mock.Call
}

// ChainId is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - rootMetadata module_mcms.RootMetadata
func (_e *IMcmsDevInspect_Expecter) ChainId(ctx interface{}, opts interface{}, rootMetadata interface{}) *IMcmsDevInspect_ChainId_Call {
	return &IMcmsDevInspect_ChainId_Call{Call: _e.mock.On("ChainId", ctx, opts, rootMetadata)}
}

func (_c *IMcmsDevInspect_ChainId_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata)) *IMcmsDevInspect_ChainId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *IMcmsDevInspect_ChainId_Call) Return(_a0 *big.Int, _a1 error) *IMcmsDevInspect_ChainId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_ChainId_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (*big.Int, error)) *IMcmsDevInspect_ChainId_Call {
	_c.Call.Return(run)
	return _c
}

// ComputeEthMessageHash provides a mock function with given fields: ctx, opts, root, validUntil
func (_m *IMcmsDevInspect) ComputeEthMessageHash(ctx context.Context, opts *bind.CallOpts, root []byte, validUntil uint64) ([]byte, error) {
	ret := _m.Called(ctx, opts, root, validUntil)

	if len(ret) == 0 {
		panic("no return value specified for ComputeEthMessageHash")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []byte, uint64) ([]byte, error)); ok {
		return rf(ctx, opts, root, validUntil)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []byte, uint64) []byte); ok {
		r0 = rf(ctx, opts, root, validUntil)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, []byte, uint64) error); ok {
		r1 = rf(ctx, opts, root, validUntil)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_ComputeEthMessageHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputeEthMessageHash'
type IMcmsDevInspect_ComputeEthMessageHash_Call struct {
	*mock.Call
}

// ComputeEthMessageHash is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - root []byte
//   - validUntil uint64
func (_e *IMcmsDevInspect_Expecter) ComputeEthMessageHash(ctx interface{}, opts interface{}, root interface{}, validUntil interface{}) *IMcmsDevInspect_ComputeEthMessageHash_Call {
	return &IMcmsDevInspect_ComputeEthMessageHash_Call{Call: _e.mock.On("ComputeEthMessageHash", ctx, opts, root, validUntil)}
}

func (_c *IMcmsDevInspect_ComputeEthMessageHash_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, root []byte, validUntil uint64)) *IMcmsDevInspect_ComputeEthMessageHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].([]byte), args[3].(uint64))
	})
	return _c
}

func (_c *IMcmsDevInspect_ComputeEthMessageHash_Call) Return(_a0 []byte, _a1 error) *IMcmsDevInspect_ComputeEthMessageHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_ComputeEthMessageHash_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, []byte, uint64) ([]byte, error)) *IMcmsDevInspect_ComputeEthMessageHash_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigGroupParents provides a mock function with given fields: ctx, opts, config
func (_m *IMcmsDevInspect) ConfigGroupParents(ctx context.Context, opts *bind.CallOpts, config module_mcms.Config) ([]byte, error) {
	ret := _m.Called(ctx, opts, config)

	if len(ret) == 0 {
		panic("no return value specified for ConfigGroupParents")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Config) ([]byte, error)); ok {
		return rf(ctx, opts, config)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Config) []byte); ok {
		r0 = rf(ctx, opts, config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Config) error); ok {
		r1 = rf(ctx, opts, config)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_ConfigGroupParents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigGroupParents'
type IMcmsDevInspect_ConfigGroupParents_Call struct {
	*mock.Call
}

// ConfigGroupParents is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - config module_mcms.Config
func (_e *IMcmsDevInspect_Expecter) ConfigGroupParents(ctx interface{}, opts interface{}, config interface{}) *IMcmsDevInspect_ConfigGroupParents_Call {
	return &IMcmsDevInspect_ConfigGroupParents_Call{Call: _e.mock.On("ConfigGroupParents", ctx, opts, config)}
}

func (_c *IMcmsDevInspect_ConfigGroupParents_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, config module_mcms.Config)) *IMcmsDevInspect_ConfigGroupParents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Config))
	})
	return _c
}

func (_c *IMcmsDevInspect_ConfigGroupParents_Call) Return(_a0 []byte, _a1 error) *IMcmsDevInspect_ConfigGroupParents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_ConfigGroupParents_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Config) ([]byte, error)) *IMcmsDevInspect_ConfigGroupParents_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigGroupQuorums provides a mock function with given fields: ctx, opts, config
func (_m *IMcmsDevInspect) ConfigGroupQuorums(ctx context.Context, opts *bind.CallOpts, config module_mcms.Config) ([]byte, error) {
	ret := _m.Called(ctx, opts, config)

	if len(ret) == 0 {
		panic("no return value specified for ConfigGroupQuorums")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Config) ([]byte, error)); ok {
		return rf(ctx, opts, config)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Config) []byte); ok {
		r0 = rf(ctx, opts, config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Config) error); ok {
		r1 = rf(ctx, opts, config)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_ConfigGroupQuorums_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigGroupQuorums'
type IMcmsDevInspect_ConfigGroupQuorums_Call struct {
	*mock.Call
}

// ConfigGroupQuorums is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - config module_mcms.Config
func (_e *IMcmsDevInspect_Expecter) ConfigGroupQuorums(ctx interface{}, opts interface{}, config interface{}) *IMcmsDevInspect_ConfigGroupQuorums_Call {
	return &IMcmsDevInspect_ConfigGroupQuorums_Call{Call: _e.mock.On("ConfigGroupQuorums", ctx, opts, config)}
}

func (_c *IMcmsDevInspect_ConfigGroupQuorums_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, config module_mcms.Config)) *IMcmsDevInspect_ConfigGroupQuorums_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Config))
	})
	return _c
}

func (_c *IMcmsDevInspect_ConfigGroupQuorums_Call) Return(_a0 []byte, _a1 error) *IMcmsDevInspect_ConfigGroupQuorums_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_ConfigGroupQuorums_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Config) ([]byte, error)) *IMcmsDevInspect_ConfigGroupQuorums_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigSigners provides a mock function with given fields: ctx, opts, config
func (_m *IMcmsDevInspect) ConfigSigners(ctx context.Context, opts *bind.CallOpts, config module_mcms.Config) ([]module_mcms.Signer, error) {
	ret := _m.Called(ctx, opts, config)

	if len(ret) == 0 {
		panic("no return value specified for ConfigSigners")
	}

	var r0 []module_mcms.Signer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Config) ([]module_mcms.Signer, error)); ok {
		return rf(ctx, opts, config)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Config) []module_mcms.Signer); ok {
		r0 = rf(ctx, opts, config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]module_mcms.Signer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Config) error); ok {
		r1 = rf(ctx, opts, config)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_ConfigSigners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigSigners'
type IMcmsDevInspect_ConfigSigners_Call struct {
	*mock.Call
}

// ConfigSigners is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - config module_mcms.Config
func (_e *IMcmsDevInspect_Expecter) ConfigSigners(ctx interface{}, opts interface{}, config interface{}) *IMcmsDevInspect_ConfigSigners_Call {
	return &IMcmsDevInspect_ConfigSigners_Call{Call: _e.mock.On("ConfigSigners", ctx, opts, config)}
}

func (_c *IMcmsDevInspect_ConfigSigners_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, config module_mcms.Config)) *IMcmsDevInspect_ConfigSigners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Config))
	})
	return _c
}

func (_c *IMcmsDevInspect_ConfigSigners_Call) Return(_a0 []module_mcms.Signer, _a1 error) *IMcmsDevInspect_ConfigSigners_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_ConfigSigners_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Config) ([]module_mcms.Signer, error)) *IMcmsDevInspect_ConfigSigners_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCalls provides a mock function with given fields: ctx, opts, targets, moduleNames, functionNames, datas
func (_m *IMcmsDevInspect) CreateCalls(ctx context.Context, opts *bind.CallOpts, targets []string, moduleNames []string, functionNames []string, datas [][]byte) ([]module_mcms.Call, error) {
	ret := _m.Called(ctx, opts, targets, moduleNames, functionNames, datas)

	if len(ret) == 0 {
		panic("no return value specified for CreateCalls")
	}

	var r0 []module_mcms.Call
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []string, []string, []string, [][]byte) ([]module_mcms.Call, error)); ok {
		return rf(ctx, opts, targets, moduleNames, functionNames, datas)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []string, []string, []string, [][]byte) []module_mcms.Call); ok {
		r0 = rf(ctx, opts, targets, moduleNames, functionNames, datas)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]module_mcms.Call)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, []string, []string, []string, [][]byte) error); ok {
		r1 = rf(ctx, opts, targets, moduleNames, functionNames, datas)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_CreateCalls_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCalls'
type IMcmsDevInspect_CreateCalls_Call struct {
	*mock.Call
}

// CreateCalls is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - targets []string
//   - moduleNames []string
//   - functionNames []string
//   - datas [][]byte
func (_e *IMcmsDevInspect_Expecter) CreateCalls(ctx interface{}, opts interface{}, targets interface{}, moduleNames interface{}, functionNames interface{}, datas interface{}) *IMcmsDevInspect_CreateCalls_Call {
	return &IMcmsDevInspect_CreateCalls_Call{Call: _e.mock.On("CreateCalls", ctx, opts, targets, moduleNames, functionNames, datas)}
}

func (_c *IMcmsDevInspect_CreateCalls_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, targets []string, moduleNames []string, functionNames []string, datas [][]byte)) *IMcmsDevInspect_CreateCalls_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].([]string), args[3].([]string), args[4].([]string), args[5].([][]byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_CreateCalls_Call) Return(_a0 []module_mcms.Call, _a1 error) *IMcmsDevInspect_CreateCalls_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_CreateCalls_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, []string, []string, []string, [][]byte) ([]module_mcms.Call, error)) *IMcmsDevInspect_CreateCalls_Call {
	_c.Call.Return(run)
	return _c
}

// Data provides a mock function with given fields: ctx, opts, call
func (_m *IMcmsDevInspect) Data(ctx context.Context, opts *bind.CallOpts, call module_mcms.Call) ([]byte, error) {
	ret := _m.Called(ctx, opts, call)

	if len(ret) == 0 {
		panic("no return value specified for Data")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Call) ([]byte, error)); ok {
		return rf(ctx, opts, call)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Call) []byte); ok {
		r0 = rf(ctx, opts, call)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Call) error); ok {
		r1 = rf(ctx, opts, call)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_Data_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Data'
type IMcmsDevInspect_Data_Call struct {
	*mock.Call
}

// Data is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - call module_mcms.Call
func (_e *IMcmsDevInspect_Expecter) Data(ctx interface{}, opts interface{}, call interface{}) *IMcmsDevInspect_Data_Call {
	return &IMcmsDevInspect_Data_Call{Call: _e.mock.On("Data", ctx, opts, call)}
}

func (_c *IMcmsDevInspect_Data_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, call module_mcms.Call)) *IMcmsDevInspect_Data_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Call))
	})
	return _c
}

func (_c *IMcmsDevInspect_Data_Call) Return(_a0 []byte, _a1 error) *IMcmsDevInspect_Data_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_Data_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Call) ([]byte, error)) *IMcmsDevInspect_Data_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockBypasserExecuteBatch provides a mock function with given fields: ctx, opts, timelockCallbackParams
func (_m *IMcmsDevInspect) DispatchTimelockBypasserExecuteBatch(ctx context.Context, opts *bind.CallOpts, timelockCallbackParams module_mcms.TimelockCallbackParams) ([]bind.Object, error) {
	ret := _m.Called(ctx, opts, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockBypasserExecuteBatch")
	}

	var r0 []bind.Object
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.TimelockCallbackParams) ([]bind.Object, error)); ok {
		return rf(ctx, opts, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.TimelockCallbackParams) []bind.Object); ok {
		r0 = rf(ctx, opts, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bind.Object)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(ctx, opts, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_DispatchTimelockBypasserExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockBypasserExecuteBatch'
type IMcmsDevInspect_DispatchTimelockBypasserExecuteBatch_Call struct {
	*mock.Call
}

// DispatchTimelockBypasserExecuteBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *IMcmsDevInspect_Expecter) DispatchTimelockBypasserExecuteBatch(ctx interface{}, opts interface{}, timelockCallbackParams interface{}) *IMcmsDevInspect_DispatchTimelockBypasserExecuteBatch_Call {
	return &IMcmsDevInspect_DispatchTimelockBypasserExecuteBatch_Call{Call: _e.mock.On("DispatchTimelockBypasserExecuteBatch", ctx, opts, timelockCallbackParams)}
}

func (_c *IMcmsDevInspect_DispatchTimelockBypasserExecuteBatch_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelockCallbackParams module_mcms.TimelockCallbackParams)) *IMcmsDevInspect_DispatchTimelockBypasserExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *IMcmsDevInspect_DispatchTimelockBypasserExecuteBatch_Call) Return(_a0 []bind.Object, _a1 error) *IMcmsDevInspect_DispatchTimelockBypasserExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_DispatchTimelockBypasserExecuteBatch_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.TimelockCallbackParams) ([]bind.Object, error)) *IMcmsDevInspect_DispatchTimelockBypasserExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// DispatchTimelockExecuteBatch provides a mock function with given fields: ctx, opts, timelock, clock, timelockCallbackParams
func (_m *IMcmsDevInspect) DispatchTimelockExecuteBatch(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams) ([]bind.Object, error) {
	ret := _m.Called(ctx, opts, timelock, clock, timelockCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for DispatchTimelockExecuteBatch")
	}

	var r0 []bind.Object
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) ([]bind.Object, error)); ok {
		return rf(ctx, opts, timelock, clock, timelockCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) []bind.Object); ok {
		r0 = rf(ctx, opts, timelock, clock, timelockCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bind.Object)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) error); ok {
		r1 = rf(ctx, opts, timelock, clock, timelockCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_DispatchTimelockExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DispatchTimelockExecuteBatch'
type IMcmsDevInspect_DispatchTimelockExecuteBatch_Call struct {
	*mock.Call
}

// DispatchTimelockExecuteBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - clock bind.Object
//   - timelockCallbackParams module_mcms.TimelockCallbackParams
func (_e *IMcmsDevInspect_Expecter) DispatchTimelockExecuteBatch(ctx interface{}, opts interface{}, timelock interface{}, clock interface{}, timelockCallbackParams interface{}) *IMcmsDevInspect_DispatchTimelockExecuteBatch_Call {
	return &IMcmsDevInspect_DispatchTimelockExecuteBatch_Call{Call: _e.mock.On("DispatchTimelockExecuteBatch", ctx, opts, timelock, clock, timelockCallbackParams)}
}

func (_c *IMcmsDevInspect_DispatchTimelockExecuteBatch_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, timelockCallbackParams module_mcms.TimelockCallbackParams)) *IMcmsDevInspect_DispatchTimelockExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(module_mcms.TimelockCallbackParams))
	})
	return _c
}

func (_c *IMcmsDevInspect_DispatchTimelockExecuteBatch_Call) Return(_a0 []bind.Object, _a1 error) *IMcmsDevInspect_DispatchTimelockExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_DispatchTimelockExecuteBatch_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, module_mcms.TimelockCallbackParams) ([]bind.Object, error)) *IMcmsDevInspect_DispatchTimelockExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// Execute provides a mock function with given fields: ctx, opts, state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof
func (_m *IMcmsDevInspect) Execute(ctx context.Context, opts *bind.CallOpts, state bind.Object, clock bind.Object, role byte, chainId *big.Int, multisigAddr string, nonce uint64, to string, moduleName string, functionName string, data []byte, proof [][]byte) (module_mcms.TimelockCallbackParams, error) {
	ret := _m.Called(ctx, opts, state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 module_mcms.TimelockCallbackParams
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, *big.Int, string, uint64, string, string, string, []byte, [][]byte) (module_mcms.TimelockCallbackParams, error)); ok {
		return rf(ctx, opts, state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, *big.Int, string, uint64, string, string, string, []byte, [][]byte) module_mcms.TimelockCallbackParams); ok {
		r0 = rf(ctx, opts, state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	} else {
		r0 = ret.Get(0).(module_mcms.TimelockCallbackParams)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, *big.Int, string, uint64, string, string, string, []byte, [][]byte) error); ok {
		r1 = rf(ctx, opts, state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type IMcmsDevInspect_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - clock bind.Object
//   - role byte
//   - chainId *big.Int
//   - multisigAddr string
//   - nonce uint64
//   - to string
//   - moduleName string
//   - functionName string
//   - data []byte
//   - proof [][]byte
func (_e *IMcmsDevInspect_Expecter) Execute(ctx interface{}, opts interface{}, state interface{}, clock interface{}, role interface{}, chainId interface{}, multisigAddr interface{}, nonce interface{}, to interface{}, moduleName interface{}, functionName interface{}, data interface{}, proof interface{}) *IMcmsDevInspect_Execute_Call {
	return &IMcmsDevInspect_Execute_Call{Call: _e.mock.On("Execute", ctx, opts, state, clock, role, chainId, multisigAddr, nonce, to, moduleName, functionName, data, proof)}
}

func (_c *IMcmsDevInspect_Execute_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, clock bind.Object, role byte, chainId *big.Int, multisigAddr string, nonce uint64, to string, moduleName string, functionName string, data []byte, proof [][]byte)) *IMcmsDevInspect_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(byte), args[5].(*big.Int), args[6].(string), args[7].(uint64), args[8].(string), args[9].(string), args[10].(string), args[11].([]byte), args[12].([][]byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_Execute_Call) Return(_a0 module_mcms.TimelockCallbackParams, _a1 error) *IMcmsDevInspect_Execute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_Execute_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, byte, *big.Int, string, uint64, string, string, string, []byte, [][]byte) (module_mcms.TimelockCallbackParams, error)) *IMcmsDevInspect_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteDispatchToDeployer provides a mock function with given fields: ctx, opts, registry, deployerState, executingCallbackParams
func (_m *IMcmsDevInspect) ExecuteDispatchToDeployer(ctx context.Context, opts *bind.CallOpts, registry bind.Object, deployerState bind.Object, executingCallbackParams bind.Object) (bind.Object, error) {
	ret := _m.Called(ctx, opts, registry, deployerState, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteDispatchToDeployer")
	}

	var r0 bind.Object
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (bind.Object, error)); ok {
		return rf(ctx, opts, registry, deployerState, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) bind.Object); ok {
		r0 = rf(ctx, opts, registry, deployerState, executingCallbackParams)
	} else {
		r0 = ret.Get(0).(bind.Object)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, registry, deployerState, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_ExecuteDispatchToDeployer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteDispatchToDeployer'
type IMcmsDevInspect_ExecuteDispatchToDeployer_Call struct {
	*mock.Call
}

// ExecuteDispatchToDeployer is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - registry bind.Object
//   - deployerState bind.Object
//   - executingCallbackParams bind.Object
func (_e *IMcmsDevInspect_Expecter) ExecuteDispatchToDeployer(ctx interface{}, opts interface{}, registry interface{}, deployerState interface{}, executingCallbackParams interface{}) *IMcmsDevInspect_ExecuteDispatchToDeployer_Call {
	return &IMcmsDevInspect_ExecuteDispatchToDeployer_Call{Call: _e.mock.On("ExecuteDispatchToDeployer", ctx, opts, registry, deployerState, executingCallbackParams)}
}

func (_c *IMcmsDevInspect_ExecuteDispatchToDeployer_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, registry bind.Object, deployerState bind.Object, executingCallbackParams bind.Object)) *IMcmsDevInspect_ExecuteDispatchToDeployer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(bind.Object))
	})
	return _c
}

func (_c *IMcmsDevInspect_ExecuteDispatchToDeployer_Call) Return(_a0 bind.Object, _a1 error) *IMcmsDevInspect_ExecuteDispatchToDeployer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_ExecuteDispatchToDeployer_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) (bind.Object, error)) *IMcmsDevInspect_ExecuteDispatchToDeployer_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteTimelockBypasserExecuteBatch provides a mock function with given fields: ctx, opts, executingCallbackParams
func (_m *IMcmsDevInspect) ExecuteTimelockBypasserExecuteBatch(ctx context.Context, opts *bind.CallOpts, executingCallbackParams bind.Object) ([]bind.Object, error) {
	ret := _m.Called(ctx, opts, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteTimelockBypasserExecuteBatch")
	}

	var r0 []bind.Object
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object) ([]bind.Object, error)); ok {
		return rf(ctx, opts, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object) []bind.Object); ok {
		r0 = rf(ctx, opts, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bind.Object)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object) error); ok {
		r1 = rf(ctx, opts, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_ExecuteTimelockBypasserExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteTimelockBypasserExecuteBatch'
type IMcmsDevInspect_ExecuteTimelockBypasserExecuteBatch_Call struct {
	*mock.Call
}

// ExecuteTimelockBypasserExecuteBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - executingCallbackParams bind.Object
func (_e *IMcmsDevInspect_Expecter) ExecuteTimelockBypasserExecuteBatch(ctx interface{}, opts interface{}, executingCallbackParams interface{}) *IMcmsDevInspect_ExecuteTimelockBypasserExecuteBatch_Call {
	return &IMcmsDevInspect_ExecuteTimelockBypasserExecuteBatch_Call{Call: _e.mock.On("ExecuteTimelockBypasserExecuteBatch", ctx, opts, executingCallbackParams)}
}

func (_c *IMcmsDevInspect_ExecuteTimelockBypasserExecuteBatch_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, executingCallbackParams bind.Object)) *IMcmsDevInspect_ExecuteTimelockBypasserExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object))
	})
	return _c
}

func (_c *IMcmsDevInspect_ExecuteTimelockBypasserExecuteBatch_Call) Return(_a0 []bind.Object, _a1 error) *IMcmsDevInspect_ExecuteTimelockBypasserExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_ExecuteTimelockBypasserExecuteBatch_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object) ([]bind.Object, error)) *IMcmsDevInspect_ExecuteTimelockBypasserExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteTimelockExecuteBatch provides a mock function with given fields: ctx, opts, timelock, clock, executingCallbackParams
func (_m *IMcmsDevInspect) ExecuteTimelockExecuteBatch(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, executingCallbackParams bind.Object) ([]bind.Object, error) {
	ret := _m.Called(ctx, opts, timelock, clock, executingCallbackParams)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteTimelockExecuteBatch")
	}

	var r0 []bind.Object
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) ([]bind.Object, error)); ok {
		return rf(ctx, opts, timelock, clock, executingCallbackParams)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) []bind.Object); ok {
		r0 = rf(ctx, opts, timelock, clock, executingCallbackParams)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bind.Object)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) error); ok {
		r1 = rf(ctx, opts, timelock, clock, executingCallbackParams)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_ExecuteTimelockExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteTimelockExecuteBatch'
type IMcmsDevInspect_ExecuteTimelockExecuteBatch_Call struct {
	*mock.Call
}

// ExecuteTimelockExecuteBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - clock bind.Object
//   - executingCallbackParams bind.Object
func (_e *IMcmsDevInspect_Expecter) ExecuteTimelockExecuteBatch(ctx interface{}, opts interface{}, timelock interface{}, clock interface{}, executingCallbackParams interface{}) *IMcmsDevInspect_ExecuteTimelockExecuteBatch_Call {
	return &IMcmsDevInspect_ExecuteTimelockExecuteBatch_Call{Call: _e.mock.On("ExecuteTimelockExecuteBatch", ctx, opts, timelock, clock, executingCallbackParams)}
}

func (_c *IMcmsDevInspect_ExecuteTimelockExecuteBatch_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, executingCallbackParams bind.Object)) *IMcmsDevInspect_ExecuteTimelockExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].(bind.Object))
	})
	return _c
}

func (_c *IMcmsDevInspect_ExecuteTimelockExecuteBatch_Call) Return(_a0 []bind.Object, _a1 error) *IMcmsDevInspect_ExecuteTimelockExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_ExecuteTimelockExecuteBatch_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, bind.Object) ([]bind.Object, error)) *IMcmsDevInspect_ExecuteTimelockExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// ExpiringRootAndOpCount provides a mock function with given fields: ctx, opts, state, role
func (_m *IMcmsDevInspect) ExpiringRootAndOpCount(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte) ([]interface{}, error) {
	ret := _m.Called(ctx, opts, state, role)

	if len(ret) == 0 {
		panic("no return value specified for ExpiringRootAndOpCount")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) ([]interface{}, error)); ok {
		return rf(ctx, opts, state, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) []interface{}); ok {
		r0 = rf(ctx, opts, state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, byte) error); ok {
		r1 = rf(ctx, opts, state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_ExpiringRootAndOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpiringRootAndOpCount'
type IMcmsDevInspect_ExpiringRootAndOpCount_Call struct {
	*mock.Call
}

// ExpiringRootAndOpCount is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - role byte
func (_e *IMcmsDevInspect_Expecter) ExpiringRootAndOpCount(ctx interface{}, opts interface{}, state interface{}, role interface{}) *IMcmsDevInspect_ExpiringRootAndOpCount_Call {
	return &IMcmsDevInspect_ExpiringRootAndOpCount_Call{Call: _e.mock.On("ExpiringRootAndOpCount", ctx, opts, state, role)}
}

func (_c *IMcmsDevInspect_ExpiringRootAndOpCount_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte)) *IMcmsDevInspect_ExpiringRootAndOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_ExpiringRootAndOpCount_Call) Return(_a0 []interface{}, _a1 error) *IMcmsDevInspect_ExpiringRootAndOpCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_ExpiringRootAndOpCount_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, byte) ([]interface{}, error)) *IMcmsDevInspect_ExpiringRootAndOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionName provides a mock function with given fields: ctx, opts, function
func (_m *IMcmsDevInspect) FunctionName(ctx context.Context, opts *bind.CallOpts, function module_mcms.Function) (string, error) {
	ret := _m.Called(ctx, opts, function)

	if len(ret) == 0 {
		panic("no return value specified for FunctionName")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Function) (string, error)); ok {
		return rf(ctx, opts, function)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Function) string); ok {
		r0 = rf(ctx, opts, function)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Function) error); ok {
		r1 = rf(ctx, opts, function)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_FunctionName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionName'
type IMcmsDevInspect_FunctionName_Call struct {
	*mock.Call
}

// FunctionName is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - function module_mcms.Function
func (_e *IMcmsDevInspect_Expecter) FunctionName(ctx interface{}, opts interface{}, function interface{}) *IMcmsDevInspect_FunctionName_Call {
	return &IMcmsDevInspect_FunctionName_Call{Call: _e.mock.On("FunctionName", ctx, opts, function)}
}

func (_c *IMcmsDevInspect_FunctionName_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, function module_mcms.Function)) *IMcmsDevInspect_FunctionName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Function))
	})
	return _c
}

func (_c *IMcmsDevInspect_FunctionName_Call) Return(_a0 string, _a1 error) *IMcmsDevInspect_FunctionName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_FunctionName_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Function) (string, error)) *IMcmsDevInspect_FunctionName_Call {
	_c.Call.Return(run)
	return _c
}

// GetConfig provides a mock function with given fields: ctx, opts, state, role
func (_m *IMcmsDevInspect) GetConfig(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte) (module_mcms.Config, error) {
	ret := _m.Called(ctx, opts, state, role)

	if len(ret) == 0 {
		panic("no return value specified for GetConfig")
	}

	var r0 module_mcms.Config
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) (module_mcms.Config, error)); ok {
		return rf(ctx, opts, state, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) module_mcms.Config); ok {
		r0 = rf(ctx, opts, state, role)
	} else {
		r0 = ret.Get(0).(module_mcms.Config)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, byte) error); ok {
		r1 = rf(ctx, opts, state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_GetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConfig'
type IMcmsDevInspect_GetConfig_Call struct {
	*mock.Call
}

// GetConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - role byte
func (_e *IMcmsDevInspect_Expecter) GetConfig(ctx interface{}, opts interface{}, state interface{}, role interface{}) *IMcmsDevInspect_GetConfig_Call {
	return &IMcmsDevInspect_GetConfig_Call{Call: _e.mock.On("GetConfig", ctx, opts, state, role)}
}

func (_c *IMcmsDevInspect_GetConfig_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte)) *IMcmsDevInspect_GetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_GetConfig_Call) Return(_a0 module_mcms.Config, _a1 error) *IMcmsDevInspect_GetConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_GetConfig_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, byte) (module_mcms.Config, error)) *IMcmsDevInspect_GetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetOpCount provides a mock function with given fields: ctx, opts, state, role
func (_m *IMcmsDevInspect) GetOpCount(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte) (uint64, error) {
	ret := _m.Called(ctx, opts, state, role)

	if len(ret) == 0 {
		panic("no return value specified for GetOpCount")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) (uint64, error)); ok {
		return rf(ctx, opts, state, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) uint64); ok {
		r0 = rf(ctx, opts, state, role)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, byte) error); ok {
		r1 = rf(ctx, opts, state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_GetOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOpCount'
type IMcmsDevInspect_GetOpCount_Call struct {
	*mock.Call
}

// GetOpCount is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - role byte
func (_e *IMcmsDevInspect_Expecter) GetOpCount(ctx interface{}, opts interface{}, state interface{}, role interface{}) *IMcmsDevInspect_GetOpCount_Call {
	return &IMcmsDevInspect_GetOpCount_Call{Call: _e.mock.On("GetOpCount", ctx, opts, state, role)}
}

func (_c *IMcmsDevInspect_GetOpCount_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte)) *IMcmsDevInspect_GetOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_GetOpCount_Call) Return(_a0 uint64, _a1 error) *IMcmsDevInspect_GetOpCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_GetOpCount_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, byte) (uint64, error)) *IMcmsDevInspect_GetOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoot provides a mock function with given fields: ctx, opts, state, role
func (_m *IMcmsDevInspect) GetRoot(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte) ([]interface{}, error) {
	ret := _m.Called(ctx, opts, state, role)

	if len(ret) == 0 {
		panic("no return value specified for GetRoot")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) ([]interface{}, error)); ok {
		return rf(ctx, opts, state, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) []interface{}); ok {
		r0 = rf(ctx, opts, state, role)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, byte) error); ok {
		r1 = rf(ctx, opts, state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_GetRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoot'
type IMcmsDevInspect_GetRoot_Call struct {
	*mock.Call
}

// GetRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - role byte
func (_e *IMcmsDevInspect_Expecter) GetRoot(ctx interface{}, opts interface{}, state interface{}, role interface{}) *IMcmsDevInspect_GetRoot_Call {
	return &IMcmsDevInspect_GetRoot_Call{Call: _e.mock.On("GetRoot", ctx, opts, state, role)}
}

func (_c *IMcmsDevInspect_GetRoot_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte)) *IMcmsDevInspect_GetRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_GetRoot_Call) Return(_a0 []interface{}, _a1 error) *IMcmsDevInspect_GetRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_GetRoot_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, byte) ([]interface{}, error)) *IMcmsDevInspect_GetRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetRootMetadata provides a mock function with given fields: ctx, opts, state, role
func (_m *IMcmsDevInspect) GetRootMetadata(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte) (module_mcms.RootMetadata, error) {
	ret := _m.Called(ctx, opts, state, role)

	if len(ret) == 0 {
		panic("no return value specified for GetRootMetadata")
	}

	var r0 module_mcms.RootMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) (module_mcms.RootMetadata, error)); ok {
		return rf(ctx, opts, state, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) module_mcms.RootMetadata); ok {
		r0 = rf(ctx, opts, state, role)
	} else {
		r0 = ret.Get(0).(module_mcms.RootMetadata)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, byte) error); ok {
		r1 = rf(ctx, opts, state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_GetRootMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRootMetadata'
type IMcmsDevInspect_GetRootMetadata_Call struct {
	*mock.Call
}

// GetRootMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - role byte
func (_e *IMcmsDevInspect_Expecter) GetRootMetadata(ctx interface{}, opts interface{}, state interface{}, role interface{}) *IMcmsDevInspect_GetRootMetadata_Call {
	return &IMcmsDevInspect_GetRootMetadata_Call{Call: _e.mock.On("GetRootMetadata", ctx, opts, state, role)}
}

func (_c *IMcmsDevInspect_GetRootMetadata_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte)) *IMcmsDevInspect_GetRootMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_GetRootMetadata_Call) Return(_a0 module_mcms.RootMetadata, _a1 error) *IMcmsDevInspect_GetRootMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_GetRootMetadata_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, byte) (module_mcms.RootMetadata, error)) *IMcmsDevInspect_GetRootMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// HashOpLeaf provides a mock function with given fields: ctx, opts, domainSeparator, op
func (_m *IMcmsDevInspect) HashOpLeaf(ctx context.Context, opts *bind.CallOpts, domainSeparator []byte, op module_mcms.Op) ([]byte, error) {
	ret := _m.Called(ctx, opts, domainSeparator, op)

	if len(ret) == 0 {
		panic("no return value specified for HashOpLeaf")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []byte, module_mcms.Op) ([]byte, error)); ok {
		return rf(ctx, opts, domainSeparator, op)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []byte, module_mcms.Op) []byte); ok {
		r0 = rf(ctx, opts, domainSeparator, op)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, []byte, module_mcms.Op) error); ok {
		r1 = rf(ctx, opts, domainSeparator, op)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_HashOpLeaf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashOpLeaf'
type IMcmsDevInspect_HashOpLeaf_Call struct {
	*mock.Call
}

// HashOpLeaf is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - domainSeparator []byte
//   - op module_mcms.Op
func (_e *IMcmsDevInspect_Expecter) HashOpLeaf(ctx interface{}, opts interface{}, domainSeparator interface{}, op interface{}) *IMcmsDevInspect_HashOpLeaf_Call {
	return &IMcmsDevInspect_HashOpLeaf_Call{Call: _e.mock.On("HashOpLeaf", ctx, opts, domainSeparator, op)}
}

func (_c *IMcmsDevInspect_HashOpLeaf_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, domainSeparator []byte, op module_mcms.Op)) *IMcmsDevInspect_HashOpLeaf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].([]byte), args[3].(module_mcms.Op))
	})
	return _c
}

func (_c *IMcmsDevInspect_HashOpLeaf_Call) Return(_a0 []byte, _a1 error) *IMcmsDevInspect_HashOpLeaf_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_HashOpLeaf_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, []byte, module_mcms.Op) ([]byte, error)) *IMcmsDevInspect_HashOpLeaf_Call {
	_c.Call.Return(run)
	return _c
}

// HashOperationBatch provides a mock function with given fields: ctx, opts, calls, predecessor, salt
func (_m *IMcmsDevInspect) HashOperationBatch(ctx context.Context, opts *bind.CallOpts, calls []module_mcms.Call, predecessor []byte, salt []byte) ([]byte, error) {
	ret := _m.Called(ctx, opts, calls, predecessor, salt)

	if len(ret) == 0 {
		panic("no return value specified for HashOperationBatch")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []module_mcms.Call, []byte, []byte) ([]byte, error)); ok {
		return rf(ctx, opts, calls, predecessor, salt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, []module_mcms.Call, []byte, []byte) []byte); ok {
		r0 = rf(ctx, opts, calls, predecessor, salt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, []module_mcms.Call, []byte, []byte) error); ok {
		r1 = rf(ctx, opts, calls, predecessor, salt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_HashOperationBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashOperationBatch'
type IMcmsDevInspect_HashOperationBatch_Call struct {
	*mock.Call
}

// HashOperationBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - calls []module_mcms.Call
//   - predecessor []byte
//   - salt []byte
func (_e *IMcmsDevInspect_Expecter) HashOperationBatch(ctx interface{}, opts interface{}, calls interface{}, predecessor interface{}, salt interface{}) *IMcmsDevInspect_HashOperationBatch_Call {
	return &IMcmsDevInspect_HashOperationBatch_Call{Call: _e.mock.On("HashOperationBatch", ctx, opts, calls, predecessor, salt)}
}

func (_c *IMcmsDevInspect_HashOperationBatch_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, calls []module_mcms.Call, predecessor []byte, salt []byte)) *IMcmsDevInspect_HashOperationBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].([]module_mcms.Call), args[3].([]byte), args[4].([]byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_HashOperationBatch_Call) Return(_a0 []byte, _a1 error) *IMcmsDevInspect_HashOperationBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_HashOperationBatch_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, []module_mcms.Call, []byte, []byte) ([]byte, error)) *IMcmsDevInspect_HashOperationBatch_Call {
	_c.Call.Return(run)
	return _c
}

// IsValidRole provides a mock function with given fields: ctx, opts, role
func (_m *IMcmsDevInspect) IsValidRole(ctx context.Context, opts *bind.CallOpts, role byte) (bool, error) {
	ret := _m.Called(ctx, opts, role)

	if len(ret) == 0 {
		panic("no return value specified for IsValidRole")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, byte) (bool, error)); ok {
		return rf(ctx, opts, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, byte) bool); ok {
		r0 = rf(ctx, opts, role)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, byte) error); ok {
		r1 = rf(ctx, opts, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_IsValidRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsValidRole'
type IMcmsDevInspect_IsValidRole_Call struct {
	*mock.Call
}

// IsValidRole is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - role byte
func (_e *IMcmsDevInspect_Expecter) IsValidRole(ctx interface{}, opts interface{}, role interface{}) *IMcmsDevInspect_IsValidRole_Call {
	return &IMcmsDevInspect_IsValidRole_Call{Call: _e.mock.On("IsValidRole", ctx, opts, role)}
}

func (_c *IMcmsDevInspect_IsValidRole_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, role byte)) *IMcmsDevInspect_IsValidRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_IsValidRole_Call) Return(_a0 bool, _a1 error) *IMcmsDevInspect_IsValidRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_IsValidRole_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, byte) (bool, error)) *IMcmsDevInspect_IsValidRole_Call {
	_c.Call.Return(run)
	return _c
}

// MaxNumSigners provides a mock function with given fields: ctx, opts
func (_m *IMcmsDevInspect) MaxNumSigners(ctx context.Context, opts *bind.CallOpts) (uint64, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for MaxNumSigners")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) (uint64, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) uint64); ok {
		r0 = rf(ctx, opts)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_MaxNumSigners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxNumSigners'
type IMcmsDevInspect_MaxNumSigners_Call struct {
	*mock.Call
}

// MaxNumSigners is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
func (_e *IMcmsDevInspect_Expecter) MaxNumSigners(ctx interface{}, opts interface{}) *IMcmsDevInspect_MaxNumSigners_Call {
	return &IMcmsDevInspect_MaxNumSigners_Call{Call: _e.mock.On("MaxNumSigners", ctx, opts)}
}

func (_c *IMcmsDevInspect_MaxNumSigners_Call) Run(run func(ctx context.Context, opts *bind.CallOpts)) *IMcmsDevInspect_MaxNumSigners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts))
	})
	return _c
}

func (_c *IMcmsDevInspect_MaxNumSigners_Call) Return(_a0 uint64, _a1 error) *IMcmsDevInspect_MaxNumSigners_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_MaxNumSigners_Call) RunAndReturn(run func(context.Context, *bind.CallOpts) (uint64, error)) *IMcmsDevInspect_MaxNumSigners_Call {
	_c.Call.Return(run)
	return _c
}

// ModuleName provides a mock function with given fields: ctx, opts, function
func (_m *IMcmsDevInspect) ModuleName(ctx context.Context, opts *bind.CallOpts, function module_mcms.Function) (string, error) {
	ret := _m.Called(ctx, opts, function)

	if len(ret) == 0 {
		panic("no return value specified for ModuleName")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Function) (string, error)); ok {
		return rf(ctx, opts, function)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Function) string); ok {
		r0 = rf(ctx, opts, function)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Function) error); ok {
		r1 = rf(ctx, opts, function)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_ModuleName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModuleName'
type IMcmsDevInspect_ModuleName_Call struct {
	*mock.Call
}

// ModuleName is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - function module_mcms.Function
func (_e *IMcmsDevInspect_Expecter) ModuleName(ctx interface{}, opts interface{}, function interface{}) *IMcmsDevInspect_ModuleName_Call {
	return &IMcmsDevInspect_ModuleName_Call{Call: _e.mock.On("ModuleName", ctx, opts, function)}
}

func (_c *IMcmsDevInspect_ModuleName_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, function module_mcms.Function)) *IMcmsDevInspect_ModuleName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Function))
	})
	return _c
}

func (_c *IMcmsDevInspect_ModuleName_Call) Return(_a0 string, _a1 error) *IMcmsDevInspect_ModuleName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_ModuleName_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Function) (string, error)) *IMcmsDevInspect_ModuleName_Call {
	_c.Call.Return(run)
	return _c
}

// NumGroups provides a mock function with given fields: ctx, opts
func (_m *IMcmsDevInspect) NumGroups(ctx context.Context, opts *bind.CallOpts) (uint64, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for NumGroups")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) (uint64, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) uint64); ok {
		r0 = rf(ctx, opts)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_NumGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NumGroups'
type IMcmsDevInspect_NumGroups_Call struct {
	*mock.Call
}

// NumGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
func (_e *IMcmsDevInspect_Expecter) NumGroups(ctx interface{}, opts interface{}) *IMcmsDevInspect_NumGroups_Call {
	return &IMcmsDevInspect_NumGroups_Call{Call: _e.mock.On("NumGroups", ctx, opts)}
}

func (_c *IMcmsDevInspect_NumGroups_Call) Run(run func(ctx context.Context, opts *bind.CallOpts)) *IMcmsDevInspect_NumGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts))
	})
	return _c
}

func (_c *IMcmsDevInspect_NumGroups_Call) Return(_a0 uint64, _a1 error) *IMcmsDevInspect_NumGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_NumGroups_Call) RunAndReturn(run func(context.Context, *bind.CallOpts) (uint64, error)) *IMcmsDevInspect_NumGroups_Call {
	_c.Call.Return(run)
	return _c
}

// OverridePreviousRoot provides a mock function with given fields: ctx, opts, rootMetadata
func (_m *IMcmsDevInspect) OverridePreviousRoot(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata) (bool, error) {
	ret := _m.Called(ctx, opts, rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for OverridePreviousRoot")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (bool, error)); ok {
		return rf(ctx, opts, rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) bool); ok {
		r0 = rf(ctx, opts, rootMetadata)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) error); ok {
		r1 = rf(ctx, opts, rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_OverridePreviousRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OverridePreviousRoot'
type IMcmsDevInspect_OverridePreviousRoot_Call struct {
	*mock.Call
}

// OverridePreviousRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - rootMetadata module_mcms.RootMetadata
func (_e *IMcmsDevInspect_Expecter) OverridePreviousRoot(ctx interface{}, opts interface{}, rootMetadata interface{}) *IMcmsDevInspect_OverridePreviousRoot_Call {
	return &IMcmsDevInspect_OverridePreviousRoot_Call{Call: _e.mock.On("OverridePreviousRoot", ctx, opts, rootMetadata)}
}

func (_c *IMcmsDevInspect_OverridePreviousRoot_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata)) *IMcmsDevInspect_OverridePreviousRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *IMcmsDevInspect_OverridePreviousRoot_Call) Return(_a0 bool, _a1 error) *IMcmsDevInspect_OverridePreviousRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_OverridePreviousRoot_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (bool, error)) *IMcmsDevInspect_OverridePreviousRoot_Call {
	_c.Call.Return(run)
	return _c
}

// PostOpCount provides a mock function with given fields: ctx, opts, rootMetadata
func (_m *IMcmsDevInspect) PostOpCount(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata) (uint64, error) {
	ret := _m.Called(ctx, opts, rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for PostOpCount")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (uint64, error)); ok {
		return rf(ctx, opts, rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) uint64); ok {
		r0 = rf(ctx, opts, rootMetadata)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) error); ok {
		r1 = rf(ctx, opts, rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_PostOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PostOpCount'
type IMcmsDevInspect_PostOpCount_Call struct {
	*mock.Call
}

// PostOpCount is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - rootMetadata module_mcms.RootMetadata
func (_e *IMcmsDevInspect_Expecter) PostOpCount(ctx interface{}, opts interface{}, rootMetadata interface{}) *IMcmsDevInspect_PostOpCount_Call {
	return &IMcmsDevInspect_PostOpCount_Call{Call: _e.mock.On("PostOpCount", ctx, opts, rootMetadata)}
}

func (_c *IMcmsDevInspect_PostOpCount_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata)) *IMcmsDevInspect_PostOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *IMcmsDevInspect_PostOpCount_Call) Return(_a0 uint64, _a1 error) *IMcmsDevInspect_PostOpCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_PostOpCount_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (uint64, error)) *IMcmsDevInspect_PostOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// PreOpCount provides a mock function with given fields: ctx, opts, rootMetadata
func (_m *IMcmsDevInspect) PreOpCount(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata) (uint64, error) {
	ret := _m.Called(ctx, opts, rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for PreOpCount")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (uint64, error)); ok {
		return rf(ctx, opts, rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) uint64); ok {
		r0 = rf(ctx, opts, rootMetadata)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) error); ok {
		r1 = rf(ctx, opts, rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_PreOpCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PreOpCount'
type IMcmsDevInspect_PreOpCount_Call struct {
	*mock.Call
}

// PreOpCount is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - rootMetadata module_mcms.RootMetadata
func (_e *IMcmsDevInspect_Expecter) PreOpCount(ctx interface{}, opts interface{}, rootMetadata interface{}) *IMcmsDevInspect_PreOpCount_Call {
	return &IMcmsDevInspect_PreOpCount_Call{Call: _e.mock.On("PreOpCount", ctx, opts, rootMetadata)}
}

func (_c *IMcmsDevInspect_PreOpCount_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata)) *IMcmsDevInspect_PreOpCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *IMcmsDevInspect_PreOpCount_Call) Return(_a0 uint64, _a1 error) *IMcmsDevInspect_PreOpCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_PreOpCount_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (uint64, error)) *IMcmsDevInspect_PreOpCount_Call {
	_c.Call.Return(run)
	return _c
}

// ProposerRole provides a mock function with given fields: ctx, opts
func (_m *IMcmsDevInspect) ProposerRole(ctx context.Context, opts *bind.CallOpts) (byte, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ProposerRole")
	}

	var r0 byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) (byte, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) byte); ok {
		r0 = rf(ctx, opts)
	} else {
		r0 = ret.Get(0).(byte)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_ProposerRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProposerRole'
type IMcmsDevInspect_ProposerRole_Call struct {
	*mock.Call
}

// ProposerRole is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
func (_e *IMcmsDevInspect_Expecter) ProposerRole(ctx interface{}, opts interface{}) *IMcmsDevInspect_ProposerRole_Call {
	return &IMcmsDevInspect_ProposerRole_Call{Call: _e.mock.On("ProposerRole", ctx, opts)}
}

func (_c *IMcmsDevInspect_ProposerRole_Call) Run(run func(ctx context.Context, opts *bind.CallOpts)) *IMcmsDevInspect_ProposerRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts))
	})
	return _c
}

func (_c *IMcmsDevInspect_ProposerRole_Call) Return(_a0 byte, _a1 error) *IMcmsDevInspect_ProposerRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_ProposerRole_Call) RunAndReturn(run func(context.Context, *bind.CallOpts) (byte, error)) *IMcmsDevInspect_ProposerRole_Call {
	_c.Call.Return(run)
	return _c
}

// Role provides a mock function with given fields: ctx, opts, rootMetadata
func (_m *IMcmsDevInspect) Role(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata) (byte, error) {
	ret := _m.Called(ctx, opts, rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for Role")
	}

	var r0 byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (byte, error)); ok {
		return rf(ctx, opts, rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) byte); ok {
		r0 = rf(ctx, opts, rootMetadata)
	} else {
		r0 = ret.Get(0).(byte)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) error); ok {
		r1 = rf(ctx, opts, rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_Role_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Role'
type IMcmsDevInspect_Role_Call struct {
	*mock.Call
}

// Role is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - rootMetadata module_mcms.RootMetadata
func (_e *IMcmsDevInspect_Expecter) Role(ctx interface{}, opts interface{}, rootMetadata interface{}) *IMcmsDevInspect_Role_Call {
	return &IMcmsDevInspect_Role_Call{Call: _e.mock.On("Role", ctx, opts, rootMetadata)}
}

func (_c *IMcmsDevInspect_Role_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata)) *IMcmsDevInspect_Role_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *IMcmsDevInspect_Role_Call) Return(_a0 byte, _a1 error) *IMcmsDevInspect_Role_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_Role_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (byte, error)) *IMcmsDevInspect_Role_Call {
	_c.Call.Return(run)
	return _c
}

// RootMetadata provides a mock function with given fields: ctx, opts, multisig
func (_m *IMcmsDevInspect) RootMetadata(ctx context.Context, opts *bind.CallOpts, multisig module_mcms.Multisig) (module_mcms.RootMetadata, error) {
	ret := _m.Called(ctx, opts, multisig)

	if len(ret) == 0 {
		panic("no return value specified for RootMetadata")
	}

	var r0 module_mcms.RootMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Multisig) (module_mcms.RootMetadata, error)); ok {
		return rf(ctx, opts, multisig)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Multisig) module_mcms.RootMetadata); ok {
		r0 = rf(ctx, opts, multisig)
	} else {
		r0 = ret.Get(0).(module_mcms.RootMetadata)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Multisig) error); ok {
		r1 = rf(ctx, opts, multisig)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_RootMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RootMetadata'
type IMcmsDevInspect_RootMetadata_Call struct {
	*mock.Call
}

// RootMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - multisig module_mcms.Multisig
func (_e *IMcmsDevInspect_Expecter) RootMetadata(ctx interface{}, opts interface{}, multisig interface{}) *IMcmsDevInspect_RootMetadata_Call {
	return &IMcmsDevInspect_RootMetadata_Call{Call: _e.mock.On("RootMetadata", ctx, opts, multisig)}
}

func (_c *IMcmsDevInspect_RootMetadata_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, multisig module_mcms.Multisig)) *IMcmsDevInspect_RootMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Multisig))
	})
	return _c
}

func (_c *IMcmsDevInspect_RootMetadata_Call) Return(_a0 module_mcms.RootMetadata, _a1 error) *IMcmsDevInspect_RootMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_RootMetadata_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Multisig) (module_mcms.RootMetadata, error)) *IMcmsDevInspect_RootMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// RootMetadataMultisig provides a mock function with given fields: ctx, opts, rootMetadata
func (_m *IMcmsDevInspect) RootMetadataMultisig(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata) (string, error) {
	ret := _m.Called(ctx, opts, rootMetadata)

	if len(ret) == 0 {
		panic("no return value specified for RootMetadataMultisig")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (string, error)); ok {
		return rf(ctx, opts, rootMetadata)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) string); ok {
		r0 = rf(ctx, opts, rootMetadata)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) error); ok {
		r1 = rf(ctx, opts, rootMetadata)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_RootMetadataMultisig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RootMetadataMultisig'
type IMcmsDevInspect_RootMetadataMultisig_Call struct {
	*mock.Call
}

// RootMetadataMultisig is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - rootMetadata module_mcms.RootMetadata
func (_e *IMcmsDevInspect_Expecter) RootMetadataMultisig(ctx interface{}, opts interface{}, rootMetadata interface{}) *IMcmsDevInspect_RootMetadataMultisig_Call {
	return &IMcmsDevInspect_RootMetadataMultisig_Call{Call: _e.mock.On("RootMetadataMultisig", ctx, opts, rootMetadata)}
}

func (_c *IMcmsDevInspect_RootMetadataMultisig_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, rootMetadata module_mcms.RootMetadata)) *IMcmsDevInspect_RootMetadataMultisig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.RootMetadata))
	})
	return _c
}

func (_c *IMcmsDevInspect_RootMetadataMultisig_Call) Return(_a0 string, _a1 error) *IMcmsDevInspect_RootMetadataMultisig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_RootMetadataMultisig_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.RootMetadata) (string, error)) *IMcmsDevInspect_RootMetadataMultisig_Call {
	_c.Call.Return(run)
	return _c
}

// SeenSignedHashes provides a mock function with given fields: ctx, opts, state, role
func (_m *IMcmsDevInspect) SeenSignedHashes(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte) (bind.Object, error) {
	ret := _m.Called(ctx, opts, state, role)

	if len(ret) == 0 {
		panic("no return value specified for SeenSignedHashes")
	}

	var r0 bind.Object
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) (bind.Object, error)); ok {
		return rf(ctx, opts, state, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, byte) bind.Object); ok {
		r0 = rf(ctx, opts, state, role)
	} else {
		r0 = ret.Get(0).(bind.Object)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, byte) error); ok {
		r1 = rf(ctx, opts, state, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_SeenSignedHashes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SeenSignedHashes'
type IMcmsDevInspect_SeenSignedHashes_Call struct {
	*mock.Call
}

// SeenSignedHashes is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - state bind.Object
//   - role byte
func (_e *IMcmsDevInspect_Expecter) SeenSignedHashes(ctx interface{}, opts interface{}, state interface{}, role interface{}) *IMcmsDevInspect_SeenSignedHashes_Call {
	return &IMcmsDevInspect_SeenSignedHashes_Call{Call: _e.mock.On("SeenSignedHashes", ctx, opts, state, role)}
}

func (_c *IMcmsDevInspect_SeenSignedHashes_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, state bind.Object, role byte)) *IMcmsDevInspect_SeenSignedHashes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_SeenSignedHashes_Call) Return(_a0 bind.Object, _a1 error) *IMcmsDevInspect_SeenSignedHashes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_SeenSignedHashes_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, byte) (bind.Object, error)) *IMcmsDevInspect_SeenSignedHashes_Call {
	_c.Call.Return(run)
	return _c
}

// SignerView provides a mock function with given fields: ctx, opts, signer
func (_m *IMcmsDevInspect) SignerView(ctx context.Context, opts *bind.CallOpts, signer module_mcms.Signer) ([]interface{}, error) {
	ret := _m.Called(ctx, opts, signer)

	if len(ret) == 0 {
		panic("no return value specified for SignerView")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Signer) ([]interface{}, error)); ok {
		return rf(ctx, opts, signer)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Signer) []interface{}); ok {
		r0 = rf(ctx, opts, signer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Signer) error); ok {
		r1 = rf(ctx, opts, signer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_SignerView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignerView'
type IMcmsDevInspect_SignerView_Call struct {
	*mock.Call
}

// SignerView is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - signer module_mcms.Signer
func (_e *IMcmsDevInspect_Expecter) SignerView(ctx interface{}, opts interface{}, signer interface{}) *IMcmsDevInspect_SignerView_Call {
	return &IMcmsDevInspect_SignerView_Call{Call: _e.mock.On("SignerView", ctx, opts, signer)}
}

func (_c *IMcmsDevInspect_SignerView_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, signer module_mcms.Signer)) *IMcmsDevInspect_SignerView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Signer))
	})
	return _c
}

func (_c *IMcmsDevInspect_SignerView_Call) Return(_a0 []interface{}, _a1 error) *IMcmsDevInspect_SignerView_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_SignerView_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Signer) ([]interface{}, error)) *IMcmsDevInspect_SignerView_Call {
	_c.Call.Return(run)
	return _c
}

// Target provides a mock function with given fields: ctx, opts, function
func (_m *IMcmsDevInspect) Target(ctx context.Context, opts *bind.CallOpts, function module_mcms.Function) (string, error) {
	ret := _m.Called(ctx, opts, function)

	if len(ret) == 0 {
		panic("no return value specified for Target")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Function) (string, error)); ok {
		return rf(ctx, opts, function)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, module_mcms.Function) string); ok {
		r0 = rf(ctx, opts, function)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, module_mcms.Function) error); ok {
		r1 = rf(ctx, opts, function)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_Target_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Target'
type IMcmsDevInspect_Target_Call struct {
	*mock.Call
}

// Target is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - function module_mcms.Function
func (_e *IMcmsDevInspect_Expecter) Target(ctx interface{}, opts interface{}, function interface{}) *IMcmsDevInspect_Target_Call {
	return &IMcmsDevInspect_Target_Call{Call: _e.mock.On("Target", ctx, opts, function)}
}

func (_c *IMcmsDevInspect_Target_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, function module_mcms.Function)) *IMcmsDevInspect_Target_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(module_mcms.Function))
	})
	return _c
}

func (_c *IMcmsDevInspect_Target_Call) Return(_a0 string, _a1 error) *IMcmsDevInspect_Target_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_Target_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, module_mcms.Function) (string, error)) *IMcmsDevInspect_Target_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockExecuteBatch provides a mock function with given fields: ctx, opts, timelock, clock, targets, moduleNames, functionNames, datas, predecessor, salt
func (_m *IMcmsDevInspect) TimelockExecuteBatch(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, targets []string, moduleNames []string, functionNames []string, datas [][]byte, predecessor []byte, salt []byte) ([]bind.Object, error) {
	ret := _m.Called(ctx, opts, timelock, clock, targets, moduleNames, functionNames, datas, predecessor, salt)

	if len(ret) == 0 {
		panic("no return value specified for TimelockExecuteBatch")
	}

	var r0 []bind.Object
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, []string, []string, []string, [][]byte, []byte, []byte) ([]bind.Object, error)); ok {
		return rf(ctx, opts, timelock, clock, targets, moduleNames, functionNames, datas, predecessor, salt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, []string, []string, []string, [][]byte, []byte, []byte) []bind.Object); ok {
		r0 = rf(ctx, opts, timelock, clock, targets, moduleNames, functionNames, datas, predecessor, salt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bind.Object)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, []string, []string, []string, [][]byte, []byte, []byte) error); ok {
		r1 = rf(ctx, opts, timelock, clock, targets, moduleNames, functionNames, datas, predecessor, salt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_TimelockExecuteBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockExecuteBatch'
type IMcmsDevInspect_TimelockExecuteBatch_Call struct {
	*mock.Call
}

// TimelockExecuteBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - clock bind.Object
//   - targets []string
//   - moduleNames []string
//   - functionNames []string
//   - datas [][]byte
//   - predecessor []byte
//   - salt []byte
func (_e *IMcmsDevInspect_Expecter) TimelockExecuteBatch(ctx interface{}, opts interface{}, timelock interface{}, clock interface{}, targets interface{}, moduleNames interface{}, functionNames interface{}, datas interface{}, predecessor interface{}, salt interface{}) *IMcmsDevInspect_TimelockExecuteBatch_Call {
	return &IMcmsDevInspect_TimelockExecuteBatch_Call{Call: _e.mock.On("TimelockExecuteBatch", ctx, opts, timelock, clock, targets, moduleNames, functionNames, datas, predecessor, salt)}
}

func (_c *IMcmsDevInspect_TimelockExecuteBatch_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, targets []string, moduleNames []string, functionNames []string, datas [][]byte, predecessor []byte, salt []byte)) *IMcmsDevInspect_TimelockExecuteBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].([]string), args[5].([]string), args[6].([]string), args[7].([][]byte), args[8].([]byte), args[9].([]byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_TimelockExecuteBatch_Call) Return(_a0 []bind.Object, _a1 error) *IMcmsDevInspect_TimelockExecuteBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_TimelockExecuteBatch_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, []string, []string, []string, [][]byte, []byte, []byte) ([]bind.Object, error)) *IMcmsDevInspect_TimelockExecuteBatch_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunction provides a mock function with given fields: ctx, opts, timelock, index
func (_m *IMcmsDevInspect) TimelockGetBlockedFunction(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, index uint64) (module_mcms.Function, error) {
	ret := _m.Called(ctx, opts, timelock, index)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunction")
	}

	var r0 module_mcms.Function
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, uint64) (module_mcms.Function, error)); ok {
		return rf(ctx, opts, timelock, index)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, uint64) module_mcms.Function); ok {
		r0 = rf(ctx, opts, timelock, index)
	} else {
		r0 = ret.Get(0).(module_mcms.Function)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, uint64) error); ok {
		r1 = rf(ctx, opts, timelock, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_TimelockGetBlockedFunction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunction'
type IMcmsDevInspect_TimelockGetBlockedFunction_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunction is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - index uint64
func (_e *IMcmsDevInspect_Expecter) TimelockGetBlockedFunction(ctx interface{}, opts interface{}, timelock interface{}, index interface{}) *IMcmsDevInspect_TimelockGetBlockedFunction_Call {
	return &IMcmsDevInspect_TimelockGetBlockedFunction_Call{Call: _e.mock.On("TimelockGetBlockedFunction", ctx, opts, timelock, index)}
}

func (_c *IMcmsDevInspect_TimelockGetBlockedFunction_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, index uint64)) *IMcmsDevInspect_TimelockGetBlockedFunction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(uint64))
	})
	return _c
}

func (_c *IMcmsDevInspect_TimelockGetBlockedFunction_Call) Return(_a0 module_mcms.Function, _a1 error) *IMcmsDevInspect_TimelockGetBlockedFunction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_TimelockGetBlockedFunction_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, uint64) (module_mcms.Function, error)) *IMcmsDevInspect_TimelockGetBlockedFunction_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunctions provides a mock function with given fields: ctx, opts, timelock
func (_m *IMcmsDevInspect) TimelockGetBlockedFunctions(ctx context.Context, opts *bind.CallOpts, timelock bind.Object) ([]module_mcms.Function, error) {
	ret := _m.Called(ctx, opts, timelock)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunctions")
	}

	var r0 []module_mcms.Function
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object) ([]module_mcms.Function, error)); ok {
		return rf(ctx, opts, timelock)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object) []module_mcms.Function); ok {
		r0 = rf(ctx, opts, timelock)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]module_mcms.Function)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object) error); ok {
		r1 = rf(ctx, opts, timelock)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_TimelockGetBlockedFunctions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunctions'
type IMcmsDevInspect_TimelockGetBlockedFunctions_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunctions is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
func (_e *IMcmsDevInspect_Expecter) TimelockGetBlockedFunctions(ctx interface{}, opts interface{}, timelock interface{}) *IMcmsDevInspect_TimelockGetBlockedFunctions_Call {
	return &IMcmsDevInspect_TimelockGetBlockedFunctions_Call{Call: _e.mock.On("TimelockGetBlockedFunctions", ctx, opts, timelock)}
}

func (_c *IMcmsDevInspect_TimelockGetBlockedFunctions_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object)) *IMcmsDevInspect_TimelockGetBlockedFunctions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object))
	})
	return _c
}

func (_c *IMcmsDevInspect_TimelockGetBlockedFunctions_Call) Return(_a0 []module_mcms.Function, _a1 error) *IMcmsDevInspect_TimelockGetBlockedFunctions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_TimelockGetBlockedFunctions_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object) ([]module_mcms.Function, error)) *IMcmsDevInspect_TimelockGetBlockedFunctions_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetBlockedFunctionsCount provides a mock function with given fields: ctx, opts, timelock
func (_m *IMcmsDevInspect) TimelockGetBlockedFunctionsCount(ctx context.Context, opts *bind.CallOpts, timelock bind.Object) (uint64, error) {
	ret := _m.Called(ctx, opts, timelock)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetBlockedFunctionsCount")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object) (uint64, error)); ok {
		return rf(ctx, opts, timelock)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object) uint64); ok {
		r0 = rf(ctx, opts, timelock)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object) error); ok {
		r1 = rf(ctx, opts, timelock)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_TimelockGetBlockedFunctionsCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetBlockedFunctionsCount'
type IMcmsDevInspect_TimelockGetBlockedFunctionsCount_Call struct {
	*mock.Call
}

// TimelockGetBlockedFunctionsCount is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
func (_e *IMcmsDevInspect_Expecter) TimelockGetBlockedFunctionsCount(ctx interface{}, opts interface{}, timelock interface{}) *IMcmsDevInspect_TimelockGetBlockedFunctionsCount_Call {
	return &IMcmsDevInspect_TimelockGetBlockedFunctionsCount_Call{Call: _e.mock.On("TimelockGetBlockedFunctionsCount", ctx, opts, timelock)}
}

func (_c *IMcmsDevInspect_TimelockGetBlockedFunctionsCount_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object)) *IMcmsDevInspect_TimelockGetBlockedFunctionsCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object))
	})
	return _c
}

func (_c *IMcmsDevInspect_TimelockGetBlockedFunctionsCount_Call) Return(_a0 uint64, _a1 error) *IMcmsDevInspect_TimelockGetBlockedFunctionsCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_TimelockGetBlockedFunctionsCount_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object) (uint64, error)) *IMcmsDevInspect_TimelockGetBlockedFunctionsCount_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockGetTimestamp provides a mock function with given fields: ctx, opts, timelock, id
func (_m *IMcmsDevInspect) TimelockGetTimestamp(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte) (uint64, error) {
	ret := _m.Called(ctx, opts, timelock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockGetTimestamp")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) (uint64, error)); ok {
		return rf(ctx, opts, timelock, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) uint64); ok {
		r0 = rf(ctx, opts, timelock, id)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, []byte) error); ok {
		r1 = rf(ctx, opts, timelock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_TimelockGetTimestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockGetTimestamp'
type IMcmsDevInspect_TimelockGetTimestamp_Call struct {
	*mock.Call
}

// TimelockGetTimestamp is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - id []byte
func (_e *IMcmsDevInspect_Expecter) TimelockGetTimestamp(ctx interface{}, opts interface{}, timelock interface{}, id interface{}) *IMcmsDevInspect_TimelockGetTimestamp_Call {
	return &IMcmsDevInspect_TimelockGetTimestamp_Call{Call: _e.mock.On("TimelockGetTimestamp", ctx, opts, timelock, id)}
}

func (_c *IMcmsDevInspect_TimelockGetTimestamp_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte)) *IMcmsDevInspect_TimelockGetTimestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].([]byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_TimelockGetTimestamp_Call) Return(_a0 uint64, _a1 error) *IMcmsDevInspect_TimelockGetTimestamp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_TimelockGetTimestamp_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, []byte) (uint64, error)) *IMcmsDevInspect_TimelockGetTimestamp_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperation provides a mock function with given fields: ctx, opts, timelock, id
func (_m *IMcmsDevInspect) TimelockIsOperation(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte) (bool, error) {
	ret := _m.Called(ctx, opts, timelock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperation")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) (bool, error)); ok {
		return rf(ctx, opts, timelock, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) bool); ok {
		r0 = rf(ctx, opts, timelock, id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, []byte) error); ok {
		r1 = rf(ctx, opts, timelock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_TimelockIsOperation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperation'
type IMcmsDevInspect_TimelockIsOperation_Call struct {
	*mock.Call
}

// TimelockIsOperation is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - id []byte
func (_e *IMcmsDevInspect_Expecter) TimelockIsOperation(ctx interface{}, opts interface{}, timelock interface{}, id interface{}) *IMcmsDevInspect_TimelockIsOperation_Call {
	return &IMcmsDevInspect_TimelockIsOperation_Call{Call: _e.mock.On("TimelockIsOperation", ctx, opts, timelock, id)}
}

func (_c *IMcmsDevInspect_TimelockIsOperation_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte)) *IMcmsDevInspect_TimelockIsOperation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].([]byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_TimelockIsOperation_Call) Return(_a0 bool, _a1 error) *IMcmsDevInspect_TimelockIsOperation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_TimelockIsOperation_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, []byte) (bool, error)) *IMcmsDevInspect_TimelockIsOperation_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationDone provides a mock function with given fields: ctx, opts, timelock, id
func (_m *IMcmsDevInspect) TimelockIsOperationDone(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte) (bool, error) {
	ret := _m.Called(ctx, opts, timelock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationDone")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) (bool, error)); ok {
		return rf(ctx, opts, timelock, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) bool); ok {
		r0 = rf(ctx, opts, timelock, id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, []byte) error); ok {
		r1 = rf(ctx, opts, timelock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_TimelockIsOperationDone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationDone'
type IMcmsDevInspect_TimelockIsOperationDone_Call struct {
	*mock.Call
}

// TimelockIsOperationDone is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - id []byte
func (_e *IMcmsDevInspect_Expecter) TimelockIsOperationDone(ctx interface{}, opts interface{}, timelock interface{}, id interface{}) *IMcmsDevInspect_TimelockIsOperationDone_Call {
	return &IMcmsDevInspect_TimelockIsOperationDone_Call{Call: _e.mock.On("TimelockIsOperationDone", ctx, opts, timelock, id)}
}

func (_c *IMcmsDevInspect_TimelockIsOperationDone_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte)) *IMcmsDevInspect_TimelockIsOperationDone_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].([]byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_TimelockIsOperationDone_Call) Return(_a0 bool, _a1 error) *IMcmsDevInspect_TimelockIsOperationDone_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_TimelockIsOperationDone_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, []byte) (bool, error)) *IMcmsDevInspect_TimelockIsOperationDone_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationPending provides a mock function with given fields: ctx, opts, timelock, id
func (_m *IMcmsDevInspect) TimelockIsOperationPending(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte) (bool, error) {
	ret := _m.Called(ctx, opts, timelock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationPending")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) (bool, error)); ok {
		return rf(ctx, opts, timelock, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, []byte) bool); ok {
		r0 = rf(ctx, opts, timelock, id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, []byte) error); ok {
		r1 = rf(ctx, opts, timelock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_TimelockIsOperationPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationPending'
type IMcmsDevInspect_TimelockIsOperationPending_Call struct {
	*mock.Call
}

// TimelockIsOperationPending is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - id []byte
func (_e *IMcmsDevInspect_Expecter) TimelockIsOperationPending(ctx interface{}, opts interface{}, timelock interface{}, id interface{}) *IMcmsDevInspect_TimelockIsOperationPending_Call {
	return &IMcmsDevInspect_TimelockIsOperationPending_Call{Call: _e.mock.On("TimelockIsOperationPending", ctx, opts, timelock, id)}
}

func (_c *IMcmsDevInspect_TimelockIsOperationPending_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, id []byte)) *IMcmsDevInspect_TimelockIsOperationPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].([]byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_TimelockIsOperationPending_Call) Return(_a0 bool, _a1 error) *IMcmsDevInspect_TimelockIsOperationPending_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_TimelockIsOperationPending_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, []byte) (bool, error)) *IMcmsDevInspect_TimelockIsOperationPending_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockIsOperationReady provides a mock function with given fields: ctx, opts, timelock, clock, id
func (_m *IMcmsDevInspect) TimelockIsOperationReady(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, id []byte) (bool, error) {
	ret := _m.Called(ctx, opts, timelock, clock, id)

	if len(ret) == 0 {
		panic("no return value specified for TimelockIsOperationReady")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, []byte) (bool, error)); ok {
		return rf(ctx, opts, timelock, clock, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, []byte) bool); ok {
		r0 = rf(ctx, opts, timelock, clock, id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object, bind.Object, []byte) error); ok {
		r1 = rf(ctx, opts, timelock, clock, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_TimelockIsOperationReady_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockIsOperationReady'
type IMcmsDevInspect_TimelockIsOperationReady_Call struct {
	*mock.Call
}

// TimelockIsOperationReady is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
//   - clock bind.Object
//   - id []byte
func (_e *IMcmsDevInspect_Expecter) TimelockIsOperationReady(ctx interface{}, opts interface{}, timelock interface{}, clock interface{}, id interface{}) *IMcmsDevInspect_TimelockIsOperationReady_Call {
	return &IMcmsDevInspect_TimelockIsOperationReady_Call{Call: _e.mock.On("TimelockIsOperationReady", ctx, opts, timelock, clock, id)}
}

func (_c *IMcmsDevInspect_TimelockIsOperationReady_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object, clock bind.Object, id []byte)) *IMcmsDevInspect_TimelockIsOperationReady_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object), args[3].(bind.Object), args[4].([]byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_TimelockIsOperationReady_Call) Return(_a0 bool, _a1 error) *IMcmsDevInspect_TimelockIsOperationReady_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_TimelockIsOperationReady_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object, bind.Object, []byte) (bool, error)) *IMcmsDevInspect_TimelockIsOperationReady_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockMinDelay provides a mock function with given fields: ctx, opts, timelock
func (_m *IMcmsDevInspect) TimelockMinDelay(ctx context.Context, opts *bind.CallOpts, timelock bind.Object) (uint64, error) {
	ret := _m.Called(ctx, opts, timelock)

	if len(ret) == 0 {
		panic("no return value specified for TimelockMinDelay")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object) (uint64, error)); ok {
		return rf(ctx, opts, timelock)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, bind.Object) uint64); ok {
		r0 = rf(ctx, opts, timelock)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, bind.Object) error); ok {
		r1 = rf(ctx, opts, timelock)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_TimelockMinDelay_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockMinDelay'
type IMcmsDevInspect_TimelockMinDelay_Call struct {
	*mock.Call
}

// TimelockMinDelay is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - timelock bind.Object
func (_e *IMcmsDevInspect_Expecter) TimelockMinDelay(ctx interface{}, opts interface{}, timelock interface{}) *IMcmsDevInspect_TimelockMinDelay_Call {
	return &IMcmsDevInspect_TimelockMinDelay_Call{Call: _e.mock.On("TimelockMinDelay", ctx, opts, timelock)}
}

func (_c *IMcmsDevInspect_TimelockMinDelay_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, timelock bind.Object)) *IMcmsDevInspect_TimelockMinDelay_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].(bind.Object))
	})
	return _c
}

func (_c *IMcmsDevInspect_TimelockMinDelay_Call) Return(_a0 uint64, _a1 error) *IMcmsDevInspect_TimelockMinDelay_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_TimelockMinDelay_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, bind.Object) (uint64, error)) *IMcmsDevInspect_TimelockMinDelay_Call {
	_c.Call.Return(run)
	return _c
}

// TimelockRole provides a mock function with given fields: ctx, opts
func (_m *IMcmsDevInspect) TimelockRole(ctx context.Context, opts *bind.CallOpts) (byte, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for TimelockRole")
	}

	var r0 byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) (byte, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) byte); ok {
		r0 = rf(ctx, opts)
	} else {
		r0 = ret.Get(0).(byte)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_TimelockRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimelockRole'
type IMcmsDevInspect_TimelockRole_Call struct {
	*mock.Call
}

// TimelockRole is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
func (_e *IMcmsDevInspect_Expecter) TimelockRole(ctx interface{}, opts interface{}) *IMcmsDevInspect_TimelockRole_Call {
	return &IMcmsDevInspect_TimelockRole_Call{Call: _e.mock.On("TimelockRole", ctx, opts)}
}

func (_c *IMcmsDevInspect_TimelockRole_Call) Run(run func(ctx context.Context, opts *bind.CallOpts)) *IMcmsDevInspect_TimelockRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts))
	})
	return _c
}

func (_c *IMcmsDevInspect_TimelockRole_Call) Return(_a0 byte, _a1 error) *IMcmsDevInspect_TimelockRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_TimelockRole_Call) RunAndReturn(run func(context.Context, *bind.CallOpts) (byte, error)) *IMcmsDevInspect_TimelockRole_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyMerkleProof provides a mock function with given fields: ctx, opts, proof, root, leaf
func (_m *IMcmsDevInspect) VerifyMerkleProof(ctx context.Context, opts *bind.CallOpts, proof [][]byte, root []byte, leaf []byte) (bool, error) {
	ret := _m.Called(ctx, opts, proof, root, leaf)

	if len(ret) == 0 {
		panic("no return value specified for VerifyMerkleProof")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, [][]byte, []byte, []byte) (bool, error)); ok {
		return rf(ctx, opts, proof, root, leaf)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts, [][]byte, []byte, []byte) bool); ok {
		r0 = rf(ctx, opts, proof, root, leaf)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts, [][]byte, []byte, []byte) error); ok {
		r1 = rf(ctx, opts, proof, root, leaf)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_VerifyMerkleProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyMerkleProof'
type IMcmsDevInspect_VerifyMerkleProof_Call struct {
	*mock.Call
}

// VerifyMerkleProof is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
//   - proof [][]byte
//   - root []byte
//   - leaf []byte
func (_e *IMcmsDevInspect_Expecter) VerifyMerkleProof(ctx interface{}, opts interface{}, proof interface{}, root interface{}, leaf interface{}) *IMcmsDevInspect_VerifyMerkleProof_Call {
	return &IMcmsDevInspect_VerifyMerkleProof_Call{Call: _e.mock.On("VerifyMerkleProof", ctx, opts, proof, root, leaf)}
}

func (_c *IMcmsDevInspect_VerifyMerkleProof_Call) Run(run func(ctx context.Context, opts *bind.CallOpts, proof [][]byte, root []byte, leaf []byte)) *IMcmsDevInspect_VerifyMerkleProof_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts), args[2].([][]byte), args[3].([]byte), args[4].([]byte))
	})
	return _c
}

func (_c *IMcmsDevInspect_VerifyMerkleProof_Call) Return(_a0 bool, _a1 error) *IMcmsDevInspect_VerifyMerkleProof_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_VerifyMerkleProof_Call) RunAndReturn(run func(context.Context, *bind.CallOpts, [][]byte, []byte, []byte) (bool, error)) *IMcmsDevInspect_VerifyMerkleProof_Call {
	_c.Call.Return(run)
	return _c
}

// ZeroHash provides a mock function with given fields: ctx, opts
func (_m *IMcmsDevInspect) ZeroHash(ctx context.Context, opts *bind.CallOpts) ([]byte, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ZeroHash")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) ([]byte, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *bind.CallOpts) []byte); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *bind.CallOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IMcmsDevInspect_ZeroHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZeroHash'
type IMcmsDevInspect_ZeroHash_Call struct {
	*mock.Call
}

// ZeroHash is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *bind.CallOpts
func (_e *IMcmsDevInspect_Expecter) ZeroHash(ctx interface{}, opts interface{}) *IMcmsDevInspect_ZeroHash_Call {
	return &IMcmsDevInspect_ZeroHash_Call{Call: _e.mock.On("ZeroHash", ctx, opts)}
}

func (_c *IMcmsDevInspect_ZeroHash_Call) Run(run func(ctx context.Context, opts *bind.CallOpts)) *IMcmsDevInspect_ZeroHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*bind.CallOpts))
	})
	return _c
}

func (_c *IMcmsDevInspect_ZeroHash_Call) Return(_a0 []byte, _a1 error) *IMcmsDevInspect_ZeroHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IMcmsDevInspect_ZeroHash_Call) RunAndReturn(run func(context.Context, *bind.CallOpts) ([]byte, error)) *IMcmsDevInspect_ZeroHash_Call {
	_c.Call.Return(run)
	return _c
}

// NewIMcmsDevInspect creates a new instance of IMcmsDevInspect. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIMcmsDevInspect(t interface {
	mock.TestingT
	Cleanup(func())
}) *IMcmsDevInspect {
	mock := &IMcmsDevInspect{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
